<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">022bd4189f711e17546c580678b76e0dae2d6691</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Reflection.Emit.OpCodes.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">51a73c478e7015271f070b6e339a66dafb551c30</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2f50d86bdb06d2a9fbaffba085b6e702fa564f1f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <ph id="ph1">&lt;xref href="System.Reflection.Emit.ILGenerator"&gt;&lt;/xref&gt;</ph> class members (such as <ph id="ph2">&lt;xref href="System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)"&gt;&lt;/xref&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Adds two values and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>58</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Adds two numeric values, returning a new numeric value.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer addition wraps, rather than saturates.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, assuming 8-bit integers where <ph id="ph1">`value1`</ph> is set to 255 and <ph id="ph2">`value2`</ph> is set to 1, the wrapped result is 0 rather than 256.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>operand</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>value1 type</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>value2 type</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>result type</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>D6</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>add.ovf</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>Adds two signed integer values with an overflow check.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can perform this operation on signed integers.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>operand</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>value1 type</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>value2 type</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>result type</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>D7</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>add.ovf.un</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Adds two unsigned integer values with an overflow check.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can perform this operation on signed integers.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>operand</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>value1 type</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>value2 type</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>result type</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>add</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instruction</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>5F</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>and</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Determines the bitwise AND of two integer values.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> and <ph id="ph2">`value2`</ph> are popped from the stack; the bitwise AND of the two values is computed.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`and`</ph> instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`And`</ph> is an integer-specific operation.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`and`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Returns an unmanaged pointer to the argument list of the current method.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 00</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>arglist</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Returns an argument list handle for the current method.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>No evaluation stack behaviors are performed by this operation.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`arglist`</ph> instruction returns an opaque handle (an unmanaged pointer, of type <ph id="ph2">`native int`</ph>) that represents the argument list of the current method.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>This handle is valid only during the lifetime of the current method.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can, however, pass the handle to other methods as long as the current method is on the thread of control.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only execute the <ph id="ph1">`arglist`</ph> instruction within a method that takes a variable number of arguments.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`arglist`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if two values are equal.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>beq <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if the two values are equal.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`beq`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The acceptable operand types are encapsulated below:</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if two values are equal.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>beq.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if equal, short form</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`beq.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>The acceptable operand types are encapsulated below:</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is greater than or equal to the second value.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>3C <ph id="ph1">`&lt;int32&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>bge <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bge`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>2F <ph id="ph1">`&lt;int8&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>bge.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bge.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>41 <ph id="ph1">`&lt;int32&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>bge.un <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bge.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>bge.un.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bge.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is greater than the second value.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>bgt <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bgt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>bgt.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bgt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>bgt.un <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bgt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>bgt.un.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bgt.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>3E <ph id="ph1">`&lt;int32&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>ble <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ble`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>31 <ph id="ph1">`&lt;int8&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>ble.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ble.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) instruction followed by a<ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>43 <ph id="ph1">`&lt;int32&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>ble.un <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ble.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>36 <ph id="ph1">`&lt;int8&gt;`</ph></source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>ble.un.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ble.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is less than the second value.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>blt <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`blt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>blt.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`blt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT">
          <source>blt.un <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source>37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source>blt.un.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>bne.un <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>bne.un.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Converts a value type to an object reference (type <ph id="ph1">`O`</ph>).</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>box <ph id="ph1">`valTypeToken`</ph></source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert a value type (of the type specified in <ph id="ph1">`valTypeToken`</ph>) to a true object reference.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value type is popped from the stack; the <ph id="ph1">`box`</ph> operation is performed.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to the resulting "boxed" value type is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>A 'raw' form used when a value type is embedded within another object or on the stack.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`box`</ph> instruction converts the 'raw' (unboxed) value type into an object reference (type <ph id="ph2">`O`</ph>).</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`valTypeToken`</ph> is a metadata token indicating the type of the value type on the stack.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the class cannot be found.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`box`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Unconditionally transfers control to a target instruction.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>br <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branches to a target instruction at the specified offset.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>No evaluation stack behaviors are performed by this operation.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`br`</ph> instruction unconditionally transfers control to a target instruction.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>Unconditionally transfers control to a target instruction (short form).</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>br.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branches to a target instruction at the specified offset, short form.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>No evaluation stack behaviors are performed by this operation.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`br.s`</ph> instruction unconditionally transfers control to a target instruction.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>01</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>break</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>inform a debugger that a breakpoint has been reached.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>No evaluation stack behaviors are performed by this operation.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`break`</ph> instruction is for debugging support.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>It signals the CLI to inform the debugger that a break point has been tripped.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has no other effect on the interpreter state.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`break`</ph> instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`break`</ph> instruction can trap to a debugger, do nothing, or raise a security exception.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The exact behavior is implementation-defined.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`break`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`false`</ph>, a null reference (<ph id="ph3">`Nothing`</ph> in Visual Basic), or zero.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>brfalse <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>brnull <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>brzero <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`brfalse`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`false`</ph>, a null reference, or zero.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>brfalse.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>brnull.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>brzero.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>, short form.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`brfalse.s`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`true`</ph>, not null, or non-zero.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>brtrue <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>brinst <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>).</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`brtrue`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>Transfers control to a target instruction (short form) if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`true`</ph>, not null, or non-zero.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>brtrue.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>brinst.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>), short form.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`brtrue.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>Calls the method indicated by the passed method descriptor.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>call <ph id="ph1">`methodDesc`</ph></source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the method described by <ph id="ph1">`methodDesc`</ph>.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`call`</ph> instruction calls the method indicated by the method descriptor passed with the instruction.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`call`</ph> instruction can be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix instruction to specify that the current method state should be released before transferring control.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the execution continues silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arguments are placed on the stack in left-to-right order.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are three important special cases:</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>The instance reference must not be a null reference.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>The signature carried in the metadata does not contain an entry in the parameter list for the <ph id="ph1">`this`</ph> pointer; instead, it uses a bit to indicate whether the method requires passing the <ph id="ph2">`this`</ph> pointer.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is valid to call a virtual method using <ph id="ph1">`call`</ph> (rather than <ph id="ph2">`callvirt`</ph>); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that a delegate's <ph id="ph1">`Invoke`</ph> method can be called with either the <ph id="ph2">`call`</ph> or <ph id="ph3">`callvirt`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if system security does not grant the caller access to the called method.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction instead of emitting a <ph id="ph3">`call`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`call`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> method is provided for <ph id="ph2">`varargs`</ph> calls.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method for normal calls.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>calli <ph id="ph1">`callSiteDescr`</ph></source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calls the method pointed to with arguments described by the calling convention.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method entry pointer is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the method entry pointer are popped from the stack; the call to the method is performed.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`calli`</ph> instruction calls the method entry pointer with the arguments <ph id="ph2">`arg1`</ph> through <ph id="ph3">`argN`</ph>.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>The types of these arguments are described by the specific calling convention (<ph id="ph1">`callSiteDesc`</ph>).</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`calli`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> prefix (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) to specify that the current method state should be released before transferring control.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such a pointer can be created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> instructions, or passed in from native code.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>The calling convention is not checked dynamically, so code that uses a <ph id="ph1">`calli`</ph> instruction does not work correctly if the destination does not actually use the specified calling convention.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arguments are placed on the stack in left-to-right order.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if the system security does not grant the caller access to the called method.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> methods can be used to perform a <ph id="ph2">`calli`</ph> instruction on the stack.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">`calli`</ph> should be called through the below methods rather than using the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> class to place the instruction directly on the stack.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>callvirt <ph id="ph1">`method`</ph></source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calls a specific method associated with <ph id="ph1">`obj`</ph>.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the object reference <ph id="ph3">`obj`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <ph id="ph4">`obj`</ph> referred to by the method metadata token.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`callvirt`</ph> instruction calls a late-bound method on an object.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the method is chosen based on the runtime type of <ph id="ph1">`obj`</ph> rather than the compile-time class visible in the method pointer.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Callvirt`</ph> can be used to call both virtual and instance methods.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`callvirt`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix to specify that the current stack frame should be released before transferring control.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method metadata token provides the name, class and signature of the method to call.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>The class associated with <ph id="ph1">`obj`</ph> is the class of which it is an instance.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the class defines a non-static method that matches the indicated method name and signature, this method is called.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise all classes in the base class chain of this class are checked in order.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is an error if no method is found.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Callvirt`</ph> pops the object and the associated arguments off the evaluation stack before calling the method.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method has a return value, it is pushed on the stack upon method completion.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the callee side, the <ph id="ph1">`obj`</ph> parameter is accessed as argument 0, <ph id="ph2">`arg1`</ph> as argument 1, and so on.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>The arguments are placed on the stack in left-to-right order.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>The instance reference <ph id="ph1">`obj`</ph> (always required for <ph id="ph2">`callvirt`</ph>) must be pushed before any of the user-visible arguments.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that a virtual method can also be called using the<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <ph id="ph2">`obj`</ph> or any of its base classes.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if obj is null.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown if system security does not grant the caller access to the called method.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>The security check may occur when the CIL is converted to native code rather than at run time.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`callvirt`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>Attempts to cast an object passed by reference to the specified class.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>castclass <ph id="ph1">`class`</ph></source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Casts an object to a new object of type <ph id="ph1">`class`</ph>.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference is popped from the stack; the referenced object is cast as the specified <ph id="ph1">`class`</ph>.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>If successful, a new object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`castclass`</ph> instruction attempts to cast the object reference (type <ph id="ph2">`O`</ph>) atop the stack to a specified class.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>The new class is specified by a metadata token indicating the desired class.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the object reference is a null reference, <ph id="ph1">`castclass`</ph> succeeds and returns the new object as a null reference.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if obj cannot be cast to class.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`castclass`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>Compares two values.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>If they are equal, the integer value 1 <ph id="ph1">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">`int32`</ph>) is pushed onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 01</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>ceq</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> equals <ph id="ph2">`value2`</ph>; else pushes 0.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is compared to <ph id="ph4">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ceq`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, then 1 (of type <ph id="ph3">`int32`</ph>) is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise 0 (of type <ph id="ph1">`int32`</ph>) is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point number, <ph id="ph1">`ceq`</ph> will return 0 if the numbers are unordered (either or both are NaN).</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>The infinite values are equal to themselves.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ceq`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source>Compares two values.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">`int32`</ph>) is pushed onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 02</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>cgt</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`cgt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point numbers, <ph id="ph1">`cgt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>Compares two unsigned or unordered values.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">`int32`</ph>) is pushed onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 03</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>cgt.un</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt.un`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is <ph id="ph2">`true`</ph> :</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>Throws <ph id="ph1">&lt;xref href="System.ArithmeticException"&gt;&lt;/xref&gt;</ph> if value is not a finite number.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>C3</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>ckfinite</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if value is not a finite number.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack..</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the <ph id="ph2">`ckfinite`</ph> instruction is performed on it.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack if no exception is thrown.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ckfinite instruction`</ph> throws <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> if <ph id="ph3">`value`</ph> (a floating-point number) is either a "not a number" value (NaN) or a <ph id="ph4">`+-`</ph> infinity value.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Ckfinite`</ph> leaves the value on the stack if no exception is thrown.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source>Execution is unspecified if <ph id="ph1">`value`</ph> is not a floating-point number.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> is thrown if <ph id="ph2">`value`</ph> is not a 'normal' number.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that a special exception or a derived class of <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> may be more appropriate, passing the incorrect value to the exception handler.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ckfinite`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>Compares two values.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>If the first value is less than the second, the integer value 1 <ph id="ph1">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">`int32`</ph>) is pushed onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 04</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT">
          <source>clt</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is: <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`clt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point numbers, <ph id="ph1">`clt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>Compares the unsigned or unordered values <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value1</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value2</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value1</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value2</ph><ept id="p2">&lt;/code&gt;</ept>, then the integer value 1 <ph id="ph3">`(int32`</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph4">`int32`</ph>) is pushed onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 05</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>clt.un</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt.un`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`clt.un`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is true:</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> (as for <ph id="ph3">`clt`</ph>).</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>Constrains the type on which a virtual method call is made.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT">
          <source>constrained.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call a virtual method on a type constrained to be type <ph id="ph1">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`constrained`</ph> prefix is permitted only on a <ph id="ph2">`callvirt`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT">
          <source>The state of the MSIL stack at this point must be as follows:</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT">
          <source>A managed pointer, <ph id="ph1">`ptr`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of <ph id="ph1">`ptr`</ph> must be a managed pointer (<ph id="ph2">`&amp;`</ph>) to <ph id="ph3">`thisType`</ph>.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is different from the case of an unprefixed <ph id="ph1">`callvirt`</ph> instruction, which expects a reference of <ph id="ph2">`thisType`</ph>.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack, just as with an unprefixed <ph id="ph3">`callvirt`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`constrained`</ph> prefix is designed to allow <ph id="ph2">`callvirt`</ph> instructions to be made in a uniform way independent of whether <ph id="ph3">`thisType`</ph> is a value type or a reference type.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> instruction has been prefixed by <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, the instruction is executed as follows:</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`thisType`</ph> is a reference type (as opposed to a value type) then <ph id="ph2">`ptr`</ph> is dereferenced and passed as the 'this' pointer to the <ph id="ph3">`callvirt`</ph> of <ph id="ph4">`method`</ph>.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> implements <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is passed unmodified as the 'this' pointer to a <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> instruction, for the implementation of <ph id="ph7">`method`</ph> by <ph id="ph8">`thisType`</ph>.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> does not implement <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is dereferenced, boxed, and passed as the 'this' pointer to the <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT">
          <source>This last case can occur only when <ph id="ph1">`method`</ph> was defined on <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, or<ph id="ph4">&lt;xref:System.Enum&gt;</ph> and not overridden by <ph id="ph5">`thisType`</ph>.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the boxing causes a copy of the original object to be made.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because none of the methods of <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Enum&gt;</ph> modify the state of the object, this fact cannot be detected.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`constrained`</ph> prefix supports IL generators that create generic code.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>Normally the <ph id="ph1">`callvirt`</ph> instruction is not valid on value types.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <ph id="ph1">`ptr`</ph> and the method being called.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, when <ph id="ph1">`ptr`</ph> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`constrained`</ph> opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <ph id="ph2">`ptr`</ph> is a value type or a reference type.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is intended for the case where <ph id="ph1">`thisType`</ph> is a generic type variable, the <ph id="ph2">`constrained`</ph> prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix also avoids potential versioning problems with value types.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if a value type <ph id="ph1">`V`</ph> overrides the Object.ToString() method, a <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> instruction is emitted; if it does not, a <ph id="ph4">`box`</ph> instruction and a <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> instruction are emitted.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT">
          <source>A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`constrained`</ph> prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`constrained`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT">
          <source>D3</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.i</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`int8`</ph>, then extends (pads) it to <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT">
          <source>67</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.i1</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`int16`</ph>, then extends (pads) it to <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT">
          <source>68</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.i2</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT">
          <source>69</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.i4</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT">
          <source>6A</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.i8</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">`native int`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT">
          <source>D4</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">`native int`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT">
          <source>8A</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i.un</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">`int8`</ph> and extends it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT">
          <source>B3</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i1</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">`int8`</ph> and extends it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT">
          <source>82</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i1.un</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">`int16`</ph> and extending it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT">
          <source>B5</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i2</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">`int16`</ph> and extends it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT">
          <source>83</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i2.un</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">`int32`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT">
          <source>B7</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i4</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">`int32`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT">
          <source>84</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i4.un</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">`int64`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT">
          <source>B9</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i8</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">`int64`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT">
          <source>85</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.i8.un</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.i8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">`unsigned native int`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT">
          <source>D5</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">`unsigned native int`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT">
          <source>8B</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u.un</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts un unsigned value to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.uvf.u.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">`unsigned int8`</ph> and extends it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT">
          <source>B4</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u1</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">`unsigned int8`</ph> and extends it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT">
          <source>86</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u1.un</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">`unsigned int16`</ph> and extends it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT">
          <source>B6</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u2</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">`unsigned int16`</ph> and extends it to <ph id="ph2">`int32`</ph>, throwing <ph id="ph3">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT">
          <source>87</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u2.un</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">`unsigned int32`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT">
          <source>B8</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u4</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">`unsigned int32`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT">
          <source>88</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u4.un</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">`unsigned int64`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT">
          <source>BA</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u8</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">`unsigned int64`</ph>, throwing <ph id="ph2">&lt;xref href="System.OverflowException"&gt;&lt;/xref&gt;</ph> on overflow.</source>
        </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT">
          <source>89</source>
        </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.ovf.u8.un</source>
        </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
        </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.ovf.u8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve">
          <source>Converts the unsigned integer value on top of the evaluation stack to <ph id="ph1">`float32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT">
          <source>76</source>
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.r.un</source>
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert unsigned integer to floating-point, pushing <ph id="ph1">`F`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.r.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the <ph id="ph1">`result`</ph> returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.r.un`</ph> operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a <ph id="ph2">`float32`</ph>, if this is wide enough to represent the integer without loss of precision, or else a <ph id="ph3">`float64`</ph>.</source>
        </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`float32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT">
          <source>6B</source>
        </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.r4</source>
        </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`float32`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.r4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`float64`</ph>.</source>
        </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT">
          <source>6C</source>
        </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.r8</source>
        </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`float64`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.r8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`unsigned native int`</ph>, and extends it to <ph id="ph2">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT">
          <source>E0</source>
        </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.u</source>
        </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`unsigned native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`unsigned int8`</ph>, and extends it to <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT">
          <source>D2</source>
        </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.u1</source>
        </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`unsigned int16`</ph>, and extends it to <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT">
          <source>D1</source>
        </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.u2</source>
        </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`unsigned int32`</ph>, and extends it to <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT">
          <source>6D</source>
        </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.u4</source>
        </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`unsigned int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">`unsigned int64`</ph>, and extends it to <ph id="ph2">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT">
          <source>6E</source>
        </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT">
          <source>conv.u8</source>
        </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
        </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
        </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`conv.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
        </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
        </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
        </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
        </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
        </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
        </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
        </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exceptions are ever thrown when using this field.</source>
        </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
        </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve">
          <source>Copies a specified number bytes from a source address to a destination address.</source>
        </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 17</source>
        </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT">
          <source>cpblk</source>
        </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT">
          <source>Copy data from one memory block to another.</source>
        </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT">
          <source>The destination address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT">
          <source>The source address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes to copy is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</source>
        </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`cpblk`</ph> instruction copies a number (type <ph id="ph2">`unsigned int32`</ph>) of bytes from a source address (of type <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, or <ph id="ph5">`&amp;`</ph>) to a destination address (of type <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, or <ph id="ph8">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of <ph id="ph1">`cpblk`</ph> is unspecified if the source and destination areas overlap.</source>
        </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`cpblk`</ph> assumes that both the source and destination addressed are aligned to the natural size of the machine.</source>
        </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`cpblk`</ph> instruction can be immediately preceded by the <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> instruction to indicate that either the source or the destination is unaligned.</source>
        </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`cpblk`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>prefix instruction.</source>
        </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpblk`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve">
          <source>Copies the value type located at the address of an object (type <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph> or <ph id="ph3">`native int`</ph>) to the address of the destination object (type <ph id="ph4">`&amp;`</ph>, <ph id="ph5">`*`</ph> or <ph id="ph6">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT">
          <source>70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT">
          <source>cpobj <ph id="ph1">`classTok`</ph></source>
        </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT">
          <source>Copies a value type from a source object to a destination object.</source>
        </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT">
          <source>The destination object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT">
          <source>The source object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT">
          <source>The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</source>
        </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of <ph id="ph1">`cpobj`</ph> is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <ph id="ph2">`classTok`</ph> (a <ph id="ph3">`typeref`</ph> or <ph id="ph4">`typedef`</ph>), or if <ph id="ph5">`classTok`</ph> does not represent a value type.</source>
        </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpobj`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve">
          <source>Divides two values and pushes the result as a floating-point (type <ph id="ph1">`F`</ph>) or quotient (type <ph id="ph2">`int32`</ph>) onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT">
          <source>5B</source>
        </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT">
          <source>div</source>
        </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT">
          <source>Divides two values to return a quotient or floating-point result.</source>
        </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 satisfies the following conditions:</source>
        </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT">
          <source>&amp;#124; <ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, and:</source>
        </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT">
          <source>sign(<ph id="ph1">`result`</ph>) = +, if sign(<ph id="ph2">`value1`</ph>) = sign(<ph id="ph3">`value2`</ph>), or -, if sign(<ph id="ph4">`value1`</ph>) ~= sign(<ph id="ph5">`value2`</ph>)</source>
        </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`div`</ph> instruction computes the result and pushes it on the stack.</source>
        </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer division truncates towards zero.</source>
        </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Division of a finite number by zero produces the correctly signed infinite value.</source>
        </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</source>
        </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any number divided by infinity will produce a zero value.</source>
        </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if the result cannot be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can happen if <ph id="ph1">`value1`</ph> is the maximum negative value, and <ph id="ph2">`value2`</ph> is -1.</source>
        </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that on Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint div -1).</source>
        </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point operations never throw an exception (they produce NaNs or infinities instead).</source>
        </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve">
          <source>Divides two unsigned integer values and pushes the result (<ph id="ph1">`int32`</ph>) onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT">
          <source>5C</source>
        </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT">
          <source>div.un</source>
        </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT">
          <source>Divides two values, unsigned, returning a quotient.</source>
        </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`div.un`</ph> instruction computes <ph id="ph2">`value1`</ph> divided by <ph id="ph3">`value2`</ph>, both taken as unsigned integers, and pushes the <ph id="ph4">`result`</ph> on the stack.</source>
        </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve">
          <source>Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT">
          <source>25</source>
        </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT">
          <source>dup</source>
        </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT">
          <source>Duplicates the value on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped off of the stack for duplication.</source>
        </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack.</source>
        </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT">
          <source>A duplicate value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`dup`</ph> instruction duplicates the top element of the stack, and leaves two identical values atop it.</source>
        </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`dup`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve">
          <source>Transfers control from the <ph id="ph1">`filter`</ph> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</source>
        </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 11</source>
        </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT">
          <source>endfilter</source>
        </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT">
          <source>End filter clause of SEH exception handling.</source>
        </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack; <ph id="ph2">`endfilter`</ph> is executed and control is transferred to the exception handler.</source>
        </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Value`</ph> (which must be of type <ph id="ph2">`int32`</ph> and is one of a specific set of values) is returned from the filter clause.</source>
        </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should be one of:</source>
        </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) to continue searching for an exception handler</source>
        </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</source>
        </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT">
          <source>Upon discovery, the handler is executed.</source>
        </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT">
          <source>Other integer values will produce unspecified results.</source>
        </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT">
          <source>The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</source>
        </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`endfilter`</ph> instruction must be the last instruction in the filter's code block (hence there can only be one <ph id="ph2">`endfilter`</ph> for any single filter block).</source>
        </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT">
          <source>After executing the <ph id="ph1">`endfilter`</ph> instruction, control logically flows back to the CLI exception handling mechanism.</source>
        </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control cannot be transferred into a filter block except through the exception mechanism.</source>
        </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control cannot be transferred out of a filter block except through the use of a <ph id="ph1">`throw`</ph> instruction or by executing the final <ph id="ph2">`endfilter`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot embed a <ph id="ph1">`try`</ph> block within a <ph id="ph2">`filter`</ph> block.</source>
        </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exception is thrown inside the <ph id="ph1">`filter`</ph> block, it is intercepted and a value of 0 (<ph id="ph2">`exception_continue_search`</ph>) is returned.</source>
        </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfilter`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve">
          <source>Transfers control from the <ph id="ph1">`fault`</ph> or <ph id="ph2">`finally`</ph> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</source>
        </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT">
          <source>DC</source>
        </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT">
          <source>endfinally</source>
        </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT">
          <source>endfault</source>
        </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ends the <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph> clause of an exception block.</source>
        </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are no stack transition behaviors for this instruction.</source>
        </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Endfinally`</ph> and <ph id="ph2">`endfault`</ph> signal the end of the <ph id="ph3">`finally`</ph> or <ph id="ph4">`fault`</ph> clause so that stack unwinding can continue until the exception handler is invoked.</source>
        </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`endfinally`</ph> or <ph id="ph2">`endfault`</ph> instruction transfers control back to the CLI exception mechanism.</source>
        </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT">
          <source>The mechanism then searches for the next <ph id="ph1">`finally`</ph> clause in the chain if the protected block was exited with a leave instruction.</source>
        </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the protected block was exited with an exception, the CLI will search for the next <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph>, or enter the exception handler chosen during the first pass of exception handling.</source>
        </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">`endfinally`</ph> instruction might only appear lexically within a <ph id="ph2">`finally`</ph> block.</source>
        </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike the <ph id="ph1">`endfilter`</ph> instruction, there is no requirement that the block end with an <ph id="ph2">`endfinally`</ph> instruction, and there can be as many <ph id="ph3">`endfinally`</ph> instructions within the block as required.</source>
        </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT">
          <source>These same restrictions apply to the <ph id="ph1">`endfault`</ph> instruction and the <ph id="ph2">`fault`</ph> block.</source>
        </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control cannot be transferred into a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the exception mechanism.</source>
        </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control cannot be transferred out of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the use of a <ph id="ph3">`throw`</ph> instruction or executing the <ph id="ph4">`endfinally`</ph> (or <ph id="ph5">`endfault`</ph>) instruction.</source>
        </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, you cannot "fall out" of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block or to execute a <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction within a <ph id="ph5">`finally`</ph> (or <ph id="ph6">`fault`</ph>) block.</source>
        </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the <ph id="ph1">`endfault`</ph> and <ph id="ph2">`endfinally`</ph> instructions are aliases - they correspond to the same opcode.</source>
        </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) opcode, as well as the <ph id="ph4">`ILGenerator`</ph> method <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.EndExceptionBlock()</source>
        </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve">
          <source>Initializes a specified block of memory at a specific address to a given size and initial value.</source>
        </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 18</source>
        </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT">
          <source>initblk</source>
        </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Set each location in a block of memory to a given value.</source>
        </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT">
          <source>A starting address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT">
          <source>An initialization value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes to initialize is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</source>
        </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`initblk`</ph> instruction sets the number (<ph id="ph2">`unsigned int32`</ph>) of bytes starting at the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) to the initialization value (of type <ph id="ph6">`unsigned int8`</ph>).</source>
        </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`initblk`</ph> assumes that the starting address is aligned to the natural size of the machine.</source>
        </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`initblk`</ph> instructions can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initblk`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve">
          <source>Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</source>
        </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></source>
        </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initializes a value type.</source>
        </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address of the value type to initialize is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value type at the specified address is initialized as type <ph id="ph1">`typeTok`</ph>.</source>
        </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`initobj`</ph> instruction initializes each field of the value type specified by the pushed address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or <ph id="ph4">`*`</ph>) to a null reference or a 0 of the appropriate primitive type.</source>
        </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT">
          <source>After this method is called, the instance is ready for a constructor method to be called.</source>
        </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeTok`</ph> is a reference type, this instruction has the same effect as <ph id="ph2">`ldnull`</ph> followed by <ph id="ph3">`stind.ref`</ph>.</source>
        </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> does not call the constructor method.</source>
        </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Initobj`</ph> is intended for initializing value types, while <ph id="ph2">`newobj`</ph> is used to allocate and initialize objects.</source>
        </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initobj`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve">
          <source>Tests whether an object reference (type <ph id="ph1">`O`</ph>) is an instance of a particular class.</source>
        </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT">
          <source>75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT">
          <source>isinst <ph id="ph1">`class`</ph></source>
        </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Tests if an object reference is an instance of <ph id="ph1">`class`</ph>, returning either a null reference or an instance of that class or interface.</source>
        </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference is popped from the stack and tested to see if it is an instance of the class passed in <ph id="ph1">`class`</ph>.</source>
        </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result (either an object reference or a null reference) is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Class`</ph> is a metadata token indicating the desired class.</source>
        </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the class of the object on the top of the stack implements <ph id="ph1">`class`</ph> (if <ph id="ph2">`class`</ph> is an interface) or is a derived class of <ph id="ph3">`class`</ph> (if <ph id="ph4">`class`</ph> is a regular class) then it is cast to type <ph id="ph5">`class`</ph> and the result is pushed on the stack, exactly as though <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> had been called.</source>
        </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, a null reference is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the object reference itself is a null reference, then <ph id="ph1">`isinst`</ph> likewise returns a null reference.</source>
        </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
        </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`isinst`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve">
          <source>Exits current method and jumps to specified method.</source>
        </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT">
          <source>27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT">
          <source>jmp <ph id="ph1">`method`</ph></source>
        </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT">
          <source>Exit current method and jump to specified method.</source>
        </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are no stack transition behaviors for this instruction.</source>
        </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`jmp`</ph> (jump) instruction transfers control to the method specified by <ph id="ph2">`method`</ph>, which is a metadata token for a method reference.</source>
        </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current arguments are transferred to the destination method.</source>
        </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT">
          <source>The evaluation stack must be empty when this instruction is executed.</source>
        </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT">
          <source>The calling convention, number and type of arguments at the destination address must match that of the current method.</source>
        </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`jmp`</ph> instruction cannot be used to transferred control out of a <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
        </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`jmp`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
        </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve">
          <source>Loads an argument (referenced by a specified index value) onto the stack.</source>
        </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarg <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack.</source>
        </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
        </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
        </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
        </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, short)</source>
        </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve">
          <source>Loads the argument at index 0 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT">
          <source>02</source>
        </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarg.0</source>
        </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT">
          <source>Load argument 0 onto stack</source>
        </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT">
          <source>The argument value at index 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction is an efficient encoding for loading the argument value at index 0.</source>
        </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction pushes the argument indexed at 0 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
        </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
        </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.0`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve">
          <source>Loads the argument at index 1 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT">
          <source>03</source>
        </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarg.1</source>
        </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT">
          <source>Load argument 1 onto stack.</source>
        </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT">
          <source>The argument value at index 1 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction is an efficient encoding for loading the argument value at index 1.</source>
        </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction pushes the argument indexed at 1 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
        </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
        </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve">
          <source>Loads the argument at index 2 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT">
          <source>04</source>
        </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarg.2</source>
        </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT">
          <source>Load argument 2 onto stack.</source>
        </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT">
          <source>The argument value at index 2 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction is an efficient encoding for loading the argument value at index 2.</source>
        </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction pushes the argument indexed at 2 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
        </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
        </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve">
          <source>Loads the argument at index 3 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT">
          <source>05</source>
        </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarg.3</source>
        </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT">
          <source>Load argument 3 onto stack.</source>
        </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT">
          <source>The argument value at index 3 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction is an efficient encoding for loading the argument value at index 3.</source>
        </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction pushes the argument indexed at 3 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
        </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
        </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.3`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve">
          <source>Loads the argument (referenced by a specified short form index) onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT">
          <source>0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarg.s <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack, short form.</source>
        </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction is an efficient encoding for loading arguments indexed from 4 through 255.</source>
        </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
        </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
        </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
        </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, byte)</source>
        </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve">
          <source>Load an argument address onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarga <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>.</source>
        </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarga`</ph> instruction fetches the address (of type <ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
        </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
        </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
        </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldarga`</ph> is used for by-ref parameter passing.</source>
        </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> should be used.</source>
        </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, short)</source>
        </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve">
          <source>Load an argument address, in short form, onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT">
          <source>0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldarga.s <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>, short form.</source>
        </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldarga.s`</ph> (the short form of <ph id="ph2">`ldarga`</ph>) should be used for argument numbers 0 through 255, and is a more efficient encoding.</source>
        </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldarga.s`</ph> instruction fetches the address (of type<ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
        </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
        </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
        </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldarga.s`</ph> is used for by-ref parameter passing.</source>
        </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> should be used.</source>
        </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, byte)</source>
        </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve">
          <source>Pushes a supplied value of type <ph id="ph1">`int32`</ph> onto the evaluation stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT">
          <source>20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4 <ph id="ph1">`num`</ph></source>
        </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the value <ph id="ph1">`num`</ph> onto the stack.</source>
        </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</source>
        </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT">
          <source>All short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT">
          <source>Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</source>
        </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are three ways to push an 8 byte integer constant onto the stack</source>
        </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> instruction for constants that must be expressed in more than 32 bits.</source>
        </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> instruction followed by a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that require 9 to 32 bits.</source>
        </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use a short form instruction followed by a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that can be expressed in 8 or fewer bits.</source>
        </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, int)</source>
        </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 0 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT">
          <source>16</source>
        </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.0</source>
        </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 0 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.0`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 1 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT">
          <source>17</source>
        </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.1</source>
        </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 1 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 1 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 2 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT">
          <source>18</source>
        </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.2</source>
        </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 2 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 2 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 3 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT">
          <source>19</source>
        </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.3</source>
        </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 3 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 3 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.3`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 4 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT">
          <source>1A</source>
        </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.4</source>
        </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 4 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 4 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 5 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT">
          <source>1B</source>
        </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.5</source>
        </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 5 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 5 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.5`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 6 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT">
          <source>1C</source>
        </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.6</source>
        </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 6 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 6 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.6`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 7 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT">
          <source>1D</source>
        </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.7</source>
        </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 7 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 7 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.7`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of 8 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT">
          <source>1E</source>
        </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.8</source>
        </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes 8 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value 8 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve">
          <source>Pushes the integer value of -1 onto the evaluation stack as an <ph id="ph1">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT">
          <source>15</source>
        </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.m1</source>
        </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes -1 onto the stack.</source>
        </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value -1 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a special short encoding for the push of the integer value 0.</source>
        </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT">
          <source>All special short encodings push 4 byte integers on the stack.</source>
        </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.m1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve">
          <source>Pushes the supplied <ph id="ph1">`int8`</ph> value onto the evaluation stack as an <ph id="ph2">`int32`</ph>, short form.</source>
        </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT">
          <source>1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i4.s <ph id="ph1">`num`</ph></source>
        </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int32`</ph>, short form.</source>
        </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldc.i4.s`</ph> is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, byte)</source>
        </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve">
          <source>Pushes a supplied value of type <ph id="ph1">`int64`</ph> onto the evaluation stack as an <ph id="ph2">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT">
          <source>21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.i8 <ph id="ph1">`num`</ph></source>
        </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT">
          <source>This encoding pushes an <ph id="ph1">`int64`</ph> value onto the stack.</source>
        </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, long)</source>
        </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve">
          <source>Pushes a supplied value of type <ph id="ph1">`float32`</ph> onto the evaluation stack as type <ph id="ph2">`F`</ph> (float).</source>
        </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT">
          <source>22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.r4 <ph id="ph1">`num`</ph></source>
        </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT">
          <source>This encoding pushes a <ph id="ph1">`float32`</ph> value onto the stack.</source>
        </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, single)</source>
        </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve">
          <source>Pushes a supplied value of type <ph id="ph1">`float64`</ph> onto the evaluation stack as type <ph id="ph2">`F`</ph> (float).</source>
        </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT">
          <source>23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldc.r8 <ph id="ph1">`num`</ph></source>
        </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT">
          <source>This encoding pushes a <ph id="ph1">`float64`</ph> value onto the stack.</source>
        </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, double)</source>
        </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve">
          <source>Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</source>
        </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT">
          <source>A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem <ph id="ph1">`typeTok`</ph></source>
        </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`typeTok`</ph>.</source>
        </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the return value is specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
        </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the upper bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`native int`</ph> at a specified array index onto the top of the evaluation stack as a <ph id="ph2">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT">
          <source>97</source>
        </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.i</source>
        </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`native int`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a <ph id="ph3">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.i`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.i`</ph> is <ph id="ph2">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`int8`</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT">
          <source>90</source>
        </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.i1</source>
        </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.i1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.i1`</ph> is <ph id="ph2">`int8`</ph>.</source>
        </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`int16`</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT">
          <source>92</source>
        </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.i2</source>
        </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`int16`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.i2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.i2`</ph> is <ph id="ph2">`int16`</ph>.</source>
        </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`int32`</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT">
          <source>94</source>
        </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.i4</source>
        </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`int32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.i4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.i4`</ph> is <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`int64`</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT">
          <source>96</source>
        </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.i8</source>
        </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`int64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.i8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.i8`</ph> is <ph id="ph2">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`float32`</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">`F`</ph> (float).</source>
        </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT">
          <source>98</source>
        </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.r4</source>
        </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`float32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a type <ph id="ph3">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.r4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.r4`</ph> is <ph id="ph2">`float32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`float64`</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">`F`</ph> (float).</source>
        </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT">
          <source>99</source>
        </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.r8</source>
        </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`float64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as type <ph id="ph3">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.r8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.r8`</ph> is <ph id="ph2">`float64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve">
          <source>Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <ph id="ph1">`O`</ph> (object reference).</source>
        </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT">
          <source>9A</source>
        </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.ref</source>
        </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with an object reference at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.ref`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.ref`</ph> is type <ph id="ph2">`O`</ph> (object reference).</source>
        </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.ref`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`unsigned int8`</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT">
          <source>91</source>
        </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.u1</source>
        </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`unsigned int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.u1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.u1`</ph> is <ph id="ph2">`int8`</ph>.</source>
        </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`unsigned int16`</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT">
          <source>93</source>
        </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.u2</source>
        </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`unsigned int16`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.u2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.u2`</ph> is <ph id="ph2">`int16`</ph>.</source>
        </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve">
          <source>Loads the element with type <ph id="ph1">`unsigned int32`</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT">
          <source>95</source>
        </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelem.u4</source>
        </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the element with type <ph id="ph1">`unsigned int32`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelem.u4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelem.u4`</ph> is <ph id="ph2">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if array does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve">
          <source>Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <ph id="ph1">`&amp;`</ph> (managed pointer).</source>
        </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT">
          <source>8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldelema <ph id="ph1">`class`</ph></source>
        </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the address of the array element at <ph id="ph1">`index`</ph> onto the top of the evaluation stack as type <ph id="ph2">`&amp;`</ph> (managed pointer).</source>
        </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the address stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
        </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelema`</ph> is used to retrieve the address of an object at a particular index in an array of objects (of type <ph id="ph2">`class`</ph>).</source>
        </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldelema`</ph> instruction loads the address of the value at index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
        </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value must be of type <ph id="ph1">`class`</ph> passed with the instruction.</source>
        </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value for <ph id="ph1">`ldelema`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelema`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve">
          <source>Finds the value of a field in the object whose reference is currently on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT">
          <source>7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldfld <ph id="ph1">`field`</ph></source>
        </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the value of a field in a specified object onto the stack.</source>
        </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</source>
        </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value stored in the field is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldfld`</ph> instruction pushes the value of a field located in an object onto the stack.</source>
        </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
        </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
        </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
        </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return type is the same as the one associated with the field.</source>
        </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT">
          <source>The field may be either an instance field (in which case the object must not be a null reference) or a static field.</source>
        </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldfld`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
        </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
        </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
        </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
        </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldfld`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
        </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve">
          <source>Finds the address of a field in the object whose reference is currently on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT">
          <source>7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldflda <ph id="ph1">`field`</ph></source>
        </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the address of <ph id="ph1">`field`</ph> in a specified object onto the stack.</source>
        </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</source>
        </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address of the specified field is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldflda`</ph> instruction pushes the address of a field located in an object onto the stack.</source>
        </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
        </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
        </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
        </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value returned by <ph id="ph1">`ldflda`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type <ph id="ph3">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldflda`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
        </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown if the object is not within the application domain from which it is being accessed.</source>
        </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address of a field that is not inside the accessing application domain cannot be loaded.</source>
        </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
        </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
        </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
        </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldflda`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
        </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">`native int`</ph>) to the native code implementing a specific method onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldftn <ph id="ph1">`method`</ph></source>
        </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes a pointer to a method referenced by <ph id="ph1">`method`</ph> on the stack.</source>
        </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged pointer to a specific method is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT">
          <source>The specific method (<ph id="ph1">`method`</ph>) can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
        </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value returned points to native code using the CLR calling convention.</source>
        </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
        </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldftn`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
        </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`native int`</ph> as a <ph id="ph2">`native int`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT">
          <source>4D</source>
        </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.i</source>
        </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`native int`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a <ph id="ph3">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.i`</ph> instruction indirectly loads a <ph id="ph2">`native int`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`int8`</ph> as an <ph id="ph2">`int32`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT">
          <source>46</source>
        </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.i1</source>
        </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack..</source>
        </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.i1`</ph> instruction indirectly loads an <ph id="ph2">`int8`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`int16`</ph> as an <ph id="ph2">`int32`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT">
          <source>48</source>
        </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.i2</source>
        </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.i2`</ph> instruction indirectly loads an <ph id="ph2">`int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`int32`</ph> as an <ph id="ph2">`int32`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT">
          <source>4A</source>
        </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.i4</source>
        </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.i4`</ph> instruction indirectly loads an <ph id="ph2">`int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`int64`</ph> as an <ph id="ph2">`int64`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT">
          <source>4C</source>
        </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.i8</source>
        </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`int64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.i8`</ph> instruction indirectly loads an <ph id="ph2">`int64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`float32`</ph> as a type <ph id="ph2">`F`</ph> (float) onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT">
          <source>4E</source>
        </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.r4</source>
        </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`float32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.r4`</ph> instruction indirectly loads a <ph id="ph2">`float32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a type <ph id="ph5">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`float64`</ph> as a type <ph id="ph2">`F`</ph> (float) onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT">
          <source>4F</source>
        </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.r8</source>
        </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`float64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
        </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.r8`</ph> instruction indirectly loads a <ph id="ph2">`float64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`float64`</ph>.</source>
        </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve">
          <source>Loads an object reference as a type <ph id="ph1">`O`</ph> (object reference) onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT">
          <source>50</source>
        </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.ref</source>
        </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the object reference at address <ph id="ph1">`addr`</ph> onto the stack as a type <ph id="ph2">`O`</ph></source>
        </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the object reference located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.ref`</ph> instruction indirectly loads the object reference the specified address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or *) onto the stack as type <ph id="ph4">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.ref`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`unsigned int8`</ph> as an <ph id="ph2">`int32`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT">
          <source>47</source>
        </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.u1</source>
        </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`unsigned int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.u1`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int8`</ph> value from the specified address (of type<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`unsigned int16`</ph> as an <ph id="ph2">`int32`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT">
          <source>49</source>
        </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.u2</source>
        </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`unsigned int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.u2`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve">
          <source>Loads a value of type <ph id="ph1">`unsigned int32`</ph> as an <ph id="ph2">`int32`</ph> onto the evaluation stack indirectly.</source>
        </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT">
          <source>4B</source>
        </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldind.u4</source>
        </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the <ph id="ph1">`unsigned int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
        </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT">
          <source>The fetched value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldind.u4`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
        </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
        </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
        </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
        </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
        </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
        </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve">
          <source>Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT">
          <source>8E</source>
        </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldlen</source>
        </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the length (of type <ph id="ph1">`natural unsigned int`</ph>) of an array on the stack.</source>
        </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT">
          <source>The array reference is popped from the stack and the length is computed.</source>
        </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT">
          <source>The length is returned as a <ph id="ph1">`natural unsigned int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the array reference is a null reference.</source>
        </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldlen`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve">
          <source>Loads the local variable at a specific index onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 0C &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloc <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack.</source>
        </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldloc`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
        </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT">
          <source>Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</source>
        </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are 65,535 (2^16-1) local variables possible (0-65,534).</source>
        </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT">
          <source>Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</source>
        </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
        </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, and <ph id="ph4">`ldloc.3`</ph> instructions provide an efficient encoding for accessing the first four local variables.</source>
        </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
        </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
        </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, short)</source>
        </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT">
          <source>06</source>
        </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloc.0</source>
        </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT">
          <source>The local variable value at the index 0 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldloc.0`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 0.</source>
        </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
        </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.0`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT">
          <source>07</source>
        </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloc.1</source>
        </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT">
          <source>The local variable value at the index 1 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldloc.1`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 1.</source>
        </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
        </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT">
          <source>08</source>
        </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloc.2</source>
        </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT">
          <source>The local variable value at the index 2 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldloc.2`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 2.</source>
        </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
        </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT">
          <source>09</source>
        </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloc.3</source>
        </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT">
          <source>The local variable value at the index 3 is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldloc.3`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 3.</source>
        </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
        </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.3`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve">
          <source>Loads the local variable at a specific index onto the evaluation stack, short form.</source>
        </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT">
          <source>11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloc.s <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack, short form.</source>
        </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldloc.s`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
        </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT">
          <source>Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</source>
        </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than <ph id="ph1">`ldloc`</ph>.</source>
        </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
        </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
        </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
        </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
        </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, byte)</source>
        </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE OD &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloca <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldloca`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
        </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
        </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, short)</source>
        </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack, short form.</source>
        </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT">
          <source>12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldloca.s <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack, short form.</source>
        </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
        </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
        </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction provides an efficient encoding for use with the local variables 0 through 255.</source>
        </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, byte)</source>
        </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve">
          <source>Pushes a null reference (type <ph id="ph1">`O`</ph>) onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT">
          <source>14</source>
        </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldnull</source>
        </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT">
          <source>push a null reference onto the stack</source>
        </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT">
          <source>A null object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldnull`</ph> pushes a null reference (type <ph id="ph2">`O`</ph>) on the stack.</source>
        </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is used to initialize locations before they are populated with data, or when they become deprecated.</source>
        </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ldnull`</ph> provides a null reference that is size-independent.</source>
        </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldnull`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve">
          <source>Copies the value type object pointed to by an address to the top of the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT">
          <source>71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldobj <ph id="ph1">`class`</ph></source>
        </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Copy instance of value type <ph id="ph1">`class`</ph> to the stack.</source>
        </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address of a value type object is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is popped from the stack and the instance at that particular address is looked up.</source>
        </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the object stored at that address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldobj`</ph> instruction is used to pass a value type as a parameter.</source>
        </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldobj`</ph> instruction copies the value pointed to by <ph id="ph2">`addrOfValObj`</ph> (of type <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`native int`</ph>) to the top of the stack.</source>
        </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes copied depends on the size of the class (as specified by the <ph id="ph1">`class`</ph> parameter).</source>
        </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`class`</ph> parameter is a metadata token representing the value type.</source>
        </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`ldobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
        </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldobj`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve">
          <source>Pushes the value of a static field onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT">
          <source>7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldsfld <ph id="ph1">`field`</ph></source>
        </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Push the value of <ph id="ph1">`field`</ph> on the stack.</source>
        </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the specific field is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction pushes the value of a static (shared among all instances of a class) field on the stack.</source>
        </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return type is that associated with the passed metadata token <ph id="ph1">`field`</ph>.</source>
        </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
        </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsfld`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
        </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve">
          <source>Pushes the address of a static field onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT">
          <source>7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldsflda <ph id="ph1">`field`</ph></source>
        </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT">
          <source>Push the address of <ph id="ph1">`field`</ph> on the stack</source>
        </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address of a specific field is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction pushes the address of a static (shared among all instances of a class) field on the stack.</source>
        </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address may be represented as a transient pointer (type <ph id="ph1">`*`</ph>) if the metadata token <ph id="ph2">`field`</ph> refers to a type whose memory is managed.</source>
        </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it corresponds to an unmanaged pointer (type <ph id="ph1">`native int`</ph>).</source>
        </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">`field`</ph> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</source>
        </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
        </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
        </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</source>
        </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsflda`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
        </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve">
          <source>Pushes a new object reference to a string literal stored in the metadata.</source>
        </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT">
          <source>72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldstr <ph id="ph1">`mdToken`</ph></source>
        </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes a string object for the metadata string token <ph id="ph1">`mdToken`</ph>.</source>
        </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to a string is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldstr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new string object representing the specific string literal stored in the metadata.</source>
        </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldstr`</ph> instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</source>
        </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Common Language Infrastructure (CLI) guarantees that the result of two <ph id="ph1">`ldstr`</ph> instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</source>
        </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldstr`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, string)</source>
        </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve">
          <source>Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT">
          <source>D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldtoken <ph id="ph1">`token`</ph></source>
        </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Converts a metadata token to its runtime representation.</source>
        </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The passed token is converted to a <ph id="ph1">`RuntimeHandle`</ph> and pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ldtoken`</ph> instruction pushes a <ph id="ph2">`RuntimeHandle`</ph> for the specified metadata token.</source>
        </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">`RuntimeHandle`</ph> can be a <ph id="ph2">`fieldref/fielddef`</ph>, a <ph id="ph3">`methodref/methoddef`</ph>, or a <ph id="ph4">`typeref/typedef`</ph>.</source>
        </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value pushed on the stack can be used in calls to <ph id="ph1">`Reflection`</ph> methods in the system class library.</source>
        </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on runtime handles, see the following classes: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, and <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldtoken`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
        </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
        </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">`native int`</ph>) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT">
          <source>ldvirtftn <ph id="ph1">`method`</ph></source>
        </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the pointer to an object's virtual method <ph id="ph1">`method`</ph> on the stack.</source>
        </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <ph id="ph1">`method`</ph>) is looked up.</source>
        </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT">
          <source>The pointer to <ph id="ph1">`method`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting unmanaged pointer pushed onto the stack by the <ph id="ph1">`ldvirtftn`</ph> instruction can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
        </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT">
          <source>The unmanaged pointer points to native code using the CLR calling convention.</source>
        </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
        </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldvirtftn`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
        </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve">
          <source>Exits a protected region of code, unconditionally transferring control to a specific target instruction.</source>
        </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT">
          <source>DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT">
          <source>leave <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT">
          <source>Exits a protected region of code.</source>
        </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no stack transition behavior specified for this instruction.</source>
        </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`leave`</ph> instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`leave`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
        </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`leave`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
        </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use a <ph id="ph1">`leave`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
        </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`leave`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve">
          <source>Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</source>
        </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT">
          <source>DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT">
          <source>leave.s <ph id="ph1">`target`</ph></source>
        </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Exit a protected region of code, short form.</source>
        </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no stack transition behavior specified for this instruction.</source>
        </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`leave.s`</ph> instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
        </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`leave.s`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
        </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`leave.s`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
        </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use a <ph id="ph1">`leave.s`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
        </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave.s`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`leave.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve">
          <source>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <ph id="ph1">`*`</ph>) of the first allocated byte onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 0F</source>
        </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT">
          <source>localloc</source>
        </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT">
          <source>Allocate space from the local heap.</source>
        </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes to be allocated is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</source>
        </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pointer to the first byte of the allocated memory is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`localloc`</ph> instruction allocates <ph id="ph2">`size`</ph> (type <ph id="ph3">`natural unsigned int`</ph>) bytes from the local dynamic memory pool and returns the address (a transient pointer, type <ph id="ph4">`*`</ph>) of the first allocated byte.</source>
        </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT">
          <source>The block of memory returned is initialized to 0 only if the initialize flag on the method is <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the current method executes a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, the local memory pool is made available for reuse.</source>
        </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting address is aligned so that any primitive data type can be stored there using the <ph id="ph1">`stind`</ph> instructions (such as <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) and loaded using the <ph id="ph3">`ldind`</ph> instructions (such as <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`localloc`</ph> instruction cannot occur within a <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, or <ph id="ph5">`fault`</ph> block.</source>
        </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> is thrown if there is insufficient memory to service the request.</source>
        </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`localloc`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve">
          <source>Pushes a typed reference to an instance of a specific type onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT">
          <source>C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT">
          <source>mkrefany <ph id="ph1">`class`</ph></source>
        </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes a typed reference of type <ph id="ph1">`class`</ph> onto the stack.</source>
        </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pointer to piece of data is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT">
          <source>The pointer is popped and converted to a typed reference of type <ph id="ph1">`class`</ph>.</source>
        </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT">
          <source>The typed reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`mkrefany`</ph> instruction supports the passing of dynamically typed references.</source>
        </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT">
          <source>The pointer must be of type <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, or <ph id="ph3">`native int`</ph>, and hold the valid address of a piece of data.</source>
        </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Class`</ph> is the class token describing the type of the data referenced by the pointer.</source>
        </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Mkrefany`</ph> pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <ph id="ph2">`class`</ph>.</source>
        </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</source>
        </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callee can then use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> instructions to retrieve the type (class) and the address respectively.</source>
        </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`class`</ph> cannot be found.</source>
        </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mkrefany`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve">
          <source>Multiplies two values and pushes the result on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT">
          <source>5A</source>
        </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT">
          <source>mul</source>
        </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiplies two values on the stack.</source>
        </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>.</source>
        </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`mul`</ph> instruction multiplies <ph id="ph2">`value1`</ph> by <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
        </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer operations silently truncate the upper bits on overflow.</source>
        </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> for an integer-specific multiply operation with overflow handling.</source>
        </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT">
          <source>For floating-point types, 0 * infinity = NaN.</source>
        </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve">
          <source>Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT">
          <source>D8</source>
        </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT">
          <source>mul.ovf</source>
        </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiplies two integer values on the stack with an overflow check.</source>
        </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
        </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`mul.ovf`</ph> instruction multiplies integer <ph id="ph2">`value1`</ph> by integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
        </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception is thrown if the result will not fit in the result type.</source>
        </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve">
          <source>Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT">
          <source>D9</source>
        </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT">
          <source>mul.ovf.un</source>
        </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiplies two unsigned values on the stack with an overflow check.</source>
        </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
        </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`mul.ovf.un`</ph> instruction multiplies unsigned integer <ph id="ph2">`value1`</ph> by unsigned integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
        </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT">
          <source>An exception is thrown if the result will not fit in the result type.</source>
        </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve">
          <source>Negates a value and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" extradata="MT">
          <source>65</source>
        </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT">
          <source>neg</source>
        </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT">
          <source>Negates the value currently on top of the stack.</source>
        </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped from the stack and negated.</source>
        </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`neg`</ph> instruction negates value and pushes the result on top of the stack.</source>
        </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return type is the same as the operand type.</source>
        </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT">
          <source>Negation of integral values is standard two's complement negation.</source>
        </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</source>
        </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT">
          <source>To detect this overflow use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> instruction instead (that is, subtract from 0).</source>
        </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" extradata="MT">
          <source>Negating a floating-point number cannot overflow, and negating NaN returns NaN.</source>
        </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`neg`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve">
          <source>Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT">
          <source>8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT">
          <source>newarr <ph id="ph1">`etype`</ph></source>
        </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT">
          <source>Creates a new array with elements of type <ph id="ph1">`etype`</ph>.</source>
        </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in the array is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements is popped from the stack and the array is created.</source>
        </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to the new array is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`newarr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new zero-based, one-dimensional array whose elements are of type <ph id="ph3">`etype`</ph> (a metadata token describing the type).</source>
        </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of elements in the new array should be specified as a <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid array indexes range from zero to the maximum number of elements minus one.</source>
        </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of an array can be any type, including value types.</source>
        </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT">
          <source>Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and so on).</source>
        </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements of the array are initialized to 0 of the appropriate type.</source>
        </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nonzero-based one-dimensional arrays and multidimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> rather than <ph id="ph2">`newarr`</ph>.</source>
        </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT">
          <source>More commonly, they are created using the methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if <ph id="ph2">`numElems`</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newarr`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve">
          <source>Creates a new object or a new instance of a value type, pushing an object reference (type <ph id="ph1">`O`</ph>) onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT">
          <source>73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT">
          <source>newobj <ph id="ph1">`ctor`</ph></source>
        </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Allocates an uninitialized object or value type and calls the constructor method <ph id="ph1">`ctor`</ph>.</source>
        </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argn`</ph> are pushed on the stack in sequence.</source>
        </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arguments <ph id="ph1">`argn`</ph> through <ph id="ph2">`arg1`</ph> are popped from the stack and passed to <ph id="ph3">`ctor`</ph> for object creation.</source>
        </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT">
          <source>A reference to the new object is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`newobj`</ph> instruction creates a new object or a new instance of a value type.</source>
        </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Ctor`</ph> is a metadata token (a <ph id="ph2">`methodref`</ph> or <ph id="ph3">`methoddef`</ph> that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</source>
        </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`newobj`</ph> instruction allocates a new instance of the class associated with <ph id="ph2">`ctor`</ph> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</source>
        </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT">
          <source>It then calls the constructor <ph id="ph1">`ctor`</ph> with the given arguments along with the newly created instance.</source>
        </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the constructor has been called, the now initialized object reference (type <ph id="ph1">`O`</ph>) is pushed on the stack.</source>
        </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</source>
        </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT">
          <source>All zero-based, one-dimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, not <ph id="ph2">`newobj`</ph>.</source>
        </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using <ph id="ph1">`newobj`</ph>.</source>
        </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value types are not usually created using <ph id="ph1">`newobj`</ph>.</source>
        </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT">
          <source>They are usually allocated either as arguments or local variables, using <ph id="ph1">`newarr`</ph> (for zero-based, one-dimensional arrays), or as fields of objects.</source>
        </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once allocated, they are initialized using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">`newobj`</ph> instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</source>
        </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
        </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a constructor method <ph id="ph2">`ctor`</ph> with the indicated name, class and signature could not be found.</source>
        </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newobj`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, ConstructorInfo)</source>
        </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve">
          <source>Fills space if opcodes are patched.</source>
        </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve">
          <source>No meaningful operation is performed although a processing cycle can be consumed.</source>
        </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT">
          <source>00</source>
        </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT">
          <source>nop</source>
        </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performs an operation without behavior.</source>
        </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no stack transitional behavior defined for this instruction.</source>
        </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`nop`</ph> operation does nothing.</source>
        </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is intended to fill in space if opcodes are patched.</source>
        </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`nop`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve">
          <source>Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</source>
        </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT">
          <source>66</source>
        </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT">
          <source>not</source>
        </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT">
          <source>Computes the bitwise complement of a value.</source>
        </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> is popped from the stack and its bitwise complement computed.</source>
        </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`not`</ph> instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</source>
        </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return type is the same as the operand type.</source>
        </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`not`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve">
          <source>Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT">
          <source>60</source>
        </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT">
          <source>or</source>
        </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT">
          <source>Computes the bitwise OR of two integer values, returns an integer.</source>
        </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise OR computed.</source>
        </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`or`</ph> instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</source>
        </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Or`</ph> is an integer-specific operation.</source>
        </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`or`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve">
          <source>Removes the value currently on top of the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT">
          <source>26</source>
        </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" extradata="MT">
          <source>pop</source>
        </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops the top value from the stack.</source>
        </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT">
          <source>The top value is popped from the stack.</source>
        </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`pop`</ph> instruction removes the top element from the stack.</source>
        </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`pop`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve">
          <source>This is a reserved instruction.</source>
        </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve">
          <source>Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</source>
        </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 1E</source>
        </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT">
          <source>readonly.</source>
        </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</source>
        </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" extradata="MT">
          <source>This prefix can only appear immediately preceding the <ph id="ph1">`ldelema`</ph> instruction and calls to the special <ph id="ph2">`Address`</ph> method on arrays.</source>
        </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its effect on the subsequent operation is twofold:</source>
        </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT">
          <source>At run time, no type check operation is performed.</source>
        </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that there is normally an implicit type check for the <ph id="ph1">`ldelema`</ph> and <ph id="ph2">`stelem`</ph> instructions when used on reference type arrays.</source>
        </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is never a run-time type check for value classes, so <ph id="ph1">`readonly`</ph> is a no-op in that case.</source>
        </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT">
          <source>The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</source>
        </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT">
          <source>The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</source>
        </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT">
          <source>For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</source>
        </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</source>
        </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT">
          <source>A managed pointer restricted in this fashion can be used only in the following ways:</source>
        </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the <ph id="ph1">`object`</ph> parameter for the <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, or<ph id="ph6">`constrained callvirt`</ph> instructions.</source>
        </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the <ph id="ph1">`pointer`</ph> parameter to the <ph id="ph2">`ldobj`</ph> instruction or to one of the <ph id="ph3">`ldind`</ph> instructions.</source>
        </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the <ph id="ph1">`source`</ph> parameter to the <ph id="ph2">`cpobj`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT">
          <source>All other operations disallowed, including the <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, or <ph id="ph3">`mkrefany`</ph> operations, or any of the <ph id="ph4">`stind`</ph> instructions.</source>
        </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT">
          <source>The purpose of the <ph id="ph1">`readonly`</ph> prefix is to avoid a type check when fetching an element from an array in generic code.</source>
        </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the expression <ph id="ph1">`arr[i].m()`</ph>, where the element type of the array <ph id="ph2">`arr`</ph> is a generic type that has been constrained to have an interface with method <ph id="ph3">`m`</ph>, might compile to the following MSIL.</source>
        </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT">
          <source>Without the <ph id="ph1">`readonly`</ph> prefix, the <ph id="ph2">`ldelema`</ph> instruction would perform a type check in the case where !0 was a reference type.</source>
        </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not only is this type check inefficient, but it is semantically incorrect.</source>
        </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type check for <ph id="ph1">`ldelema`</ph> is an exact match, which is too strong.</source>
        </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the array held subclasses of type !0, the code above would fail the type check.</source>
        </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address of the array element is fetched, instead of the element itself, in order to have a handle for <ph id="ph1">`arr[i]`</ph> that works for both value types and reference types, and thus can be passed to the <ph id="ph2">`constrained callvirt`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT">
          <source>In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</source>
        </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</source>
        </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" extradata="MT">
          <source>The verifier rules ensure this.</source>
        </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT">
          <source>The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</source>
        </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`readonly`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve">
          <source>Retrieves the type token embedded in a typed reference.</source>
        </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 1D</source>
        </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT">
          <source>refanytype</source>
        </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the type token stored in a typed reference.</source>
        </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The typed reference is popped from the stack and its corresponding type token retrieved.</source>
        </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type token is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT">
          <source>A typed reference contains a type token and an address to an object instance.</source>
        </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`refanytype`</ph> instruction retrieves the type token embedded in the typed reference.</source>
        </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for information on creating typed references.</source>
        </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanytype`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve">
          <source>Retrieves the address (type <ph id="ph1">`&amp;`</ph>) embedded in a typed reference.</source>
        </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT">
          <source>C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT">
          <source>refanyval <ph id="ph1">`type`</ph></source>
        </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the address stored in a typed reference.</source>
        </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT">
          <source>The typed reference is popped from the stack and the corresponding address retrieved.</source>
        </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT">
          <source>The address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT">
          <source>A typed reference contains a type token and an address to an object instance.</source>
        </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`refanyval`</ph> instruction retrieves the address embedded in the a typed reference.</source>
        </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type embedded in the typed reference supplied on the stack must match the type specified by <ph id="ph1">`type`</ph> (a metadata token, either a <ph id="ph2">`typedef`</ph> or a <ph id="ph3">`typeref`</ph>).</source>
        </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for related content.</source>
        </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> is not identical to the type stored in the type reference (in this case, <ph id="ph3">`type`</ph> is the class supplied to the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction that constructed said typed reference).</source>
        </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> cannot be found.</source>
        </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanyval`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve">
          <source>Divides two values and pushes the remainder onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT">
          <source>5D</source>
        </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT">
          <source>rem</source>
        </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the remainder of dividing <ph id="ph1">`value1`</ph> by <ph id="ph2">`value2`</ph> onto the stack.</source>
        </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT">
          <source>ReplaceThisText</source>
        </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
        </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
        </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), and:</source>
        </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT">
          <source>0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, sign(<ph id="ph3">`result`</ph>) = sign(<ph id="ph4">`value1`</ph>), where <ph id="ph5">`div`</ph> is the division instruction that truncates towards zero.</source>
        </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value2`</ph> is zero or <ph id="ph2">`value1`</ph> is infinity the result is NaN.</source>
        </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value2`</ph> is infinity, the result is <ph id="ph2">`value1`</ph> (negated for <ph id="ph3">`-infinity`</ph>).</source>
        </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that on the Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint <ph id="ph2">`rem`</ph> -1).</source>
        </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve">
          <source>Divides two unsigned values and pushes the remainder onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT">
          <source>5E</source>
        </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT">
          <source>rem.un</source>
        </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pushes the remainder of dividing unsigned <ph id="ph1">`value1`</ph> by unsigned <ph id="ph2">`value2`</ph> onto the stack.</source>
        </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
        </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
        </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x(<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), and:</source>
        </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT">
          <source>0 = <ph id="ph1">`result`</ph><ph id="ph2"> &lt; </ph><ph id="ph3">`value2`</ph>, where <ph id="ph4">`div.un`</ph> is the unsigned division instruction.</source>
        </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`rem.un`</ph> instruction computes <ph id="ph2">`result`</ph> and pushes it on the stack.</source>
        </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Rem.un`</ph> treats its arguments as unsigned integers, while <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> treats them as signed integers.</source>
        </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Rem.un`</ph> is unspecified for floating-point numbers.</source>
        </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve">
          <source>Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT">
          <source>2A</source>
        </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT">
          <source>ret</source>
        </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT">
          <source>Returns from method, possibly returning a value.</source>
        </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is popped from the callee evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value obtained in step 1 is pushed onto the caller evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</source>
        </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</source>
        </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" extradata="MT">
          <source>The evaluation stack for the current method must be empty except for the value to be returned.</source>
        </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ret`</ph> instruction cannot be used to transfer control out of a<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
        </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" extradata="MT">
          <source>From within a <ph id="ph1">`try`</ph> or <ph id="ph2">`catch`</ph>, use the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction with a destination of a <ph id="ph4">`ret`</ph> instruction that is outside all enclosing exception blocks.</source>
        </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">`filter`</ph> and <ph id="ph2">`finally`</ph> blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a <ph id="ph3">`filter`</ph> or <ph id="ph4">`finally`</ph>.</source>
        </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ret`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve">
          <source>Rethrows the current exception.</source>
        </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 1A</source>
        </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT">
          <source>rethrow</source>
        </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT">
          <source>Rethrows the current exception</source>
        </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" extradata="MT">
          <source>No stack transition behavior is defined for this instruction.</source>
        </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`rethrow`</ph> instruction is only permitted within the body of a <ph id="ph2">`catch`</ph> handler.</source>
        </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT">
          <source>It throws the same exception that was caught by this handler.</source>
        </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rethrow`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve">
          <source>Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT">
          <source>62</source>
        </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT">
          <source>shl</source>
        </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT">
          <source>Shifts an integer to the left (shifting in zeros).</source>
        </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`shl`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) left by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
        </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Shl`</ph> inserts a zero bit in the lowest position on each shift.</source>
        </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shl`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve">
          <source>Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT">
          <source>63</source>
        </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT">
          <source>shr</source>
        </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT">
          <source>Shifts an integer to the right (shifting in sign).</source>
        </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
        </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Shr`</ph> replicates the high order bit on each shift, preserving the sign of the original value in the <ph id="ph2">`result`</ph>.</source>
        </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve">
          <source>Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT">
          <source>64</source>
        </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT">
          <source>shr.un</source>
        </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT">
          <source>Shifts an integer to the right (shifting in zeroes).</source>
        </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> or <ph id="ph3">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
        </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Shr.un`</ph> inserts a zero bit in the highest position on each shift.</source>
        </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve">
          <source>Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 1C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT">
          <source>sizeof <ph id="ph1">`valType`</ph></source>
        </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT">
          <source>Push the size, in bytes, of a value type as an <ph id="ph1">`unsigned int32`</ph>.</source>
        </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT">
          <source>The size (in bytes) of the supplied value type (<ph id="ph1">`valType`</ph>) is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`valType`</ph> must be a metadata token (a <ph id="ph2">`typeref`</ph> or <ph id="ph3">`typedef`</ph>) that specifies a value type, reference type, or generic type parameter.</source>
        </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</source>
        </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type parameter can be used only in the body of the type or method that defines it.</source>
        </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT">
          <source>When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</source>
        </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sizeof`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index.</source>
        </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 0B &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT">
          <source>starg <ph id="ph1">`num`</ph></source>
        </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>.</source>
        </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
        </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`starg`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
        </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
        </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
        </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
        </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, short)</source>
        </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</source>
        </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT">
          <source>10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT">
          <source>starg.s <ph id="ph1">`num`</ph></source>
        </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>, short form.</source>
        </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
        </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`starg.s`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
        </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
        </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`starg.s`</ph> instruction provides an efficient encoding for use with the first 256 arguments.</source>
        </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
        </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
        </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>method overload can use the <ph id="ph2">`starg.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, byte)</source>
        </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</source>
        </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT">
          <source>A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem <ph id="ph1">`typeTok`</ph></source>
        </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces the array element at the supplied index with a value of type <ph id="ph1">`typeTok`</ph> on the stack.</source>
        </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT">
          <source>An index value, <ph id="ph1">`index`</ph>, to an element in <ph id="ph2">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value of the type specified in the instruction is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem`</ph> instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <ph id="ph2">`array`</ph> with the value.</source>
        </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value has the type specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
        </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the <ph id="ph1">`native int`</ph> value on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT">
          <source>9B</source>
        </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.i</source>
        </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`native int`</ph> value on the stack.</source>
        </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.i`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`native int`</ph> value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the <ph id="ph1">`int8`</ph> value on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT">
          <source>9C</source>
        </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.i1</source>
        </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int8`</ph> value on the stack.</source>
        </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.i1`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int8`</ph> value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the <ph id="ph1">`int16`</ph> value on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT">
          <source>9D</source>
        </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.i2</source>
        </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int16`</ph> value on the stack.</source>
        </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.i2`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int16`</ph> value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the <ph id="ph1">`int32`</ph> value on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT">
          <source>9E</source>
        </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.i4</source>
        </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int32`</ph> value on the stack.</source>
        </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.i4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int32`</ph> value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the <ph id="ph1">`int64`</ph> value on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT">
          <source>9F</source>
        </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.i8</source>
        </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int64`</ph> value on the stack.</source>
        </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.i8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int64`</ph> value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the <ph id="ph1">`float32`</ph> value on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT">
          <source>A0</source>
        </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.r4</source>
        </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float32`</ph> value on the stack.</source>
        </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.r4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float32`</ph> value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the <ph id="ph1">`float64`</ph> value on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT">
          <source>A1</source>
        </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.r8</source>
        </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float64`</ph> value on the stack.</source>
        </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.r8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float64`</ph> value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve">
          <source>Replaces the array element at a given index with the object ref value (type <ph id="ph1">`O`</ph>) on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT">
          <source>A2</source>
        </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT">
          <source>stelem.ref</source>
        </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`ref`</ph> value (type <ph id="ph2">`O`</ph>) on the stack.</source>
        </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
        </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stelem.ref`</ph> instruction replaces the value of the element at the supplied index in the one-dimensional array <ph id="ph2">`array`</ph> with the <ph id="ph3">`ref`</ph> (type <ph id="ph4">`O`</ph>) value pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
        </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
        </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">`stelem.ref`</ph> implicitly casts the supplied value to the element type of <ph id="ph2">`array`</ph> before assigning the value to the array element.</source>
        </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT">
          <source>This cast can fail, even for verified code.</source>
        </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus the <ph id="ph1">`stelem.ref`</ph> instruction can throw <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT">
          <source>For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class provides a <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
        </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
        </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.ref`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve">
          <source>Replaces the value stored in the field of an object reference or pointer with a new value.</source>
        </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT">
          <source>7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT">
          <source>stfld <ph id="ph1">`field`</ph></source>
        </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces the value of <ph id="ph1">`field`</ph> of the object with a new value.</source>
        </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference or pointer is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the object reference/pointer are popped from the stack; the value of <ph id="ph1">`field`</ph> in the object is replaced with the supplied value.</source>
        </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stfld`</ph> instruction replaces the value of a field of an object (type <ph id="ph2">`O`</ph>) or via a pointer (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) with a given value.</source>
        </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Field`</ph> is a metadata token that refers to a field member reference.</source>
        </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stfld`</ph> instruction can have a prefix of either or both of <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference or pointer is a null reference and the field isn't static.</source>
        </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if <ph id="ph2">`field`</ph> is not found in the metadata.</source>
        </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</source>
        </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stfld`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
        </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve">
          <source>Stores a value of type <ph id="ph1">`native int`</ph> at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT">
          <source>DF</source>
        </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.i</source>
        </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores a <ph id="ph1">`native int`</ph> value at a given address.</source>
        </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.i`</ph> instruction stores a <ph id="ph2">`native int`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve">
          <source>Stores a value of type <ph id="ph1">`int8`</ph> at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT">
          <source>52</source>
        </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.i1</source>
        </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores an <ph id="ph1">`int8`</ph> value at a given address.</source>
        </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.i1`</ph> instruction stores an <ph id="ph2">`int8`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i1`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.i1`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve">
          <source>Stores a value of type <ph id="ph1">`int16`</ph> at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" extradata="MT">
          <source>53</source>
        </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.i2</source>
        </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores an <ph id="ph1">`int16`</ph> value at a given address.</source>
        </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.i2`</ph> instruction stores an <ph id="ph2">`int16`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.2i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.i2`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve">
          <source>Stores a value of type <ph id="ph1">`int32`</ph> at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" extradata="MT">
          <source>54</source>
        </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.i4</source>
        </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores an <ph id="ph1">`int32`</ph> value at a given address.</source>
        </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.i4`</ph> instruction stores an <ph id="ph2">`int32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.i4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve">
          <source>Stores a value of type <ph id="ph1">`int64`</ph> at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" extradata="MT">
          <source>55</source>
        </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.i8</source>
        </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores an <ph id="ph1">`int64`</ph> value at a given address.</source>
        </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.i8`</ph> instruction stores an <ph id="ph2">`int64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve">
          <source>Stores a value of type <ph id="ph1">`float32`</ph> at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT">
          <source>56</source>
        </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.r4</source>
        </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores a <ph id="ph1">`float32`</ph> value at a given address.</source>
        </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.r4`</ph> instruction stores a <ph id="ph2">`float32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.r4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r4`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve">
          <source>Stores a value of type <ph id="ph1">`float64`</ph> at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT">
          <source>57</source>
        </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.r8</source>
        </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores a <ph id="ph1">`float64`</ph> value at a given address.</source>
        </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.r8`</ph> instruction stores a <ph id="ph2">`float64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.r8`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r8`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve">
          <source>Stores a object reference value at a supplied address.</source>
        </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" extradata="MT">
          <source>51</source>
        </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" extradata="MT">
          <source>stind.ref</source>
        </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores an object reference (type <ph id="ph1">`O`</ph>) value at a given address.</source>
        </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stind.ref`</ph> instruction stores an object reference value at the supplied address (type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type safe operation requires that the <ph id="ph1">`stind.ref`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
        </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stind.ref`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
        </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.ref`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</source>
        </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 0E &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT">
          <source>stloc <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>.</source>
        </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
        </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stloc`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
        </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
        </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
        </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions require that <ph id="ph1">`index`</ph> be a valid local index.</source>
        </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the <ph id="ph1">`stloc`</ph> instruction, <ph id="ph2">`index`</ph> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</source>
        </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</source>
        </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
        </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
        </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, short)</source>
        </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</source>
        </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT">
          <source>0A</source>
        </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT">
          <source>stloc.0</source>
        </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops a value from the stack into local variable 0.</source>
        </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped off of the stack and placed in the local variable indexed by 0.</source>
        </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stloc.0`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</source>
        </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
        </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`stloc.0`</ph> is an especially efficient encoding for storing values in local variable 0.</source>
        </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
        </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.0`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</source>
        </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" extradata="MT">
          <source>0B</source>
        </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" extradata="MT">
          <source>stloc.1</source>
        </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops a value from the stack into local variable 1.</source>
        </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped off of the stack and placed in the local variable indexed by 1.</source>
        </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stloc.1`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</source>
        </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
        </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`stloc.1`</ph> is an especially efficient encoding for storing values in local variable 1.</source>
        </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" extradata="MT">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
        </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.1`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</source>
        </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT">
          <source>0C</source>
        </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT">
          <source>stloc.2</source>
        </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops a value from the stack into local variable 2</source>
        </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped off of the stack and placed in the local variable indexed by 2.</source>
        </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stloc.2`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</source>
        </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
        </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`stloc.2`</ph> is an especially efficient encoding for storing values in local variable 2.</source>
        </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
        </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.2`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</source>
        </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" extradata="MT">
          <source>0D</source>
        </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" extradata="MT">
          <source>stloc.3</source>
        </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops a value from the stack into local variable 3</source>
        </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped off of the stack and placed in the local variable indexed by 3.</source>
        </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stloc.3`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</source>
        </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
        </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`stloc.3`</ph> is an especially efficient encoding for storing values in local variable 3.</source>
        </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
        </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.3`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index</ph><ept id="p1">&lt;/code&gt;</ept> (short form).</source>
        </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT">
          <source>13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT">
          <source>stloc.s <ph id="ph1">`index`</ph></source>
        </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>, short form.</source>
        </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
        </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
        </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
        </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction provides an efficient encoding for local variables 0 through 255.</source>
        </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" extradata="MT">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
        </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
        </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc.s`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
        </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, byte)</source>
        </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve">
          <source>Copies a value of a specified type from the evaluation stack into a supplied memory address.</source>
        </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" extradata="MT">
          <source>81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT">
          <source>stobj <ph id="ph1">`class`</ph></source>
        </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT">
          <source>Stores a value of type <ph id="ph1">`class`</ph> from the stack into memory.</source>
        </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type object of type <ph id="ph1">`class`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object and the address are popped from the stack; the value type object is stored at the address.</source>
        </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stobj`</ph> instruction copies the value type object into the address specified by the address (a pointer of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
        </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of bytes copied depends on the size of the class represented by <ph id="ph1">`class`</ph>, a metadata token representing a value type.</source>
        </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation of the <ph id="ph1">`stobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
        </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
        </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
        </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stobj`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve">
          <source>Replaces the value of a static field with a value from the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT">
          <source>80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT">
          <source>stsfld <ph id="ph1">`field`</ph></source>
        </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" extradata="MT">
          <source>Replaces the value in <ph id="ph1">`field`</ph> with a supplied value.</source>
        </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is popped from the stack and stored in <ph id="ph1">`field`</ph>.</source>
        </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stsfld`</ph> instruction replaces the value of a static field with a value from the stack.</source>
        </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`field`</ph> is a metadata token that must refer to a static field member.</source>
        </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`stsfld`</ph> instruction may be prefixed by <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
        </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
        </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stsfld`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
        </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve">
          <source>Subtracts one value from another and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" extradata="MT">
          <source>59</source>
        </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT">
          <source>sub</source>
        </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subtracts one value from another, returning a new numeric value.</source>
        </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4301" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph>.</source>
        </trans-unit>
        <trans-unit id="4302" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4303" translate="yes" xml:space="preserve" extradata="MT">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="4304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integer subtraction wraps, rather than saturates.</source>
        </trans-unit>
        <trans-unit id="4305" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example: assuming 8-bit integers, where <ph id="ph1">`value1`</ph> is set to 0 and <ph id="ph2">`value2`</ph> is set to 1, the "wrapped" result will be 255.</source>
        </trans-unit>
        <trans-unit id="4306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
        </trans-unit>
        <trans-unit id="4307" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4308" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4309" translate="yes" xml:space="preserve">
          <source>Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="4310" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4311" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4312" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4313" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4314" translate="yes" xml:space="preserve" extradata="MT">
          <source>DA</source>
        </trans-unit>
        <trans-unit id="4315" translate="yes" xml:space="preserve" extradata="MT">
          <source>sub.ovf</source>
        </trans-unit>
        <trans-unit id="4316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subtracts one integer value from another with an overflow check.</source>
        </trans-unit>
        <trans-unit id="4317" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4318" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4319" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4320" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
        </trans-unit>
        <trans-unit id="4321" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4322" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="4323" translate="yes" xml:space="preserve" extradata="MT">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="4324" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4325" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4326" translate="yes" xml:space="preserve">
          <source>Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="4327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4331" translate="yes" xml:space="preserve" extradata="MT">
          <source>DB</source>
        </trans-unit>
        <trans-unit id="4332" translate="yes" xml:space="preserve" extradata="MT">
          <source>sub.ovf.un</source>
        </trans-unit>
        <trans-unit id="4333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subtracts one unsigned integer value from another with an overflow check.</source>
        </trans-unit>
        <trans-unit id="4334" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4335" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4336" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4337" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
        </trans-unit>
        <trans-unit id="4338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4339" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
        </trans-unit>
        <trans-unit id="4340" translate="yes" xml:space="preserve" extradata="MT">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="4341" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf.un`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4342" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4343" translate="yes" xml:space="preserve">
          <source>Implements a jump table.</source>
        </trans-unit>
        <trans-unit id="4344" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4345" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4347" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4348" translate="yes" xml:space="preserve" extradata="MT">
          <source>45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4349" translate="yes" xml:space="preserve" extradata="MT">
          <source>switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</source>
        </trans-unit>
        <trans-unit id="4350" translate="yes" xml:space="preserve" extradata="MT">
          <source>Jumps to one of <ph id="ph1">`N`</ph> values.</source>
        </trans-unit>
        <trans-unit id="4351" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4352" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4353" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <ph id="ph1">`N`</ph>.</source>
        </trans-unit>
        <trans-unit id="4354" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`switch`</ph> instruction implements a jump table.</source>
        </trans-unit>
        <trans-unit id="4355" translate="yes" xml:space="preserve" extradata="MT">
          <source>The format of the instruction is an <ph id="ph1">`unsigned int32`</ph> representing the number of targets <ph id="ph2">`N`</ph>, followed by <ph id="ph3">`N`</ph> int32 values specifying jump targets.</source>
        </trans-unit>
        <trans-unit id="4356" translate="yes" xml:space="preserve" extradata="MT">
          <source>These targets are represented as offsets (positive or negative) from the beginning of the instruction following this <ph id="ph1">`switch`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="4357" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`switch`</ph> instruction pops a value off the stack and compares it, as an unsigned integer, to <ph id="ph2">`N`</ph>.</source>
        </trans-unit>
        <trans-unit id="4358" translate="yes" xml:space="preserve" extradata="MT">
          <source>If value is less than <ph id="ph1">`N`</ph>, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</source>
        </trans-unit>
        <trans-unit id="4359" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value is greater than or equal to <ph id="ph1">`N`</ph>, execution continues at the next instruction (fall through).</source>
        </trans-unit>
        <trans-unit id="4360" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
        </trans-unit>
        <trans-unit id="4361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
        </trans-unit>
        <trans-unit id="4362" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Such transfers are severely restricted and must use the leave instruction instead).</source>
        </trans-unit>
        <trans-unit id="4363" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`switch`</ph> opcode.</source>
        </trans-unit>
        <trans-unit id="4364" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Label[]`</ph> argument is an array of Labels representing 32-bit offsets.</source>
        </trans-unit>
        <trans-unit id="4365" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label[])</source>
        </trans-unit>
        <trans-unit id="4366" translate="yes" xml:space="preserve">
          <source>Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</source>
        </trans-unit>
        <trans-unit id="4367" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4368" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4369" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4370" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4371" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 14</source>
        </trans-unit>
        <trans-unit id="4372" translate="yes" xml:space="preserve" extradata="MT">
          <source>tail.</source>
        </trans-unit>
        <trans-unit id="4373" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent call terminates current methods</source>
        </trans-unit>
        <trans-unit id="4374" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no stack transition behavior defined for this instruction.</source>
        </trans-unit>
        <trans-unit id="4375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`tail`</ph> prefix instruction must immediately precede a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="4376" translate="yes" xml:space="preserve" extradata="MT">
          <source>It indicates that the current method's stack frame should be removed before the call instruction is executed.</source>
        </trans-unit>
        <trans-unit id="4377" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</source>
        </trans-unit>
        <trans-unit id="4378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack must be empty except for the arguments being transferred by the following call.</source>
        </trans-unit>
        <trans-unit id="4379" translate="yes" xml:space="preserve" extradata="MT">
          <source>The instruction following the call instruction must be a ret.</source>
        </trans-unit>
        <trans-unit id="4380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus the only valid code sequence is <ph id="ph1">`tail. call`</ph> (or <ph id="ph2">`calli`</ph> or <ph id="ph3">`callvirt`</ph>).</source>
        </trans-unit>
        <trans-unit id="4381" translate="yes" xml:space="preserve" extradata="MT">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the <ph id="ph1">`call`</ph> instruction, but they may branch to the subsequent <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="4382" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</source>
        </trans-unit>
        <trans-unit id="4383" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework security checks can therefore cause the <ph id="ph1">`tail`</ph> to be ignored, leaving a standard <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="4384" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the <ph id="ph1">`tail`</ph> prefix is ignored when used to exit a method that is marked synchronized.</source>
        </trans-unit>
        <trans-unit id="4385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`tail`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4386" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4387" translate="yes" xml:space="preserve">
          <source>Returns true or false if the supplied opcode takes a single byte argument.</source>
        </trans-unit>
        <trans-unit id="4388" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</source>
        </trans-unit>
        <trans-unit id="4389" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`TakesSingleByteArgument`</ph> returns <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> instance takes a single byte argument in the following cases:</source>
        </trans-unit>
        <trans-unit id="4390" translate="yes" xml:space="preserve" extradata="MT">
          <source>The opcode performs a branch instruction to a byte-sized address (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="4391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The opcode pushes a byte value onto the stack (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="4392" translate="yes" xml:space="preserve" extradata="MT">
          <source>The opcode references a variable or argument via the byte-sized "short form" (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="4393" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="4394" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example below demonstrates the use of <ph id="ph1">`TakesSingleByteArgument`</ph> by reflecting on to the <ph id="ph2">`OpCodes`</ph> class and testing to see whether each <ph id="ph3">`OpCode`</ph> field takes a single-byte argument.</source>
        </trans-unit>
        <trans-unit id="4395" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="4396" translate="yes" xml:space="preserve">
          <source>An instance of an Opcode object.</source>
        </trans-unit>
        <trans-unit id="4397" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="4398" translate="yes" xml:space="preserve">
          <source>Throws the exception object currently on the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="4399" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4400" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4401" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4402" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4403" translate="yes" xml:space="preserve" extradata="MT">
          <source>7A</source>
        </trans-unit>
        <trans-unit id="4404" translate="yes" xml:space="preserve" extradata="MT">
          <source>throw</source>
        </trans-unit>
        <trans-unit id="4405" translate="yes" xml:space="preserve" extradata="MT">
          <source>Throws an exception.</source>
        </trans-unit>
        <trans-unit id="4406" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4407" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference (to an exception) is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference is popped from the stack and the exception thrown.</source>
        </trans-unit>
        <trans-unit id="4409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`throw`</ph> instruction throws the exception object (type <ph id="ph2">`O`</ph>) currently on the stack.</source>
        </trans-unit>
        <trans-unit id="4410" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
        </trans-unit>
        <trans-unit id="4411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`throw`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4412" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4413" translate="yes" xml:space="preserve">
          <source>Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="4414" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4417" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4418" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4419" translate="yes" xml:space="preserve" extradata="MT">
          <source>unaligned.</source>
        </trans-unit>
        <trans-unit id="4420" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indicates that the subsequent pointer instruction may be unaligned.</source>
        </trans-unit>
        <trans-unit id="4421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4422" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4423" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Unaligned`</ph> specifies that the address (an unmanaged pointer, <ph id="ph2">`native int`</ph>) on the stack might not be aligned to the natural size of the immediately following <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, or <ph id="ph10">`cpblk`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="4424" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, for a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> instruction the alignment of the address may not be to a 4-byte boundary.</source>
        </trans-unit>
        <trans-unit id="4425" translate="yes" xml:space="preserve" extradata="MT">
          <source>For <ph id="ph1">`initblk`</ph> and <ph id="ph2">`cpblk`</ph> the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</source>
        </trans-unit>
        <trans-unit id="4426" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code generators that do not restrict their output to a 32-bit word size must use <ph id="ph1">`unaligned`</ph> if the alignment is not known at compile time to be 8-byte.</source>
        </trans-unit>
        <trans-unit id="4427" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</source>
        </trans-unit>
        <trans-unit id="4428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that transient pointers (type <ph id="ph1">`*`</ph>) are always aligned.</source>
        </trans-unit>
        <trans-unit id="4429" translate="yes" xml:space="preserve" extradata="MT">
          <source>While the alignment for a <ph id="ph1">`cpblk`</ph> instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</source>
        </trans-unit>
        <trans-unit id="4430" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`unaligned`</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
        </trans-unit>
        <trans-unit id="4431" translate="yes" xml:space="preserve" extradata="MT">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="4432" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
        </trans-unit>
        <trans-unit id="4433" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`unaligned`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4434" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Label)</source>
        </trans-unit>
        <trans-unit id="4435" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(Opcode, Byte)</source>
        </trans-unit>
        <trans-unit id="4436" translate="yes" xml:space="preserve">
          <source>Converts the boxed representation of a value type to its unboxed form.</source>
        </trans-unit>
        <trans-unit id="4437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4441" translate="yes" xml:space="preserve" extradata="MT">
          <source>79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4442" translate="yes" xml:space="preserve" extradata="MT">
          <source>unbox <ph id="ph1">`valType`</ph></source>
        </trans-unit>
        <trans-unit id="4443" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extracts the value type data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
        </trans-unit>
        <trans-unit id="4444" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4445" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4446" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference is popped from the stack and unboxed to a value type pointer.</source>
        </trans-unit>
        <trans-unit id="4447" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value type pointer is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4448" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
        </trans-unit>
        <trans-unit id="4449" translate="yes" xml:space="preserve" extradata="MT">
          <source>A 'raw' form used when a value type is embedded within another object.</source>
        </trans-unit>
        <trans-unit id="4450" translate="yes" xml:space="preserve" extradata="MT">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
        </trans-unit>
        <trans-unit id="4451" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`unbox`</ph> instruction converts the object reference (type <ph id="ph2">`O`</ph>), the boxed representation of a value type, to a value type pointer (a managed pointer, type <ph id="ph3">`&amp;`</ph>), its unboxed form.</source>
        </trans-unit>
        <trans-unit id="4452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The supplied value type (<ph id="ph1">`valType`</ph>) is a metadata token indicating the type of value type contained within the boxed object.</source>
        </trans-unit>
        <trans-unit id="4453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, which is required to make a copy of a value type for use in the object, <ph id="ph2">`unbox`</ph> is not required to copy the value type from the object.</source>
        </trans-unit>
        <trans-unit id="4454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically it simply computes the address of the value type that is already present inside of the boxed object.</source>
        </trans-unit>
        <trans-unit id="4455" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if the object is not boxed as <ph id="ph2">`valType`</ph>.</source>
        </trans-unit>
        <trans-unit id="4456" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
        </trans-unit>
        <trans-unit id="4457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the value type <ph id="ph2">`valType`</ph> cannot be found.</source>
        </trans-unit>
        <trans-unit id="4458" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
        </trans-unit>
        <trans-unit id="4459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4460" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="4461" translate="yes" xml:space="preserve">
          <source>Converts the boxed representation of a type specified in the instruction to its unboxed form.</source>
        </trans-unit>
        <trans-unit id="4462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4463" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4464" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4465" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4466" translate="yes" xml:space="preserve" extradata="MT">
          <source>A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
        </trans-unit>
        <trans-unit id="4467" translate="yes" xml:space="preserve" extradata="MT">
          <source>unbox.any <ph id="ph1">`typeTok`</ph></source>
        </trans-unit>
        <trans-unit id="4468" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extract the data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
        </trans-unit>
        <trans-unit id="4469" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4470" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4471" translate="yes" xml:space="preserve" extradata="MT">
          <source>The object reference is popped from the stack and unboxed to the type specified in the instruction.</source>
        </trans-unit>
        <trans-unit id="4472" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting object reference or value type is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4473" translate="yes" xml:space="preserve" extradata="MT">
          <source>When applied to the boxed form of a value type, the <ph id="ph1">`unbox.any`</ph> instruction extracts the value contained within <ph id="ph2">`obj`</ph> (of type <ph id="ph3">`O`</ph>), and is therefore equivalent to <ph id="ph4">`unbox`</ph> followed by <ph id="ph5">`ldobj`</ph>.</source>
        </trans-unit>
        <trans-unit id="4474" translate="yes" xml:space="preserve" extradata="MT">
          <source>When applied to a reference type, the <ph id="ph1">`unbox.any`</ph> instruction has the same effect as <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</source>
        </trans-unit>
        <trans-unit id="4475" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the operand <ph id="ph1">`typeTok`</ph> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</source>
        </trans-unit>
        <trans-unit id="4476" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is not a boxed type.</source>
        </trans-unit>
        <trans-unit id="4477" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is a null reference.</source>
        </trans-unit>
        <trans-unit id="4478" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox.any`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4479" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode, Type)</source>
        </trans-unit>
        <trans-unit id="4480" translate="yes" xml:space="preserve">
          <source>Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
        </trans-unit>
        <trans-unit id="4481" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4482" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4484" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4485" translate="yes" xml:space="preserve" extradata="MT">
          <source>FE 13</source>
        </trans-unit>
        <trans-unit id="4486" translate="yes" xml:space="preserve" extradata="MT">
          <source>volatile.</source>
        </trans-unit>
        <trans-unit id="4487" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indicates that the subsequent pointer reference is volatile.</source>
        </trans-unit>
        <trans-unit id="4488" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4489" translate="yes" xml:space="preserve" extradata="MT">
          <source>An address is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4490" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`volatile`</ph>.</source>
        </trans-unit>
        <trans-unit id="4491" translate="yes" xml:space="preserve" extradata="MT">
          <source>specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
        </trans-unit>
        <trans-unit id="4492" translate="yes" xml:space="preserve" extradata="MT">
          <source>Marking an access as <ph id="ph1">`volatile`</ph> affects only that single access; other accesses to the same location must be marked separately.</source>
        </trans-unit>
        <trans-unit id="4493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Access to volatile locations need not be performed atomically.</source>
        </trans-unit>
        <trans-unit id="4494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
        </trans-unit>
        <trans-unit id="4495" translate="yes" xml:space="preserve" extradata="MT">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
        </trans-unit>
        <trans-unit id="4496" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only the <ph id="ph1">`volatile`</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
        </trans-unit>
        <trans-unit id="4497" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`volatile`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4498" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
        <trans-unit id="4499" translate="yes" xml:space="preserve">
          <source>Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</source>
        </trans-unit>
        <trans-unit id="4500" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
        </trans-unit>
        <trans-unit id="4501" translate="yes" xml:space="preserve" extradata="MT">
          <source>Format</source>
        </trans-unit>
        <trans-unit id="4502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly Format</source>
        </trans-unit>
        <trans-unit id="4503" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="4504" translate="yes" xml:space="preserve" extradata="MT">
          <source>61</source>
        </trans-unit>
        <trans-unit id="4505" translate="yes" xml:space="preserve" extradata="MT">
          <source>xor</source>
        </trans-unit>
        <trans-unit id="4506" translate="yes" xml:space="preserve" extradata="MT">
          <source>Computes the bitwise XOR of two integer values and returns an integer.</source>
        </trans-unit>
        <trans-unit id="4507" translate="yes" xml:space="preserve" extradata="MT">
          <source>The stack transitional behavior, in sequential order, is:</source>
        </trans-unit>
        <trans-unit id="4508" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4509" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4510" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise XOR computed.</source>
        </trans-unit>
        <trans-unit id="4511" translate="yes" xml:space="preserve" extradata="MT">
          <source>The bitwise XOR of <ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> is pushed onto the stack.</source>
        </trans-unit>
        <trans-unit id="4512" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`xor`</ph> instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</source>
        </trans-unit>
        <trans-unit id="4513" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Xor`</ph> is an integer-specific operation.</source>
        </trans-unit>
        <trans-unit id="4514" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`xor`</ph> opcode:</source>
        </trans-unit>
        <trans-unit id="4515" translate="yes" xml:space="preserve" extradata="MT">
          <source>ILGenerator.Emit(OpCode)</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>