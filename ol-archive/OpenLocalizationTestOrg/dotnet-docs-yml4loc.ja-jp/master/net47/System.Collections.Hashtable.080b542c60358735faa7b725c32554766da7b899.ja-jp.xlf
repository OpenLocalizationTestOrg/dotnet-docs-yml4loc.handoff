<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a3fe3ec61f6a4877de85c615781d98d04181423f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Collections.Hashtable.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9206bd032136565226631bc68f3db35cab14cad9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56879f17f26bd3f784c248d7156352b596fd8a4f</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a collection of key/value pairs that are organized based on the hash code of the key.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)</ept>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each element is a key/value pair stored in a <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The objects used as keys by a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are required to override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method (or the <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> interface) and the <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method (or the <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> interface).</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implementation of both methods and interfaces must handle case sensitivity the same way; otherwise, the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> might behave incorrectly.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, when creating a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, you must use the <ph id="ph2">&lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</ph> class (or any case-insensitive <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation) with the <ph id="ph4">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> class (or any case-insensitive <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> implementation).</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Furthermore, these methods must produce the same results when called with the same parameters while the key exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>An alternative is to use a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor with an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>If key equality were simply reference equality, the inherited implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> would suffice.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Key objects must be immutable as long as they are used as keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>When an element is added to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the element is placed into a bucket based on the hash code of the key.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent lookups of the key use the hash code of the key to search in only one particular bucket, thus substantially reducing the number of key comparisons required to find an element.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> determines the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Smaller load factors cause faster average lookup times at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default load factor of 1.0 generally provides the best balance between speed and size.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>A different load factor can also be specified when the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is created.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the actual load factor of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> increases.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is automatically increased to the smallest prime number that is larger than twice the current number of <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> buckets.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each key object in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must provide its own hash function, which can be accessed by calling <ph id="ph2">&lt;xref:System.Collections.Hashtable.GetHash%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any object implementing <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> can be passed to a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, and that hash function is used for all objects in the table.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> can hold.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`For Each`</ph> in Visual Basic) returns an object of the type of the elements in the collection.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since each element of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is a key/value pair, the element type is not the type of the key or the type of the value.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the element type is <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Collections.Hashtable_ClassExample#01<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement is a wrapper around the enumerator, which only allows reading from, not writing to, the collection.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because keys can be inherited and their behavior changed, their absolute uniqueness cannot be guaranteed by comparisons using the <ph id="ph1">&lt;xref:System.Type.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the default initial capacity, load factor, hash code provider, and comparer.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the specified initial capacity, load factor, hash code provider, and comparer.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object can initially contain.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;&lt;/xref&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> object to use to determine whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, hash code provider, and comparer.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IDictionary"&gt;&lt;/xref&gt;</ph> object to copy to a new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;&lt;/xref&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> object to use to determine whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the specified initial capacity, load factor, and <ph id="ph2">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object can initially contain.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider and the default comparer.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the specified initial capacity, hash code provider, comparer, and the default load factor.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object can initially contain.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;&lt;/xref&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> object to use to determine whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor and <ph id="ph2">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IDictionary"&gt;&lt;/xref&gt;</ph> object to copy to a new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider and the default comparer.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, and the specified hash code provider and comparer.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>This API is obsolete.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>For an alternative, see <ph id="ph1">&lt;xref href="System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IDictionary"&gt;&lt;/xref&gt;</ph> object to copy to a new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;&lt;/xref&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> object to use to determine whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the specified initial capacity and load factor, and the default hash code provider and comparer.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object can initially contain.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is causing an overflow.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class that is serializable using the specified <ph id="ph2">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;&lt;/xref&gt;</ph> and <ph id="ph3">&lt;xref href="System.Runtime.Serialization.StreamingContext"&gt;&lt;/xref&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;&lt;/xref&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Runtime.Serialization.StreamingContext"&gt;&lt;/xref&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;info&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the default initial capacity and load factor, and the specified hash code provider and comparer.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;&lt;/xref&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> object to use to determine whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, and the default hash code provider and comparer.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IDictionary"&gt;&lt;/xref&gt;</ph> object to copy to a new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The result is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is less than 0.1.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;loadFactor&lt;/code&gt;</ph> is greater than 1.0.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class by copying the elements from the specified dictionary to a new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor and the specified <ph id="ph2">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IDictionary"&gt;&lt;/xref&gt;</ph> object to copy to a new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider and the default comparer.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the specified initial capacity, and the default load factor, hash code provider, and comparer.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object can initially contain.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the default initial capacity and load factor, and the specified <ph id="ph2">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider and the default comparer.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>The new <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, hash code provider, and comparer.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IDictionary"&gt;&lt;/xref&gt;</ph> object to copy to a new <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;d&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> class using the specified initial capacity and <ph id="ph2">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph>, and the default load factor.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>Capacity is automatically increased as required based on the load factor.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer determines whether two keys are equal.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>The approximate number of elements that the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> object can initially contain.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default hash code provider and the default comparer.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;xref href="System.Object.GetHashCode"&gt;&lt;/xref&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;xref href="System.Object.Equals(System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Adds an element with the specified key and value into the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object that has no correlation between its state and its hash code value should typically not be used as the key.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, String objects are better than StringBuilder objects for use as keys.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is less than the capacity of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, this method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The key of the element to add.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The value of the element to add.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>An element with the same key already exists in the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>Removes all elements from the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity remains unchanged.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> clone has the same count, the same capacity, the same <ph id="ph2">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, and the same <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation as the original <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>A shallow copy of the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>Gets or sets the <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> to use for the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph> to use for the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>Determines whether the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> contains a specific key.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> implements <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>It behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>The key to locate in the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>Determines whether the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> contains a specific key.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>The key to locate in the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>Determines whether the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> contains a specific value.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>The values of the elements of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are compared to the specified value using the <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>The value to locate in the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> contains an element with the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p1">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Copies the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> elements to a one-dimensional <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> instance at the specified index.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT">
          <source>To copy only the keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Keys.CopyTo`</ph>.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>To copy only the values in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Values.CopyTo`</ph>.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that is the destination of the <ph id="ph2">&lt;xref href="System.Collections.DictionaryEntry"&gt;&lt;/xref&gt;</ph> objects copied from <ph id="ph3">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> must have zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The zero-based index in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>The number of elements in the source <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is greater than the available space from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">arrayIndex</ph><ept id="p1">&lt;/code&gt;</ept> to the end of the destination <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The type of the source <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> cannot be cast automatically to the type of the destination <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Gets the number of key/value pairs contained in the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>The number of key/value pairs contained in the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> to use for the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> includes both the comparer and the hash code provider.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph> to use for the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;xref href="System.Collections.IHashCodeProvider"&gt;&lt;/xref&gt;</ph> and an <ph id="ph2">&lt;xref href="System.Collections.IComparer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>Returns an <ph id="ph1">&lt;xref href="System.Collections.IDictionaryEnumerator"&gt;&lt;/xref&gt;</ph> that iterates through the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>[Visual Basic, C#]</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.IDictionaryEnumerator"&gt;&lt;/xref&gt;</ph> for the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Returns the hash code for the specified key.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, this method uses that hash code provider; otherwise, it uses the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> implementation of <ph id="ph3">`key`</ph>.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> for which a hash code is to be returned.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The hash code for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">key</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>Implements the <ph id="ph1">&lt;xref href="System.Runtime.Serialization.ISerializable"&gt;&lt;/xref&gt;</ph> interface and returns the data needed to serialize the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;&lt;/xref&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Runtime.Serialization.StreamingContext"&gt;&lt;/xref&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;info&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>The collection was modified.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Gets or sets the object that can dispense hash codes.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The object that can dispense hash codes.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;xref href="System.Collections.IEqualityComparer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> has a fixed size; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is read-only; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is synchronized (thread safe).</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can support one writer and multiple readers concurrently.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>To support multiple writers, all operations must be done through the wrapper returned by the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if access to the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Gets or sets the value associated with the specified key.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[key]`</ph>.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>To distinguish between <ph id="ph1">`null`</ph> that is returned because the specified key is not found and <ph id="ph2">`null`</ph> that is returned because the value of the specified key is <ph id="ph3">`null`</ph>, use the <ph id="ph4">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> method or the <ph id="ph5">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph> method to determine if the key exists in the list.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.IList.Item%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>The key whose value to get or set.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The value associated with the specified key.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>If the specified key is not found, attempting to get it returns <ph id="ph1">`null`</ph>, and attempting to set it creates a new element using the specified key.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>The property is set and the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>The property is set, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">key</ph><ept id="p1">&lt;/code&gt;</ept> does not exist in the collection, and the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>Compares a specific <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> with a specific key in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation, this method uses that comparer; that is, <ph id="ph2">&lt;xref:System.Collections.IComparer.Compare%2A&gt;</ph> (<ph id="ph3">`item`</ph>, <ph id="ph4">`key`</ph>).</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses <ph id="ph1">`item.Equals(key)`</ph>.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> to compare with <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">key</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>The key in the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> to compare with <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">item</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">item</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">key</ph><ept id="p2">&lt;/code&gt;</ept> are equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;item&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Gets an <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> containing the keys in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the keys in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated values in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Values%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the keys in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> containing the keys in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>Implements the <ph id="ph1">&lt;xref href="System.Runtime.Serialization.ISerializable"&gt;&lt;/xref&gt;</ph> interface and raises the deserialization event when the deserialization is complete.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>The source of the deserialization event.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Runtime.Serialization.SerializationInfo"&gt;&lt;/xref&gt;</ph> object associated with the current <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Removes the element with the specified key from the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> does not contain an element with the specified key, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> remains unchanged.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>The key of the element to remove.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;key&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>Returns a synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method is thread safe for multiple readers and writers.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>Furthermore, the synchronized wrapper ensures that there is only one writer writing at a time.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph> to synchronize.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>A synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> .</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>Classic Hashtable.IsSynchronized Example#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Gets an <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> containing the values in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the values in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated keys in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Keys%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the values in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> containing the values in the <ph id="ph2">&lt;xref href="System.Collections.Hashtable"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>Returns an enumerator that iterates through a collection.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>[Visual Basic, C#]</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, calling <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, calling <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator can be invalidated and the next call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the collection is modified between <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the element that it is set to, even if the enumerator is already invalidated.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.IEnumerator"&gt;&lt;/xref&gt;</ph> that can be used to iterate through the collection.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>