<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6122df98f127b624d0f8f428a5e065f1fcf24227</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Type.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff9d504ad35d2fd358ade45a620fa59d3e35adf3</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6d0a2d79ecddc663b28e059900b0b19ef5ec23f1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3)</ept>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type`</ph> is the root of the <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> functionality and is the primary way to access metadata.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the members of <ph id="ph1">&lt;xref:System.Type&gt;</ph> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type`</ph> is an abstract base class that allows multiple implementations.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system will always provide the derived class <ph id="ph1">`RuntimeType`</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>In multithreading scenarios, do not lock <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects in order to synchronize access to <ph id="ph2">`static`</ph> data.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Other code, over which you have no control, might also lock your class type.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might result in a deadlock.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, synchronize access to static data by locking a private <ph id="ph1">`static`</ph> object.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>A derived class can access protected members of the calling code's base classes.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, access is allowed to assembly members of the calling code's assembly.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section:</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>What types does a Type object represent?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Retrieving a Type object<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Comparing type objects for equality<ept id="p1">](#Equality)</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>What types does a Type object represent?</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>This class is thread safe; multiple threads can concurrently read from an instance of this type.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Type&gt;</ph> class can represent any of the following types:</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value types</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Interfaces</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerations</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delegates</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructed generic types and generic type definitions</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving a Type object</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object associated with a particular type can be obtained in the following ways:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>The instance <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=fullName&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the type of an instance.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because all managed types derive from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be called on an instance of any type.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=fullName&gt;</ph> method to determine the runtime type of each object in an object array.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)</ept><ept id="p3">]</ept>  <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The static <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> methods return a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a type specified by its fully qualified name.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=fullName&gt;</ph> methods return <ph id="ph4">`Type`</ph> objects that represent the types defined in a module.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first method can be used to obtain an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects for all the public and private types defined in a module.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>(You can obtain an instance of <ph id="ph1">`Module`</ph> through the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=fullName&gt;</ph> method, or through the <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=fullName&gt;</ph> property.)</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=fullName&gt;</ph> object contains a number of methods to retrieve the classes defined in an assembly, including <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> method returns a filtered list of interface types supported by a type.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> method returns a <ph id="ph2">`Type`</ph> object that represents the element.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> methods return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects representing the interface types supported by a type.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method returns an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects representing the types specified by an arbitrary set of objects.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The objects are specified with an array of type <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> methods are provided for COM interoperability.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>They return a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type specified by a <ph id="ph2">`ProgID`</ph> or <ph id="ph3">`CLSID`</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method is provided for interoperability.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>It returns a <ph id="ph1">`Type`</ph> object that represents the type specified by a class handle.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The C# <ph id="ph1">`typeof`</ph> operator, the C++ <ph id="ph2">`typeid`</ph> operator, and the Visual Basic <ph id="ph3">`GetType`</ph> operator obtain the <ph id="ph4">`Type`</ph> object for a type.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing a constructed generic type, which is an open constructed type if its <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, and a closed constructed type otherwise.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type can be instantiated only if it is closed.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> methods return <ph id="ph4">&lt;xref:System.Type&gt;</ph> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<ph id="ph5">`ref`</ph> in C#, <ph id="ph6">`ByRef`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparing type objects for equality</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a type is unique; that is, two <ph id="ph2">&lt;xref:System.Type&gt;</ph> object references refer to the same object if and only if they represent the same type.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>This allows for comparison of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects using reference equality.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example compares the <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent a number of integer values to determine whether they are of the same type.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type#3<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type#3<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type#3<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is invoked by derived classes during the construction of type objects.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Reflection.Assembly"&gt;&lt;/xref&gt;</ph> in which the type is declared.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For generic types, gets the <ph id="ph1">&lt;xref href="System.Reflection.Assembly"&gt;&lt;/xref&gt;</ph> in which the generic type is defined.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in another assembly, the <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> property for the constructed type returns an <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents MyGenerics.dll.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an unassigned generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=fullName&gt;</ph> property is not available on a particular .NET platform, such as .NET Core or the Universal Windows Platform, use the  <ph id="ph2">`System.Reflection.TypeInfo.Assembly`</ph> property instead.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>?qualifyHint=False&amp;autoUpgrade=True</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Reflection.Assembly"&gt;&lt;/xref&gt;</ph> instance that describes the assembly containing the current type.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object was loaded.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The display name of an assembly is obtained using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, "ProcessorArchitecture=msil".</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>Escape character.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comma (,)</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes the Assembly name.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Plus sign (+)</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes a nested class.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>Period (.)</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Denotes namespace identifiers.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Brackets ([])</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>After a type name, denotes an array of that type.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a generic type, encloses the generic type argument list.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within a type argument list, encloses an assembly-qualified type.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the assembly-qualified name for a class might look like this:</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection would emit this string as follows:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generic arguments of generic types are themselves qualified by assembly name.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in the assembly-qualified type name for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id="ph3">`int`</ph> is expanded to the assembly-qualified type name for <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, which includes the name of the assembly from which the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> was loaded, or <ph id="ph3">`null`</ph> if the current instance represents a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Gets the attributes associated with the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some members of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration are masks that represent a group of values.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each group includes one member whose underlying value is zero.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the underlying value of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> member in the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> group is zero, as is the <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> member in the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> group.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of this, you must use the mask before testing for those values.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most purposes, properties like<ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, and<ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> are easier to use than type attributes.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the attributes of the generic type definition.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the attributes returned for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic) are the attributes of <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter — that is, if the <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph3">`true`</ph> — the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> value returned by this property is unspecified.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.TypeAttributes"&gt;&lt;/xref&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, unless the <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a generic type parameter, in which case the value is unspecified.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Gets the type from which the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> directly inherits.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>The base type is the type from which the current type directly inherits.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object&gt;</ph> is the only type that does not have a base type, therefore <ph id="ph2">`null`</ph> is returned as the base type of <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Interfaces inherit from zero or more base interfaces; therefore, this property returns <ph id="ph1">`null`</ph> if the <ph id="ph2">`Type`</ph> object represents an interface.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The base interfaces can be determined with <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, the base type reflects the generic arguments.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider the following declarations:</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type.BaseType#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type.BaseType#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type.BaseType#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> property returns <ph id="ph4">`B&lt;int&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type definition, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns the class constraint, that is, the class the type parameter must inherit.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no class constraint, <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> from which the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> directly inherits, or <ph id="ph3">`null`</ph> if the current <ph id="ph4">`Type`</ph> represents the <ph id="ph5">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> class or an interface.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object has type parameters that have not been replaced by specific types.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since types can be arbitrarily complex, making this determination is difficult.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>For convenience and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the type cannot be instantiated.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, it returns <ph id="ph1">`true`</ph> for an array whose elements are type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the array is not itself generic.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for arrays.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a set of example classes and a table showing the values of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property, see <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> that represents the declaring method, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a type parameter of a generic method.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>The declaring method is a generic method definition.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, if <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> does not return <ph id="ph2">`null`</ph>, then <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> returns <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> that is returned by the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property is either a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the case of a generic method, or a <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> in the case of a generic constructor.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, generic constructors are not supported.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a type parameter of a generic method, a <ph id="ph2">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> that represents declaring method; otherwise, <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Gets the type that declares the current nested type or generic type parameter.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type, this property returns the generic type definition.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type is generic, the generic type definition is returned.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the following code returns the generic type definition of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, which contains the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generic method:</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type.DeclaringType#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type.DeclaringType#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type.DeclaringType#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <ph id="ph1">&lt;xref href="System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> class and pass an instance of that type using the <ph id="ph2">`binder`</ph> parameter of one of the <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> overloads.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection models the accessibility rules of the common type system.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the caller needs <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is consistent with lookup of members that are protected, private, and so on.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>The general principle is that <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> should perform only widening conversions, which never lose data.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is distinguished from a narrowing conversion, which may lose data.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the conversions supported by the default binder.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>Source Type</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>Target Type</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any type</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its base type.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any type</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>The interface it implements.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Byte</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>SByte</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Int16, Int32, Int64, Single, Double</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>UInt16</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>UInt32, Int32, UInt64, Int64, Single, Double</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>Int16</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>Int32, Int64, Single, Double</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>UInt32</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>UInt64, Int64, Single, Double</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>Int32</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>Int64, Single, Double</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>UInt64</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>Single, Double</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>Int64</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>Single, Double</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>Single</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>Double</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-reference</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>By-reference.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>A reference to the default binder used by the system.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Separates names in the namespace of the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Represents an empty array of type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object is the same as the underlying system type of the specified <ph id="ph2">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>It casts <ph id="ph1">`o`</ph> to an object of type <ph id="ph2">&lt;xref:System.Type&gt;</ph> and calls the <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>For the comparison to succeed, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">o</ph><ept id="p1">&lt;/code&gt;</ept> must be able to be cast or converted to an object of type   <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the underlying system type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">o</ph><ept id="p1">&lt;/code&gt;</ept> is the same as the underlying system type of the current <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>This method also returns <ph id="ph1">`false`</ph> if: .</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><ph id="ph1">-   &lt;code&gt;o&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><ph id="ph1">-   &lt;code&gt;o&lt;/code&gt;</ph> cannot be cast or converted to a <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the underlying system type of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">o</ph><ept id="p1">&lt;/code&gt;</ept> is the same as the underlying system type of the current <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Represents the member filter used on attributes.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Object`</ph> may be assigned the value of any one of the fields on the classes <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">`Object`</ph> can be assigned the value of a field from <ph id="ph2">`FieldAttributes`</ph> such as Public.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, when the <ph id="ph1">`FilterAttribute`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object is decorated with the public field attribute in metadata.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Represents the case-sensitive member filter used on names.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only wildcard end string matching is supported.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "Byte*".</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object has a name that begins with "Byte".</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Represents the case-insensitive member filter used on names.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only wildcard end string matching is supported.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "ByTe*".</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return true only if the method represented by the <ph id="ph2">`MemberInfo`</ph> object has a name that begins with "byte", ignoring case.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing a filtered list of interfaces implemented or inherited by the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=fullName&gt;</ph> delegates supplied by the <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=fullName&gt;</ph> class may also be used, in lieu of the <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=fullName&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>No duplicate interfaces are returned.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type argument of a generic type, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces implemented by the type, whether or not they match constraints.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> can return generic interfaces, even on types that are not generic.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a nongeneric type might implement <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The delegate that compares the interfaces against <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">filterCriteria</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The search criteria that determines whether an interface should be included in the returned array.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing a filtered list of the interfaces implemented or inherited by the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, or an empty array of type <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> if no interfaces matching the filter are implemented or inherited by the current <ph id="ph4">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;filter&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>A static initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Returns a filtered array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects of the specified member type.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members include properties, methods, fields, events, and so on.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Instance`</ph> to include instance members in the search.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Static`</ph> to include static members in the search.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid values for <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> are defined in <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no such members are found, an empty array is returned.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> processes any members declared by the class constraint and the interface constraints of the type parameter.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>An object that indicates the type of member to search for.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The delegate that does the comparisons, returning <ph id="ph1">`true`</ph> if the member currently being inspected matches the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">filterCriteria</ph><ept id="p1">&lt;/code&gt;</ept> and <ph id="ph3">`false`</ph> otherwise.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>You can use the <ph id="ph1">`FilterAttribute`</ph>, <ph id="ph2">`FilterName`</ph>, and <ph id="ph3">`FilterNameIgnoreCase`</ph> delegates supplied by this class.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The first uses the fields of <ph id="ph1">`FieldAttributes`</ph>, <ph id="ph2">`MethodAttributes`</ph>, and <ph id="ph3">`MethodImplAttributes`</ph> as search criteria, and the other two delegates use <ph id="ph4">`String`</ph> objects as the search criteria.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>The search criteria that determines whether a member is returned in the array of <ph id="ph1">`MemberInfo`</ph> objects.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The fields of <ph id="ph1">`FieldAttributes`</ph>, <ph id="ph2">`MethodAttributes`</ph>, and <ph id="ph3">`MethodImplAttributes`</ph> can be used in conjunction with the <ph id="ph4">`FilterAttribute`</ph> delegate supplied by this class.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>A filtered array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects of the specified member type.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph>, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> does not have members of type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">memberType</ph><ept id="p1">&lt;/code&gt;</ept> that match the filter criteria.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;filter&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Gets the fully qualified name of the type, including its namespace but not its assembly.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the fully qualified name of the <ph id="ph1">&lt;xref:System.String&gt;</ph> type is <ph id="ph2">`System.String`</ph>.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the assembly-qualified name returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, which consists of the full name plus the full assembly name.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current type represents a closed generic type, the type arguments in the string returned by the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph>property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.FullName#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.FullName#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns <ph id="ph1">`null`</ph> if:</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example retrieves the type parameter of the <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type and attempts to display its <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.FullName#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.FullName#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an array type, a pointer  type, or a <ph id="ph2">`byref`</ph> type that is based on a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example defines a generic type, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, with three methods: <ph id="ph2">`Display(T[])`</ph>, which is passed an array of type T; <ph id="ph3">`HandleT(T)`</ph>, which is passed a T object; and <ph id="ph4">`ChangeValue(ref T)`</ph>, which is passed a T object by reference.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because C# and Visual Basic do not allow us to define T as a pointer in the <ph id="ph1">`HandleT`</ph> method, we have to call the <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents the method's parameter type to create a pointer to a generic type.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The output from the example shows that in all three cases, the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.FullName#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.FullName#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current type contains generic type parameters that have not been replaced by specific types (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>), but the type is not a generic type definition (that is, the <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph4">`false`</ph></source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, <ph id="ph1">`Derived&lt;T&gt;`</ph> inherits from <ph id="ph2">`Base&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property obtains the  <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the base type of <ph id="ph3">`Derived&lt;T&gt;`</ph>, and its <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> property returns <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.FullName#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.FullName#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get a <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> that is not <ph id="ph2">`null`</ph>, you can use the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get the generic type definition, as the example illustrates.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the type, including its namespace but not its assembly; or <ph id="ph1">`null`</ph> if the current instance represents a generic type parameter, an array type, pointer type, or <ph id="ph2">`byref`</ph> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Gets a combination of <ph id="ph1">&lt;xref href="System.Reflection.GenericParameterAttributes"&gt;&lt;/xref&gt;</ph> flags that describe the covariance and special constraints of the current generic type parameter.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName&gt;</ph> value to select the covariance flags, and use the <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName&gt;</ph> value to select the constraint flags.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>A bitwise combination of <ph id="ph1">&lt;xref href="System.Reflection.GenericParameterAttributes"&gt;&lt;/xref&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object is not a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>That is, the <ph id="ph1">&lt;xref href="System.Type.IsGenericParameter"&gt;&lt;/xref&gt;</ph> property returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object represents a type parameter of a generic type or a generic method.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type or method definition:</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide the correct context for the value of the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property, it is necessary to identify the generic type or method a type parameter belongs to.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider the return value of the generic method <ph id="ph1">`GetSomething`</ph> in the following code:</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type.GenericParameterPosition#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type.GenericParameterPosition#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type.GenericParameterPosition#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type returned by <ph id="ph1">`GetSomething`</ph> depends on the type arguments supplied to class <ph id="ph2">`A`</ph> and to <ph id="ph3">`GetSomething`</ph> itself.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for <ph id="ph2">`GetSomething`</ph>, and from that you can obtain the return type.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you examine the type parameters of the return type, <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> returns 0 for both.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>The position of <ph id="ph1">`V`</ph> is 0 because <ph id="ph2">`V`</ph> is the first type parameter in the type parameter list for class <ph id="ph3">`A`</ph>.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>The position of <ph id="ph1">`X`</ph> is 0 because <ph id="ph2">`X`</ph> is the first type parameter in the type parameter list for <ph id="ph3">`GetSomething`</ph>.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property causes an exception if the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> does not represent a type parameter.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you examine the type arguments of an open constructed type, use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell which are type parameters and which are types.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for a type parameter; you can then use the <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> method to obtain its position and use the <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> properties to determine the generic method or type definition that defines it.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Position numbers begin at 0.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The current type does not represent a type parameter.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Type.IsGenericParameter"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>Gets an array of the generic type arguments for this type.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current type is a generic type definition, this property returns an empty array.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the generic type parameters of a type that represents a generic type definition, use the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object for the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, use the <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName&gt;</ph> extension method.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>An array of the generic type arguments for this type.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Gets the number of dimensions in an array.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>An integer that contains the number of dimensions in the current type.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The current type is not an array.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;xref href="System.Type.Attributes"&gt;&lt;/xref&gt;</ph> property and gets a bitmask indicating the attributes associated with the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.TypeAttributes"&gt;&lt;/xref&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Searches for a public instance constructor whose parameters match the types in the specified array.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get a class initializer, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the requested constructor is non-public, this method returns <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the desired constructor.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>An empty array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects, to get a constructor that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Such an empty array is provided by the <ph id="ph1">`static`</ph> field <ph id="ph2">&lt;xref href="System.Type.EmptyTypes"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Type.EmptyTypes"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the parameter type array.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>An object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method implements <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The current type is a <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Reflection.Emit.GenericTypeParameterBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>Returns all the public constructors defined for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>It will not find class initializers (.cctor).</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> objects representing all the public instance constructors defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, but not including the type initializer (static constructor).</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>If no public instance constructors are defined for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, or if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a type parameter in the definition of a generic type or generic method, an empty array of type <ph id="ph3">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the constructors defined for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, using the specified <ph id="ph2">`BindingFlags`</ph>.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`bindingAttr`</ph> can be used to specify whether to return only public constructors or both public and non-public constructors.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructors of base classes are not returned.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> objects representing all constructors defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints, including the type initializer if it is defined.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Returns an empty array of type <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> if no constructors are defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if none of the defined constructors match the binding constraints, or if the current <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a type parameter in the definition of a generic type or generic method.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>Searches for the members defined for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> whose <ph id="ph2">&lt;xref href="System.Reflection.DefaultMemberAttribute"&gt;&lt;/xref&gt;</ph> is set.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members include properties, methods, fields, events, and so on.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a property <ph id="ph2">`P`</ph> that returns <ph id="ph3">`T`</ph>, calling <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns <ph id="ph6">`int P`</ph> in C# (<ph id="ph7">`Property P As Integer`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing all default members of the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph>, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> does not have default members.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the object encompassed or referred to by the current array, pointer or reference type.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns <ph id="ph1">`null`</ph> for the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the object encompassed or referred to by the current array, pointer, or reference type, or <ph id="ph2">`null`</ph> if the current <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>Returns the name of the constant that has the specified value, for the current enumeration type.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The value whose name is to be retrieved.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>The name of the member of the current enumeration type that has the specified value, or <ph id="ph1">`null`</ph> if no such constant is found.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>The current type is not an enumeration.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is neither of the current type nor does it have the same underlying type as the current type.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>Returns the names of the members of the current enumeration type.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>An array that contains the names of the members of the enumeration.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source>The current type is not an enumeration.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>Returns the underlying type of the current enumeration type.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the underlying type of an enumeration in C# and Visual Basic is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Other integer types can be specified.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>The underlying type of the current enumeration.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>The current type is not an enumeration.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The enumeration type is not valid, because it contains more than one instance field.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>Returns an array of the values of the constants in the current enumeration type.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>An array that contains the values.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>The current type is not an enumeration.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph> object representing the specified public event.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance events.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>The string containing the name of an event that is declared or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>The object representing the specified public event that is declared or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph> object representing the specified event, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>The string containing the name of an event which is declared or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>The object representing the specified event that is declared or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>Returns all the public events that are declared or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph> objects representing all the public events which are declared or inherited by the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph>, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> does not have public events.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for events that are declared or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only protected and internal events on base classes are returned; private events on base classes are not returned.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph> objects representing all events that are declared or inherited by the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.EventInfo"&gt;&lt;/xref&gt;</ph>, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> does not have events, or if none of the events match the binding constraints.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>Searches for the public field with the specified name.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance fields.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>The string containing the name of the data field to get.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>An object representing the public field with the specified name, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>This <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object is a <ph id="ph2">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> whose <ph id="ph3">&lt;xref href="System.Reflection.Emit.TypeBuilder.CreateType"&gt;&lt;/xref&gt;</ph> method has not yet been called.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Searches for the specified field, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>The string containing the name of the data field to get.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>An object representing the field that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>Returns all the public fields of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.FieldInfo"&gt;&lt;/xref&gt;</ph> objects representing all the public fields defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.FieldInfo"&gt;&lt;/xref&gt;</ph>, if no public fields are defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the fields defined for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.FieldInfo"&gt;&lt;/xref&gt;</ph> objects representing all fields defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.FieldInfo"&gt;&lt;/xref&gt;</ph>, if no fields are defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, or if none of the defined fields match the binding constraints.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current type is a closed constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic type definition.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current type is a generic type definition, the array contains the type parameters.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current type is an open constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a generic type.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source>Returns an empty array if the current type is not a generic type.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>Derived classes must provide an implementation.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each constraint on a generic type parameter is expressed as a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> property to determine whether a constraint is the base class constraint; if the property returns <ph id="ph2">`false`</ph>, the constraint is an interface constraint.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type parameter has no class constraint and no interface constraints, an empty array is returned.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object is not a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source>That is, the <ph id="ph1">&lt;xref href="System.Type.IsGenericParameter"&gt;&lt;/xref&gt;</ph> property returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents a generic type definition from which the current generic type can be constructed.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type definition is a template from which other types can be constructed.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the generic type definition.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two constructed types are created from the same generic type definition, using the same type arguments, the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for both types.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that already represents a generic type definition, it returns the current <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>An array of generic types is not itself generic.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the C# code <ph id="ph1">`A&lt;int&gt;[] v;`</ph> or the Visual Basic code <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, the type of variable <ph id="ph3">`v`</ph> is not generic.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> to determine whether a type is generic before calling <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing a generic type from which the current type can be constructed.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>The current type is not a generic type.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Type.IsGenericType"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>Derived classes must provide an implementation.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>Returns the hash code for this instance.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>The hash code for this instance.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>Searches for the interface with the specified name.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">``"IExample`1"``</ph>.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>The string containing the name of the interface to get.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>For generic interfaces, this is the mangled name.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ignoreCase`</ph> parameter applies only to the simple interface name, not to the namespace.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>The portion of <ph id="ph1">`name`</ph> that specifies the namespace must have the correct case, or the interface will not be found.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the string "System.icomparable" finds the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface, but the string "system.icomparable" does not.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">`"IExample`</ph>1"`.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>The string containing the name of the interface to get.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>For generic interfaces, this is the mangled name.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to ignore the case of that part of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">name</ph><ept id="p1">&lt;/code&gt;</ept> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> to perform a case-sensitive search for all parts of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">name</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>Returns an interface mapping for the specified interface type.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> returned by this method.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>The interface type to retrieve a mapping for.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>An object that represents the interface mapping for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">interfaceType</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;interfaceType&lt;/code&gt;</ph> is not implemented by the current type.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">interfaceType</ph><ept id="p1">&lt;/code&gt;</ept> parameter does not refer to an interface.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;interfaceType&lt;/code&gt;</ph> is a generic interface, and the current type is an array type.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;interfaceType&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a generic type parameter; that is, <ph id="ph2">&lt;xref href="System.Type.IsGenericParameter"&gt;&lt;/xref&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve">
          <source>Derived classes must provide an implementation.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> method does not return interfaces in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which interfaces are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing all the interfaces implemented or inherited by the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if no interfaces are implemented or inherited by the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>A static initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>Searches for the public members with the specified name.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance members.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members include properties, methods, fields, events, and so on.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload will not find class initializers (.cctor).</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public members to get.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source>Searches for the specified members, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members include properties, methods, fields, events, and so on.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic) for <ph id="ph7">`bindingAttr`</ph>.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve">
          <source>The string containing the name of the members to get.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source>Zero, to return an empty array.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve">
          <source>Searches for the specified members of the specified member type, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members include properties, methods, fields, events, and so on.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes?displayProperty=fullName&gt;</ph> for <ph id="ph3">`type`</ph>, and  <ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph7">`Or`</ph><ph id="ph8">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic) for <ph id="ph9">`bindingAttr`</ph>.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source>The string containing the name of the members to get.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve">
          <source>The value to search for.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve">
          <source>Zero, to return an empty array.</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve">
          <source>A derived class must provide an implementation.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve">
          <source>Returns all the public members of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members include properties, methods, fields, events, and so on.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph6">`Or`</ph><ph id="ph7">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph8">`Or`</ph><ph id="ph9">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT">
          <source>It will not find class initializers (.cctor).</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing all the public members of the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph>, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> does not have public members.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the members defined for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members include properties, methods, fields, events, and so on.</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only protected and internal members on base classes are returned; private members on base classes are not returned.</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method with only the <ph id="ph1">`Public`</ph> flag or only the <ph id="ph2">`NonPublic`</ph> flag will return the specified members and does not require any other flags.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve">
          <source>Zero (<ph id="ph1">&lt;xref href="System.Reflection.BindingFlags.Default"&gt;&lt;/xref&gt;</ph>), to return an empty array.</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph> objects representing all members defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.MemberInfo"&gt;&lt;/xref&gt;</ph>, if no members are defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, or if none of the defined members match the binding constraints.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`GetXXX`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve">
          <source>The string containing the name of the method to get.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve">
          <source>An empty array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id="ph2">&lt;xref href="System.Type.EmptyTypes"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve">
          <source>The string containing the name of the method to get.</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve">
          <source>An empty array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id="ph2">&lt;xref href="System.Type.EmptyTypes"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve">
          <source>Searches for the specified public method whose parameters match the specified argument types and modifiers.</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance methods.</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, use <ph id="ph1">`GetMethod("MyMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public method to get.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve">
          <source>An empty array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id="ph2">&lt;xref href="System.Type.EmptyTypes"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve">
          <source>An object representing the public method that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve">
          <source>More than one method is found with the specified name and specified parameters.</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve">
          <source>Searches for the public method with the specified name.</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance methods.</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a method is overloaded and has more than one public method, the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, an exception is thrown because there is more than one public overload of the <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the other hand, because the <ph id="ph1">`Person.ToString`</ph> method overrides  <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> and therefore is not overloaded, the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method is able to retrieve the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.GetMethod#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.GetMethod#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do one of the following to retrieve a specific method:</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method and specify a <ph id="ph2">`bindingAttr`</ph> argument that uniquely identifies the method.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <ph id="ph1">`bindingAttr`</ph> argument  of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id="ph3">`Or`</ph><ph id="ph4">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> method to retrieve an array containing all of the public methods belonging to a type.</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public method to get.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve">
          <source>An object that represents the public method with the specified name, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve">
          <source>More than one method is found with the specified name.</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve">
          <source>Searches for the specified method, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include public methods in the search.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a method is overloaded and more than one overload meets the constraints specified by the <ph id="ph1">`bindingAttr`</ph> argument, the method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, an exception is thrown because:</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`DisplayValue`</ph> method, <ph id="ph3">`DisplayValue(String)`</ph> and <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`Equals`</ph> method,  one of which is inherited from <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> and <ph id="ph5">`Equals(Object)`</ph>.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.GetMethod#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.GetMethod#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do one of the following to retrieve a specific method:</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Change the binding constraints.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the previous example, attempting to retrieve a public instance <ph id="ph1">`Equals`</ph> method that is declared by the type and not inherited successfully retrieves <ph id="ph2">`Equals(TestClass)`</ph>.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT">
          <source>This approach is illustrated in the previous example's handler for the <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve">
          <source>The string containing the name of the method to get.</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve">
          <source>Searches for the specified public method whose parameters match the specified argument types.</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance methods.</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`name`</ph> parameter cannot include type arguments.</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> searches for a method with the text name "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyGenericMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, use <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public method to get.</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve">
          <source>An empty array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id="ph2">&lt;xref href="System.Type.EmptyTypes"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve">
          <source>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve">
          <source>More than one method is found with the specified name and specified parameters.</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`types`</ph> is <ph id="ph2">`null`</ph>, arguments are not matched.</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve">
          <source>The string containing the name of the method to get.</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, arguments are not matched.</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve">
          <source>The current type is a <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Reflection.Emit.GenericTypeParameterBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve">
          <source>Returns all the public methods of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructors are not included in the array of methods returned by this call.</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT">
          <source>Make a separate call to <ph id="ph1">`GetConstructors()`</ph> to get the constructor methods.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> objects representing all the public methods defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph>, if no public methods are defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the methods defined for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
        </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
        </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</source>
        </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
        </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can only omit parameters when invoking.</source>
        </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
        </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> objects representing all methods defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph>, if no methods are defined for the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, or if none of the defined methods match the binding constraints.</source>
        </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not qualify it with the name of the outer class.</source>
        </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</source>
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not include language-specific syntax for type parameters.</source>
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to get a return.</source>
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include public nested types in the search.</source>
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns only the nested types of the current type.</source>
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not search the base classes of the current type.</source>
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> at each level.</source>
        </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> are ignored.</source>
        </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
        </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
        </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
        </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
        </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve">
          <source>The string containing the name of the nested type to get.</source>
        </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve">
          <source>An object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve">
          <source>Searches for the public nested type with the specified name.</source>
        </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not qualify it with the name of the outer class.</source>
        </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</source>
        </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not include language-specific syntax for type parameters.</source>
        </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
        </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
        </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
        </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve">
          <source>The string containing the name of the nested type to get.</source>
        </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve">
          <source>An object representing the public nested type with the specified name, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the types nested in the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for nested types is not recursive.</source>
        </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
        </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to get a return.</source>
        </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include public nested types in the search.</source>
        </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
        </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns only the nested types of the current type.</source>
        </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not search the base classes of the current type.</source>
        </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> at each level.</source>
        </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> are ignored.</source>
        </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
        </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
        </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
        </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
        </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing all the types nested in the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints (the search is not recursive), or an empty array of type <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, if no nested types are found that match the binding constraints.</source>
        </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve">
          <source>Returns the public types nested in the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only the public types immediately nested in the current type are returned; the search is not recursive.</source>
        </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
        </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
        </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
        </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the public types nested in the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (the search is not recursive), or an empty array of type <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> if no public types are nested in the current <ph id="ph4">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve">
          <source>Returns all the public properties of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> overload with a <ph id="ph2">`bindingAttr`</ph> argument equal to <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# and  <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT">
          <source>It returns all public instance and static properties, both those defined by the type represented by the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as well as those inherited from its base types.</source>
        </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.PropertyInfo"&gt;&lt;/xref&gt;</ph> objects representing all public properties of the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.PropertyInfo"&gt;&lt;/xref&gt;</ph>, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> does not have public properties.</source>
        </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the properties of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
        </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
        </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
        </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
        </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
        </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</source>
        </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.PropertyInfo"&gt;&lt;/xref&gt;</ph> objects representing all properties of the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve">
          <source>An empty array of type <ph id="ph1">&lt;xref href="System.Reflection.PropertyInfo"&gt;&lt;/xref&gt;</ph>, if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> does not have properties, or if none of the properties match the binding constraints.</source>
        </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve">
          <source>Searches for the public property with the specified name.</source>
        </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance properties.</source>
        </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
        </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
        </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
        </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT">
          <source>A derived type declares a property that hides an inherited property with the same name, by using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT">
          <source>To resolve the ambiguity, use the <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method overload and add the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag to restrict the search to members that are not inherited.</source>
        </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexers and Default Properties</source>
        </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
        </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
        </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can overload the property.</source>
        </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
        </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
        </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
        </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
        </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
        </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public property to get.</source>
        </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name.</source>
        </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve">
          <source>Searches for the specified property, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
        </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
        </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
        </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
        </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
        </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
        </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT">
          <source>A derived type declares a property that hides an inherited property with the same name, using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT">
          <source>To resolve the ambiguity, include <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to restrict the search to members that are not inherited.</source>
        </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexers and Default Properties</source>
        </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
        </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
        </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can overload the property.</source>
        </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
        </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
        </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
        </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
        </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
        </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve">
          <source>The string containing the name of the property to get.</source>
        </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve">
          <source>Searches for the public property with the specified name and return type.</source>
        </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance properties.</source>
        </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexers and Default Properties</source>
        </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
        </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
        </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can overload the property.</source>
        </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
        </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
        </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
        </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
        </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
        </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public property to get.</source>
        </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name.</source>
        </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, or <ph id="ph3">&lt;code&gt;returnType&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
        </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance properties.</source>
        </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexers and Default Properties</source>
        </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
        </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
        </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can overload the property.</source>
        </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
        </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
        </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
        </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
        </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
        </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public property to get.</source>
        </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
        </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
        </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
        </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve">
          <source>An element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
        </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance properties.</source>
        </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexers and Default Properties</source>
        </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
        </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
        </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can overload the property.</source>
        </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
        </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
        </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
        </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
        </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
        </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public property to get.</source>
        </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
        </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
        </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
        </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve">
          <source>An element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve">
          <source>Searches for the specified public property whose parameters match the specified argument types and modifiers.</source>
        </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
        </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search includes public static and public instance properties.</source>
        </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexers and Default Properties</source>
        </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
        </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
        </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can overload the property.</source>
        </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
        </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
        </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
        </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
        </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
        </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve">
          <source>The string containing the name of the public property to get.</source>
        </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
        </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
        </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve">
          <source>An object representing the public property that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name and matching the specified argument types and modifiers.</source>
        </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve">
          <source>An element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve">
          <source>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
        </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
        </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
        </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
        </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
        </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
        </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
        </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexers and Default Properties</source>
        </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
        </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
        </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can overload the property.</source>
        </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
        </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
        </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
        </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
        </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
        </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve">
          <source>The string containing the name of the property to get.</source>
        </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
        </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
        </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve">
          <source>An element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
        </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
        </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
        </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
        </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
        </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
        </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve">
          <source>The string containing the name of the property to get.</source>
        </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve">
          <source>Zero, to return <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve">
          <source>The return type of the property.</source>
        </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
        </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve">
          <source>An empty array of the type <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
        </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">types</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve">
          <source>The default binder does not process this parameter.</source>
        </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
        </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve">
          <source>One of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">types</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve">
          <source>The current type is a <ph id="ph1">&lt;xref href="System.Reflection.Emit.TypeBuilder"&gt;&lt;/xref&gt;</ph>, <ph id="ph2">&lt;xref href="System.Reflection.Emit.EnumBuilder"&gt;&lt;/xref&gt;</ph>, or <ph id="ph3">&lt;xref href="System.Reflection.Emit.GenericTypeParameterBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve">
          <source>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
        </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method overload and its associated overloads (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) to replace the default implementation of the <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> method with more flexible implementations.</source>
        </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT">
          <source>By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</source>
        </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Control which version of an assembly a type is loaded from.</source>
        </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Provide another place to look for a type name that does not include an assembly name.</source>
        </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Load assemblies using partial assembly names.</source>
        </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=fullName&gt;</ph> that are not created by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</source>
        </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Other overloads of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method require an assembly-qualified type name, which includes the version number.</source>
        </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternate implementations of the type system may need to return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=fullName&gt;</ph> that are not created by the CLR; all types that are returned by other overloads of the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method are runtime types.</source>
        </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Usage Notes</source>
        </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload and its associated overloads parse <ph id="ph1">`typeName`</ph> into the name of a type and the name of an assembly, and then resolve the names.</source>
        </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</source>
        </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are unfamiliar with the concept of assembly-qualified type names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> is not an assembly-qualified name, assembly resolution is skipped.</source>
        </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <ph id="ph1">`typeResolver`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section.</source>
        </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT">
          <source>General usage notes:</source>
        </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not pass methods to <ph id="ph1">`assemblyResolver`</ph> or <ph id="ph2">`typeResolver`</ph> if they come from unknown or untrusted callers.</source>
        </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use only methods that you provide or that you are familiar with.</source>
        </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</source>
        </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you omit the <ph id="ph1">`assemblyResolver`</ph> and/or <ph id="ph2">`typeResolver`</ph> parameters, the value of the <ph id="ph3">`throwOnError`</ph> parameter is passed to the methods that perform the default resolution.</source>
        </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`throwOnError`</ph> is <ph id="ph2">`true`</ph>, this method throws a <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> when <ph id="ph4">`typeResolver`</ph> returns <ph id="ph5">`null`</ph>, and a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> when <ph id="ph7">`assemblyResolver`</ph> returns <ph id="ph8">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not catch exceptions thrown by <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph>.</source>
        </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT">
          <source>You are responsible for any exceptions that are thrown by the resolver methods.</source>
        </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Resolving Assemblies</source>
        </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method receives an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, which is produced by parsing the string assembly name that is included in <ph id="ph3">`typeName`</ph>.</source>
        </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> does not contain an assembly name, <ph id="ph2">`assemblyResolver`</ph> is not called and <ph id="ph3">`null`</ph> is passed to <ph id="ph4">`typeResolver`</ph>.</source>
        </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is not supplied, standard assembly probing is used to locate the assembly.</source>
        </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method does not do standard probing; in that case you must ensure that your <ph id="ph3">`assemblyResolver`</ph> can handle all the assemblies you pass to it.</source>
        </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method should return <ph id="ph2">`null`</ph> if the assembly cannot be resolved.</source>
        </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`assemblyResolver`</ph> returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called and no further processing occurs; additionally, if <ph id="ph4">`throwOnError`</ph> is <ph id="ph5">`true`</ph>, a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> that is passed to <ph id="ph2">`assemblyResolver`</ph> is a partial name, one or more of its parts are <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if it has no version, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> property, and the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> method all return <ph id="ph4">`null`</ph>, then only the simple name of the assembly was supplied.</source>
        </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method can use or ignore all parts of the assembly name.</source>
        </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effects of different assembly resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
        </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Resolving Types</source>
        </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> does not specify an assembly name, <ph id="ph2">`typeResolver`</ph> is always called.</source>
        </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> specifies an assembly name, <ph id="ph2">`typeResolver`</ph> is called only when the assembly name is successfully resolved.</source>
        </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`assemblyResolver`</ph> or standard assembly probing returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called.</source>
        </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`typeResolver`</ph> method receives three arguments:</source>
        </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly to search or <ph id="ph1">`null`</ph> if <ph id="ph2">`typeName`</ph> does not contain an assembly name.</source>
        </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The simple name of the type.</source>
        </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the case of a nested type, this is the outermost containing type.</source>
        </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the case of a generic type, this is the simple name of the generic type.</source>
        </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT">
          <source>A Boolean value that is <ph id="ph1">`true`</ph> if the case of type names is to be ignored.</source>
        </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT">
          <source>The implementation determines the way these arguments are used.</source>
        </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`typeResolver`</ph> method should return <ph id="ph2">`null`</ph> if it cannot resolve the type.</source>
        </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeResolver`</ph> returns <ph id="ph2">`null`</ph> and <ph id="ph3">`throwOnError`</ph> is <ph id="ph4">`true`</ph>, this overload of <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effects of different type resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
        </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Resolving Nested Types</source>
        </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> is a nested type, only the name of the outermost containing type is passed to <ph id="ph2">`typeResolver`</ph>.</source>
        </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">`typeResolver`</ph> returns this type, the <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> method is called recursively until the innermost nested type has been resolved.</source>
        </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Resolving Generic Types</source>
        </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</source>
        </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type argument is generic, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve its type arguments, and so on.</source>
        </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combination of <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> that you provide must be capable of resolving all levels of this recursion.</source>
        </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose you supply an <ph id="ph1">`assemblyResolver`</ph> that controls the loading of <ph id="ph2">`MyAssembly`</ph>.</source>
        </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Suppose you want to resolve the generic type <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT">
          <source>You might pass the following generic type name:</source>
        </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notice that <ph id="ph1">`MyType`</ph> is the only assembly-qualified type argument.</source>
        </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The names of the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph2">&lt;xref:System.String&gt;</ph> classes are not assembly-qualified.</source>
        </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your <ph id="ph1">`typeResolver`</ph> must be able handle either an assembly or <ph id="ph2">`null`</ph>, because it will receive <ph id="ph3">`null`</ph> for <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can handle that case by calling an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</source>
        </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GetTypeOnSteroids#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</source>
        </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Now suppose that instead of <ph id="ph1">`System.String`</ph>, the first generic argument type is <ph id="ph2">`YourType`</ph>, from <ph id="ph3">`YourAssembly`</ph>:</source>
        </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <ph id="ph1">`YourType`</ph> without an assembly-qualified name.</source>
        </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because your <ph id="ph1">`assemblyResolve`</ph> will be called recursively, it must be able to handle this case.</source>
        </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead of returning <ph id="ph1">`null`</ph> for assemblies other than <ph id="ph2">`MyAssembly`</ph>, it now performs an assembly load using the supplied <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>GetTypeOnSteroids#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
        </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Resolving Type Names with Special Characters</source>
        </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Certain characters have special meanings in assembly-qualified names.</source>
        </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</source>
        </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if a type is named <ph id="ph1">`Strange]Type`</ph>, the escape character must be added ahead of the square bracket as follows: <ph id="ph2">`Strange\]Type`</ph>.</source>
        </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</source>
        </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows the special characters for type names.</source>
        </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT">
          <source>Character</source>
        </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT">
          <source>, (comma)</source>
        </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter for assembly-qualified names.</source>
        </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT">
          <source>[] (square brackets)</source>
        </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</source>
        </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT">
          <source>&amp; (ampersand)</source>
        </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a suffix, indicates that a type is a reference type.</source>
        </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT">
          <source>* (asterisk)</source>
        </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a suffix, indicates that a type is a pointer type.</source>
        </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT">
          <source>+ (plus)</source>
        </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter for nested types.</source>
        </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT">
          <source>\ (backslash)</source>
        </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Escape character.</source>
        </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Properties such as <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> return correctly escaped strings.</source>
        </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must pass correctly escaped strings to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT">
          <source>In turn, the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method passes correctly escaped names to <ph id="ph2">`typeResolver`</ph> and to the default type resolution methods.</source>
        </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to compare a name to an unescaped name in <ph id="ph1">`typeResolver`</ph>, you must remove the escape characters.</source>
        </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
        </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mixed Name Resolution</source>
        </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table summarizes the interactions between <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>, and default name resolution, for all combinations of type name and assembly name in <ph id="ph3">`typeName`</ph>:</source>
        </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contents of type name</source>
        </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Assembly resolver method</source>
        </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type resolver method</source>
        </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Result</source>
        </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT">
          <source>type, assembly</source>
        </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT">
          <source>null</source>
        </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT">
          <source>null</source>
        </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT">
          <source>type, assembly</source>
        </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT">
          <source>provided</source>
        </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT">
          <source>null</source>
        </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
        </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is resolved, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</source>
        </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT">
          <source>type, assembly</source>
        </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT">
          <source>null</source>
        </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT">
          <source>provided</source>
        </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Equivalent to converting the assembly name to an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=fullName&gt;</ph> method overload to get the assembly.</source>
        </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
        </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT">
          <source>type, assembly</source>
        </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT">
          <source>provided</source>
        </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT">
          <source>provided</source>
        </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
        </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
        </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT">
          <source>type</source>
        </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT">
          <source>null, provided</source>
        </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT">
          <source>null</source>
        </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</source>
        </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
        </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT">
          <source>type</source>
        </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT">
          <source>null, provided</source>
        </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT">
          <source>provided</source>
        </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`typeResolver`</ph> is called, and <ph id="ph2">`null`</ph> is passed for the assembly.</source>
        </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`typeResolver`</ph> can provide a type from any assembly, including assemblies it loads for the purpose.</source>
        </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
        </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT">
          <source>assembly</source>
        </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT">
          <source>null, provided</source>
        </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT">
          <source>null, provided</source>
        </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</source>
        </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT">
          <source>This results in an invalid assembly name.</source>
        </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Back to: <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>Resolving Assemblies<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>Resolving Types<ept id="p3">](#resolving_types)</ept>.</source>
        </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve">
          <source>The name of the type to get.</source>
        </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeResolver</ph><ept id="p1">&lt;/code&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">typeResolver</ph><ept id="p2">&lt;/code&gt;</ept> is capable of resolving.</source>
        </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">typeName</ph><ept id="p2">&lt;/code&gt;</ept> must be an assembly-qualified name (see <ph id="ph3">&lt;xref href="System.Type.AssemblyQualifiedName"&gt;&lt;/xref&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
        </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve">
          <source>The assembly name is passed to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> as an <ph id="ph2">&lt;xref href="System.Reflection.AssemblyName"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">assemblyResolver</ph><ept id="p2">&lt;/code&gt;</ept> is not called.</source>
        </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
        </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
        </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
        </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve">
          <source>Use only methods that you provide or that you are familiar with.</source>
        </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">assemblyResolver</ph><ept id="p2">&lt;/code&gt;</ept> or by standard assembly resolution.</source>
        </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve">
          <source>If no assembly is provided, the method can provide one.</source>
        </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">ignoreCase</ph><ept id="p1">&lt;/code&gt;</ept> is passed to that parameter.</source>
        </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
        </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if the type cannot be found; <ph id="ph2">`false`</ph> to return <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve">
          <source>Specifying <ph id="ph1">`false`</ph> also suppresses some other exception conditions, but not all of them.</source>
        </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to perform a case-insensitive search for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeName</ph><ept id="p1">&lt;/code&gt;</ept>, <ph id="ph3">`false`</ph> to perform a case-sensitive search for <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">typeName</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve">
          <source>The type with the specified name.</source>
        </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve">
          <source>If the type is not found, the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept> parameter specifies whether <ph id="ph2">`null`</ph> is returned or an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve">
          <source>In some cases, an exception is thrown regardless of the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the type is not found.</source>
        </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.</source>
        </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.</source>
        </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id="ph2">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve">
          <source>An error occurs when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
        </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
        </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">`ByRef`</ph> type, or <ph id="ph3">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
        </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
        </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the assembly or one of its dependencies was not found.</source>
        </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
        </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> contains an invalid assembly name.</source>
        </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is a valid assembly name without a type name.</source>
        </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies is not valid.</source>
        </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
        </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve">
          <source>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
        </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`ignoreCase`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve">
          <source>The name of the type to get.</source>
        </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeResolver</ph><ept id="p1">&lt;/code&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">typeResolver</ph><ept id="p2">&lt;/code&gt;</ept> is capable of resolving.</source>
        </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">typeName</ph><ept id="p2">&lt;/code&gt;</ept> must be an assembly-qualified name (see <ph id="ph3">&lt;xref href="System.Type.AssemblyQualifiedName"&gt;&lt;/xref&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
        </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve">
          <source>The assembly name is passed to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> as an <ph id="ph2">&lt;xref href="System.Reflection.AssemblyName"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">assemblyResolver</ph><ept id="p2">&lt;/code&gt;</ept> is not called.</source>
        </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
        </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
        </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
        </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve">
          <source>Use only methods that you provide or that you are familiar with.</source>
        </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">assemblyResolver</ph><ept id="p2">&lt;/code&gt;</ept> or by standard assembly resolution.</source>
        </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve">
          <source>If no assembly is provided, the method can provide one.</source>
        </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">`false`</ph> is passed to that parameter.</source>
        </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
        </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if the type cannot be found; <ph id="ph2">`false`</ph> to return <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve">
          <source>Specifying <ph id="ph1">`false`</ph> also suppresses some other exception conditions, but not all of them.</source>
        </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve">
          <source>The type with the specified name.</source>
        </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve">
          <source>If the type is not found, the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept> parameter specifies whether <ph id="ph2">`null`</ph> is returned or an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve">
          <source>In some cases, an exception is thrown regardless of the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the type is not found.</source>
        </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.</source>
        </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.</source>
        </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id="ph2">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve">
          <source>An error occurs when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
        </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
        </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">`ByRef`</ph> type, or <ph id="ph3">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
        </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
        </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the assembly or one of its dependencies was not found.</source>
        </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> contains an invalid assembly name.</source>
        </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is a valid assembly name without a type name.</source>
        </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
        </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies is not valid.</source>
        </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
        </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve">
          <source>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</source>
        </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not throw an exception.</source>
        </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`throwOnError`</ph> and <ph id="ph4">`ignoreCase`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve">
          <source>The name of the type to get.</source>
        </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeResolver</ph><ept id="p1">&lt;/code&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">typeResolver</ph><ept id="p2">&lt;/code&gt;</ept> is capable of resolving.</source>
        </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">typeName</ph><ept id="p2">&lt;/code&gt;</ept> must be an assembly-qualified name (see <ph id="ph3">&lt;xref href="System.Type.AssemblyQualifiedName"&gt;&lt;/xref&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
        </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve">
          <source>The assembly name is passed to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> as an <ph id="ph2">&lt;xref href="System.Reflection.AssemblyName"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">assemblyResolver</ph><ept id="p2">&lt;/code&gt;</ept> is not called.</source>
        </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">assemblyResolver</ph><ept id="p1">&lt;/code&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
        </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
        </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
        </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve">
          <source>Use only methods that you provide or that you are familiar with.</source>
        </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">assemblyResolver</ph><ept id="p2">&lt;/code&gt;</ept> or by standard assembly resolution.</source>
        </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve">
          <source>If no assembly is provided, the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeResolver</ph><ept id="p1">&lt;/code&gt;</ept> method can provide one.</source>
        </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">`false`</ph> is passed to that parameter.</source>
        </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
        </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve">
          <source>The type with the specified name, or <ph id="ph1">`null`</ph> if the type is not found.</source>
        </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve">
          <source>An error occurs when <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeName</ph><ept id="p1">&lt;/code&gt;</ept> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
        </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">`ByRef`</ph> type, or <ph id="ph3">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
        </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
        </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id="ph2">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
        </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> contains an invalid assembly name.</source>
        </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is a valid assembly name without a type name.</source>
        </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies is not valid.</source>
        </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
        </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve">
          <source>Gets the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</source>
        </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
        </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
        </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
        </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
        </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
        </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
        </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=fullName&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
        </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
        </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
        </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
        </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
        </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
        </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
        </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
        </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</source>
        </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
        </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
        </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, "ProcessorArchitecture=msil".</source>
        </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
        </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method to load types from the assembly.</source>
        </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter</source>
        </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
        </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT">
          <source>Escape character.</source>
        </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT">
          <source>Backtick (`)</source>
        </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
        </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT">
          <source>Brackets ([])</source>
        </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
        </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comma (,)</source>
        </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes the Assembly name.</source>
        </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT">
          <source>Period (.)</source>
        </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Denotes namespace identifiers.</source>
        </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT">
          <source>Plus sign (+)</source>
        </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes a nested class.</source>
        </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the fully qualified name for a class might look like this:</source>
        </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
        </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection emits this string as follows:</source>
        </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
        </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
        </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
        </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
        </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
        </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
        </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
        </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
        </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
        </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
        </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
        </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
        </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
        </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
        </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
        </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
        </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
        </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
        </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nullable types are a special case of generic types.</source>
        </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
        </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
        </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
        </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT">
          <source>To Get</source>
        </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use</source>
        </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
        </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
        </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
        </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that unlike pointers, references are limited to one level.</source>
        </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT">
          <source>A parent class and a nested class</source>
        </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT">
          <source>A one-dimensional array with a lower bound of 0</source>
        </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT">
          <source>A one-dimensional array with an unknown lower bound</source>
        </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT">
          <source>An n-dimensional array</source>
        </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
        </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
        </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT">
          <source>A two-dimensional array's array</source>
        </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
        </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with one type argument</source>
        </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
        </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with two type arguments</source>
        </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
        </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with two assembly-qualified type arguments</source>
        </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
        </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
        </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
        </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
        </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
        </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve">
          <source>The assembly-qualified name of the type to get.</source>
        </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve">
          <source>See <ph id="ph1">&lt;xref href="System.Type.AssemblyQualifiedName"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
        </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if the type cannot be found; <ph id="ph2">`false`</ph> to return <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve">
          <source>Specifying <ph id="ph1">`false`</ph> also suppresses some other exception conditions, but not all of them.</source>
        </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve">
          <source>The type with the specified name.</source>
        </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve">
          <source>If the type is not found, the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept> parameter specifies whether <ph id="ph2">`null`</ph> is returned or an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve">
          <source>In some cases, an exception is thrown regardless of the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the type is not found.</source>
        </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.</source>
        </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.</source>
        </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id="ph2">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax.</source>
        </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve">
          <source>For example, "MyType[,*,]".</source>
        </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">`ByRef`</ph> type, or <ph id="ph3">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
        </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
        </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the assembly or one of its dependencies was not found.</source>
        </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;xref href="System.IO.IOException"&gt;&lt;/xref&gt;</ph>, instead.</source>
        </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
        </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies is not valid.</source>
        </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
        </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified name, performing a case-sensitive search.</source>
        </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if you know its namespace-qualified name.</source>
        </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
        </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or  in C++.</source>
        </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not throw an exception.</source>
        </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>GetType only works on assemblies loaded from disk.</source>
        </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
        </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
        </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=fullName&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
        </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
        </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
        </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
        </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
        </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
        </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
        </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</source>
        </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
        </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
        </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, "ProcessorArchitecture=msil".</source>
        </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
        </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method to load types from the assembly.</source>
        </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter</source>
        </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
        </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT">
          <source>Escape character.</source>
        </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT">
          <source>Backtick (`)</source>
        </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
        </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT">
          <source>Brackets ([])</source>
        </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
        </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comma (,)</source>
        </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes the Assembly name.</source>
        </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT">
          <source>Period (.)</source>
        </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT">
          <source>Denotes namespace identifiers.</source>
        </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT">
          <source>Plus sign (+)</source>
        </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes a nested class.</source>
        </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the fully qualified name for a class might look like this:</source>
        </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
        </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection emits this string as follows:</source>
        </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
        </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
        </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
        </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
        </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
        </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
        </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
        </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
        </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
        </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
        </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
        </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
        </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
        </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
        </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
        </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
        </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
        </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
        </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nullable types are a special case of generic types.</source>
        </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
        </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
        </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
        </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT">
          <source>To Get</source>
        </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use</source>
        </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
        </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
        </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
        </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that unlike pointers, references are limited to one level.</source>
        </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT">
          <source>A parent class and a nested class</source>
        </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT">
          <source>A one-dimensional array with a lower bound of 0</source>
        </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT">
          <source>A one-dimensional array with an unknown lower bound</source>
        </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT">
          <source>An n-dimensional array</source>
        </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
        </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
        </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT">
          <source>An array of one-dimensional arrays</source>
        </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
        </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with one type argument</source>
        </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
        </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with two type arguments</source>
        </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
        </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with two assembly-qualified type arguments</source>
        </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
        </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
        </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
        </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
        </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
        </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve">
          <source>The assembly-qualified name of the type to get.</source>
        </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve">
          <source>See <ph id="ph1">&lt;xref href="System.Type.AssemblyQualifiedName"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
        </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">`ByRef`</ph> type, or <ph id="ph3">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
        </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
        </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id="ph2">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;xref href="System.IO.IOException"&gt;&lt;/xref&gt;</ph>, instead.</source>
        </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
        </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies is not valid.</source>
        </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
        </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</source>
        </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
        </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
        </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
        </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
        </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
        </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
        </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=fullName&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
        </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
        </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
        </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
        </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Member Type</source>
        </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT">
          <source>Static</source>
        </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-Static</source>
        </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT">
          <source>Field</source>
        </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT">
          <source>A field is always hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT">
          <source>Event</source>
        </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT">
          <source>Method</source>
        </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes.</source>
        </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Type</source>
        </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property</source>
        </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not applicable</source>
        </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
        </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT">
          <source>See note 2 below.</source>
        </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
        </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a binary comparison.</source>
        </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
        </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
        </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT">
          <source>Custom attributes are not part of the common type system.</source>
        </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
        </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
        </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
        </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
        </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
        </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</source>
        </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
        </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
        </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, "ProcessorArchitecture=msil".</source>
        </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
        </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method to load types from the assembly.</source>
        </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delimiter</source>
        </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Meaning</source>
        </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
        </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT">
          <source>Escape character.</source>
        </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT">
          <source>Backtick (`)</source>
        </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
        </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT">
          <source>Brackets ([])</source>
        </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
        </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comma (,)</source>
        </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes the Assembly name.</source>
        </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT">
          <source>Period (.)</source>
        </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT">
          <source>Denotes namespace identifiers.</source>
        </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT">
          <source>Plus sign (+)</source>
        </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precedes a nested class.</source>
        </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the fully qualified name for a class might look like this:</source>
        </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
        </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection emits this string as follows:</source>
        </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
        </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
        </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
        </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
        </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
        </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
        </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
        </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
        </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
        </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
        </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
        </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
        </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
        </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
        </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
        </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
        </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
        </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
        </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nullable types are a special case of generic types.</source>
        </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
        </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
        </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
        </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT">
          <source>To Get</source>
        </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use</source>
        </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
        </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
        </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
        </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
        </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that unlike pointers, references are limited to one level.</source>
        </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT">
          <source>A parent class and a nested class</source>
        </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT">
          <source>A one-dimensional array with a lower bound of 0</source>
        </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT">
          <source>A one-dimensional array with an unknown lower bound</source>
        </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT">
          <source>An n-dimensional array</source>
        </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
        </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
        </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT">
          <source>A two-dimensional array's array</source>
        </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
        </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with one type argument</source>
        </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
        </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with two type arguments</source>
        </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
        </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type with two assembly-qualified type arguments</source>
        </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
        </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
        </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
        </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
        </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
        </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve">
          <source>The assembly-qualified name of the type to get.</source>
        </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve">
          <source>See <ph id="ph1">&lt;xref href="System.Type.AssemblyQualifiedName"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
        </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw an exception if the type cannot be found; <ph id="ph2">`false`</ph> to return <ph id="ph3">`null`</ph>.Specifying <ph id="ph4">`false`</ph> also suppresses some other exception conditions, but not all of them.</source>
        </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to perform a case-insensitive search for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeName</ph><ept id="p1">&lt;/code&gt;</ept>, <ph id="ph3">`false`</ph> to perform a case-sensitive search for <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">typeName</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve">
          <source>The type with the specified name.</source>
        </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve">
          <source>If the type is not found, the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept> parameter specifies whether <ph id="ph2">`null`</ph> is returned or an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve">
          <source>In some cases, an exception is thrown regardless of the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwOnError</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the type is not found.</source>
        </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.</source>
        </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.</source>
        </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id="ph2">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax.</source>
        </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve">
          <source>For example, "MyType[,*,]".</source>
        </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">`ByRef`</ph> type, or <ph id="ph3">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
        </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
        </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the assembly or one of its dependencies was not found.</source>
        </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
        </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies is not valid.</source>
        </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
        </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve">
          <source>Gets the types of the objects in the specified array.</source>
        </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve">
          <source>An array of objects whose types to determine.</source>
        </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects representing the types of the corresponding elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">args</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;args&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve">
          <source>One or more of the elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve">
          <source>The class initializers are invoked and at least one throws an exception.</source>
        </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve">
          <source>Gets the underlying type code of the specified <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can change the behavior of this method by overriding the <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve">
          <source>The type whose underlying type code to get.</source>
        </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve">
          <source>The code of the underlying type, or <ph id="ph1">&lt;xref href="System.TypeCode.Empty"&gt;&lt;/xref&gt;</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">type</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve">
          <source>Returns the underlying type code of this <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides the implementation for the <ph id="ph1">`static`</ph> (in C#) or <ph id="ph2">`Shared`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can override this method to provide your own implementation of <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve">
          <source>The type code of the underlying type.</source>
        </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
        </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
        </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
        </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
        </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
        </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
        </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.</source>
        </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
        </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve">
          <source>The CLSID of the type to get.</source>
        </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve">
          <source>The server from which to load the type.</source>
        </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve">
          <source>If the server name is <ph id="ph1">`null`</ph>, this method automatically reverts to the local machine.</source>
        </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> to ignore any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.__ComObject`</ph> regardless of whether the CLSID is valid.</source>
        </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server.</source>
        </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
        </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
        </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
        </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
        </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
        </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.</source>
        </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve">
          <source>The CLSID of the type to get.</source>
        </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve">
          <source>The server from which to load the type.</source>
        </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve">
          <source>If the server name is <ph id="ph1">`null`</ph>, this method automatically reverts to the local machine.</source>
        </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.__ComObject`</ph> regardless of whether the CLSID is valid.</source>
        </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</source>
        </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
        </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
        </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
        </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
        </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
        </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.</source>
        </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the example for an illustration.</source>
        </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
        </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve">
          <source>The CLSID of the type to get.</source>
        </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> to ignore any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.__ComObject`</ph> regardless of whether the CLSID is valid.</source>
        </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
        </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
        </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
        </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
        </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
        </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
        </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the<ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.</source>
        </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the example for an illustration.</source>
        </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> overload ignores any exception that may occur when instantiating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object based on the <ph id="ph3">`clsid`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that no exception is thrown if <ph id="ph1">`clsid`</ph> is not found in the registry.</source>
        </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve">
          <source>The CLSID of the type to get.</source>
        </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.__ComObject`</ph> regardless of whether the CLSID is valid.</source>
        </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve">
          <source>Gets the type referenced by the specified type handle.</source>
        </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
        </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve">
          <source>The object that refers to the type.</source>
        </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve">
          <source>The type referenced by the specified <ph id="ph1">&lt;xref href="System.RuntimeTypeHandle"&gt;&lt;/xref&gt;</ph>, or <ph id="ph2">`null`</ph> if the <ph id="ph3">&lt;xref href="System.RuntimeTypeHandle.Value"&gt;&lt;/xref&gt;</ph> property of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph4">handle</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is provided for COM support.</source>
        </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT">
          <source>ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
        </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve">
          <source>The ProgID of the type to get.</source>
        </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve">
          <source>The type associated with the specified ProgID, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">progID</ph><ept id="p1">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;progID&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</source>
        </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is provided for COM support.</source>
        </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
        </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve">
          <source>The ProgID of the type to get.</source>
        </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> to ignore any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve">
          <source>The type associated with the specified program identifier (ProgID), if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">progID</ph><ept id="p1">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;progID&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve">
          <source>The specified ProgID is not registered.</source>
        </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</source>
        </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is provided for COM support.</source>
        </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
        </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve">
          <source>The progID of the type to get.</source>
        </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve">
          <source>The server from which to load the type.</source>
        </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve">
          <source>If the server name is <ph id="ph1">`null`</ph>, this method automatically reverts to the local machine.</source>
        </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve">
          <source>The type associated with the specified program identifier (progID), if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">progID</ph><ept id="p1">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;prodID&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
        </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is provided for COM support.</source>
        </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
        </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve">
          <source>The progID of the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> to get.</source>
        </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve">
          <source>The server from which to load the type.</source>
        </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve">
          <source>If the server name is <ph id="ph1">`null`</ph>, this method automatically reverts to the local machine.</source>
        </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> to ignore any exception that occurs.</source>
        </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve">
          <source>The type associated with the specified program identifier (progID), if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">progID</ph><ept id="p1">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;progID&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve">
          <source>The specified progID is not registered.</source>
        </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve">
          <source>Gets the handle for the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of a specified object.</source>
        </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
        </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve">
          <source>The object for which to get the type handle.</source>
        </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve">
          <source>The handle for the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the specified <ph id="ph2">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;o&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve">
          <source>Gets the GUID associated with the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT">
          <source>A GUID is associated with a type using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve">
          <source>The GUID associated with the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference.</source>
        </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, Type.GetType("Int32[]").HasElementType returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementType returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT">
          <source>HasElementType also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
        </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;xref href="System.Type.HasElementType"&gt;&lt;/xref&gt;</ph> property and determines whether the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference.</source>
        </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, Type.GetType("Int32[]").HasElementTypeImpl returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementTypeImpl returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT">
          <source>HasElementTypeImpl also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
        </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</source>
        </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`InvokeMember`</ph> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</source>
        </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
        </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
        </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
        </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
        </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
        </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph3">`modifiers`</ph> and <ph id="ph4">`culture`</ph> parameters), you can use the abstract <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph6">`modifiers`</ph> and <ph id="ph7">`culture`</ph>.</source>
        </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
        </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each parameter in the <ph id="ph1">`namedParameters`</ph> array gets the value in the corresponding element in the <ph id="ph2">`args`</ph> array.</source>
        </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the length of <ph id="ph1">`args`</ph> is greater than the length of <ph id="ph2">`namedParameters`</ph>, the remaining argument values are passed in order.</source>
        </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`namedParameters`</ph> array can be used to change the order of arguments in an input array.</source>
        </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, given the method <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) and the input array <ph id="ph3">`{ 42, "x" }`</ph>, the input array can be passed unchanged to <ph id="ph4">`args`</ph> if the array <ph id="ph5">`{ "b", "a" }`</ph> is supplied for <ph id="ph6">`namedParameters`</ph>.</source>
        </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
        </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
        </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
        </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
        </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
        </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
        </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
        </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with other invocation flags.</source>
        </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
        </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
        </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
        </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
        </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
        </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
        </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method will be invoked if both of the following conditions are true:</source>
        </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
        </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
        </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT">
          <source>The binder will find all of the matching methods.</source>
        </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
        </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
        </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the method is selected, it is invoked.</source>
        </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accessibility is checked at that point.</source>
        </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
        </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
        </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default binder selects the most specific match.</source>
        </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`InvokeMember`</ph> can be used to invoke methods with parameters that have default values.</source>
        </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT">
          <source>To bind to these methods, Reflection requires <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to be specified.</source>
        </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a parameter that has a default value, you can either supply a different value, or supply <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=fullName&gt;</ph> to use the default value.</source>
        </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a method such as MyMethod(int x, float y = 2.0).</source>
        </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT">
          <source>To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <ph id="ph1">`Missing.Value`</ph> for the second argument.</source>
        </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unless you use <ph id="ph1">`Missing.Value`</ph>, you may not omit optional parameters with the <ph id="ph2">`Invoke`</ph> method.</source>
        </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you must do so, use <ph id="ph1">`InvokeMember`</ph> instead.</source>
        </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
        </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
        </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
        </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT">
          <source>which will initialize the field F to this new array.</source>
        </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
        </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will change string "z" in the array that F holds to string "b".</source>
        </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
        </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve">
          <source>An empty string ("") to invoke the default member.</source>
        </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`IDispatch`</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
        </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve">
          <source>The access can be one of the <ph id="ph1">`BindingFlags`</ph> such as <ph id="ph2">`Public`</ph>, <ph id="ph3">`NonPublic`</ph>, <ph id="ph4">`Private`</ph>, <ph id="ph5">`InvokeMethod`</ph>, <ph id="ph6">`GetField`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve">
          <source>The type of lookup need not be specified.</source>
        </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve">
          <source>If the type of lookup is omitted, <ph id="ph1">`BindingFlags.Public`</ph><ph id="ph2"> | </ph><ph id="ph3">`BindingFlags.Instance`</ph><ph id="ph4"> | </ph><ph id="ph5">`BindingFlags.Static`</ph> are used.</source>
        </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve">
          <source>A null reference (Nothing in Visual Basic), to use the <ph id="ph1">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve">
          <source>Note that explicitly defining a <ph id="ph1">&lt;xref href="System.Reflection.Binder"&gt;&lt;/xref&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
        </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve">
          <source>The object on which to invoke the specified member.</source>
        </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve">
          <source>An array containing the arguments to pass to the member to invoke.</source>
        </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Reflection.ParameterModifier"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">args</ph><ept id="p1">&lt;/code&gt;</ept> array.</source>
        </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve">
          <source>A parameter's associated attributes are stored in the member's signature.</source>
        </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve">
          <source>The default binder processes this parameter only when calling a COM component.</source>
        </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Globalization.CultureInfo"&gt;&lt;/xref&gt;</ph> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</source>
        </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;xref href="System.Globalization.CultureInfo"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve">
          <source>An array containing the names of the parameters to which the values in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept> array are passed.</source>
        </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve">
          <source>An object representing the return value of the invoked member.</source>
        </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain <ph id="ph2">`CreateInstance`</ph> and <ph id="ph3">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;args&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.</source>
        </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`CreateInstance`</ph>, <ph id="ph4">`GetField`</ph>, <ph id="ph5">`SetField`</ph>, <ph id="ph6">`GetProperty`</ph>, or <ph id="ph7">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`CreateInstance`</ph> combined with <ph id="ph3">`InvokeMethod`</ph>, <ph id="ph4">`GetField`</ph>, <ph id="ph5">`SetField`</ph>, <ph id="ph6">`GetProperty`</ph>, or <ph id="ph7">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id="ph2">`GetField`</ph> and <ph id="ph3">`SetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id="ph2">`GetProperty`</ph> and <ph id="ph3">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`InvokeMethod`</ph> combined with <ph id="ph3">`SetField`</ph> or <ph id="ph4">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`SetField`</ph> and <ph id="ph3">&lt;code&gt;args&lt;/code&gt;</ph> has more than one element.</source>
        </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve">
          <source>The named parameter array is larger than the argument array.</source>
        </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">`BindingFlags.InvokeMethod`</ph>, <ph id="ph2">`BindingFlags.GetProperty`</ph>, <ph id="ph3">`BindingFlags.SetProperty`</ph>, <ph id="ph4">`BindingFlags.PutDispProperty`</ph>, or <ph id="ph5">`BindingFlags.PutRefDispProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve">
          <source>The specified member is a class initializer.</source>
        </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve">
          <source>The field or property cannot be found.</source>
        </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve">
          <source>No method can be found that matches the arguments in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve">
          <source>No member can be found that has the argument names supplied in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">namedParameters</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve">
          <source>The specified member cannot be invoked on <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve">
          <source>More than one method matches the binding criteria.</source>
        </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve">
          <source>The method represented by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> has one or more unspecified generic type parameters.</source>
        </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve">
          <source>That is, the method's <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</source>
        </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
        </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
        </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
        </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private and protected members) in the search.</source>
        </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
        </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
        </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
        </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
        </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with other invocation flags.</source>
        </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
        </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
        </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
        </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
        </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
        </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
        </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method will be invoked if both of the following conditions are true:</source>
        </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
        </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
        </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT">
          <source>The binder will find all of the matching methods.</source>
        </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
        </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
        </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the method is selected, it is invoked.</source>
        </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accessibility is checked at that point.</source>
        </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
        </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
        </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default binder selects the most specific match.</source>
        </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
        </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
        </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
        </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT">
          <source>which will initialize the field F to this new array.</source>
        </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
        </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will change string "z" in the array that F holds to string "b".</source>
        </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
        </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
        </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
        </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
        </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
        </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve">
          <source>An empty string ("") to invoke the default member.</source>
        </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`IDispatch`</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
        </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve">
          <source>The access can be one of the <ph id="ph1">`BindingFlags`</ph> such as <ph id="ph2">`Public`</ph>, <ph id="ph3">`NonPublic`</ph>, <ph id="ph4">`Private`</ph>, <ph id="ph5">`InvokeMethod`</ph>, <ph id="ph6">`GetField`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve">
          <source>The type of lookup need not be specified.</source>
        </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve">
          <source>If the type of lookup is omitted, <ph id="ph1">`BindingFlags.Public`</ph><ph id="ph2"> | </ph><ph id="ph3">`BindingFlags.Instance`</ph><ph id="ph4"> | </ph><ph id="ph5">`BindingFlags.Static`</ph> are used.</source>
        </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve">
          <source>Note that explicitly defining a <ph id="ph1">&lt;xref href="System.Reflection.Binder"&gt;&lt;/xref&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
        </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve">
          <source>The object on which to invoke the specified member.</source>
        </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve">
          <source>An array containing the arguments to pass to the member to invoke.</source>
        </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve">
          <source>An object representing the return value of the invoked member.</source>
        </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain <ph id="ph2">`CreateInstance`</ph> and <ph id="ph3">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`CreateInstance`</ph>, <ph id="ph4">`GetField`</ph>, <ph id="ph5">`SetField`</ph>, <ph id="ph6">`GetProperty`</ph>, or <ph id="ph7">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`CreateInstance`</ph> combined with <ph id="ph3">`InvokeMethod`</ph>, <ph id="ph4">`GetField`</ph>, <ph id="ph5">`SetField`</ph>, <ph id="ph6">`GetProperty`</ph>, or <ph id="ph7">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id="ph2">`GetField`</ph> and <ph id="ph3">`SetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id="ph2">`GetProperty`</ph> and <ph id="ph3">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`InvokeMethod`</ph> combined with <ph id="ph3">`SetField`</ph> or <ph id="ph4">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`SetField`</ph> and <ph id="ph3">&lt;code&gt;args&lt;/code&gt;</ph> has more than one element.</source>
        </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">`BindingFlags.InvokeMethod`</ph>, <ph id="ph2">`BindingFlags.GetProperty`</ph>, <ph id="ph3">`BindingFlags.SetProperty`</ph>, <ph id="ph4">`BindingFlags.PutDispProperty`</ph>, or <ph id="ph5">`BindingFlags.PutRefDispProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve">
          <source>The specified member is a class initializer.</source>
        </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve">
          <source>The field or property cannot be found.</source>
        </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve">
          <source>No method can be found that matches the arguments in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve">
          <source>The specified member cannot be invoked on <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve">
          <source>More than one method matches the binding criteria.</source>
        </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve">
          <source>The .NET Compact Framework does not currently support this method.</source>
        </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve">
          <source>The method represented by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> has one or more unspecified generic type parameters.</source>
        </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve">
          <source>That is, the method's <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</source>
        </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph2">`culture`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id="ph4">`culture`</ph>.</source>
        </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
        </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
        </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
        </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
        </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
        </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
        </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
        </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
        </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
        </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
        </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
        </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with other invocation flags.</source>
        </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
        </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
        </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
        </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
        </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
        </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
        </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.</source>
        </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method will be invoked if both of the following conditions are true:</source>
        </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
        </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
        </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The binder will find all of the matching methods.</source>
        </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
        </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
        </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the method is selected, it is invoked.</source>
        </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accessibility is checked at that point.</source>
        </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
        </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
        </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default binder selects the most specific match.</source>
        </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</source>
        </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph> you can use code such as:</source>
        </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
        </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" extradata="MT">
          <source>which will initialize the field F to this new array.</source>
        </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
        </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will change string "z" in the array that F holds to string "b".</source>
        </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
        </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
        </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
        </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
        </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
        </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve">
          <source>An empty string ("") to invoke the default member.</source>
        </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve">
          <source>For <ph id="ph1">`IDispatch`</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
        </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.</source>
        </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve">
          <source>The access can be one of the <ph id="ph1">`BindingFlags`</ph> such as <ph id="ph2">`Public`</ph>, <ph id="ph3">`NonPublic`</ph>, <ph id="ph4">`Private`</ph>, <ph id="ph5">`InvokeMethod`</ph>, <ph id="ph6">`GetField`</ph>, and so on.</source>
        </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve">
          <source>The type of lookup need not be specified.</source>
        </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve">
          <source>If the type of lookup is omitted, <ph id="ph1">`BindingFlags.Public`</ph><ph id="ph2"> | </ph><ph id="ph3">`BindingFlags.Instance`</ph><ph id="ph4"> | </ph><ph id="ph5">`BindingFlags.Static`</ph> are used.</source>
        </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
        </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic), to use the <ph id="ph2">&lt;xref href="System.Type.DefaultBinder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve">
          <source>Note that explicitly defining a <ph id="ph1">&lt;xref href="System.Reflection.Binder"&gt;&lt;/xref&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
        </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve">
          <source>The object on which to invoke the specified member.</source>
        </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve">
          <source>An array containing the arguments to pass to the member to invoke.</source>
        </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve">
          <source>The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> to a <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;xref href="System.Globalization.CultureInfo"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve">
          <source>An object representing the return value of the invoked member.</source>
        </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain <ph id="ph2">`CreateInstance`</ph> and <ph id="ph3">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph4">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> is not a valid <ph id="ph2">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`CreateInstance`</ph>, <ph id="ph4">`GetField`</ph>, <ph id="ph5">`SetField`</ph>, <ph id="ph6">`GetProperty`</ph>, or <ph id="ph7">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`CreateInstance`</ph> combined with <ph id="ph3">`InvokeMethod`</ph>, <ph id="ph4">`GetField`</ph>, <ph id="ph5">`SetField`</ph>, <ph id="ph6">`GetProperty`</ph>, or <ph id="ph7">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id="ph2">`GetField`</ph> and <ph id="ph3">`SetField`</ph>.</source>
        </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id="ph2">`GetProperty`</ph> and <ph id="ph3">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`InvokeMethod`</ph> combined with <ph id="ph3">`SetField`</ph> or <ph id="ph4">`SetProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id="ph2">`SetField`</ph> and <ph id="ph3">&lt;code&gt;args&lt;/code&gt;</ph> has more than one element.</source>
        </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">`BindingFlags.InvokeMethod`</ph>, <ph id="ph2">`BindingFlags.GetProperty`</ph>, <ph id="ph3">`BindingFlags.SetProperty`</ph>, <ph id="ph4">`BindingFlags.PutDispProperty`</ph>, or <ph id="ph5">`BindingFlags.PutRefDispProperty`</ph>.</source>
        </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve">
          <source>The specified member is a class initializer.</source>
        </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve">
          <source>The field or property cannot be found.</source>
        </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve">
          <source>No method can be found that matches the arguments in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">args</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve">
          <source>The specified member cannot be invoked on <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">target</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve">
          <source>More than one method matches the binding criteria.</source>
        </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve">
          <source>The method represented by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">name</ph><ept id="p1">&lt;/code&gt;</ept> has one or more unspecified generic type parameters.</source>
        </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve">
          <source>That is, the method's <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is abstract and must be overridden.</source>
        </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> in the following cases:</source>
        </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</source>
        </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, abstract classes are marked with the <bpt id="p1">[</bpt>abstract<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> keyword; in Visual Basic, they are marked with the <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current type is an interface.</source>
        </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is abstract; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">`AnsiClass`</ph> is selected for the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
        </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
        </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the string format attribute <ph id="ph2">`AnsiClass`</ph> is selected for the <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the type is an array.</source>
        </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the <ph id="ph3">&lt;xref:System.Array&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also returns <ph id="ph1">`false`</ph> if the current instance is a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a collection type or an interface designed to work with collections, such as <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT">
          <source>To check for an array, use code such as:</source>
        </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current type is an array; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;xref href="System.Type.IsArray"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an array.</source>
        </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class must return <ph id="ph2">`false`</ph> because it is an object, not an array.</source>
        </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an array; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve">
          <source>Determines whether an instance of a specified type can be assigned to an instance of the current type.</source>
        </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method can be used to determine whether an instance of <ph id="ph2">`c`</ph> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.IsAssignableFrom#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.IsAssignableFrom#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method thus ensures that a line of code like the following will execute at runtime without throwing an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> exception or a similar exception:</source>
        </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.IsAssignableFrom#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.IsAssignableFrom#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type definition is not assignable from a closed constructed type.</source>
        </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, you cannot assign the closed constructed type <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) to a variable of type <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`c`</ph> parameter is of type <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, the result is based on the type that is to be built.</source>
        </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example demonstrates this using a built type named <ph id="ph1">`B`</ph>.</source>
        </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.IsAssignableFrom#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.IsAssignableFrom#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve">
          <source>The type to compare with the current type.</source>
        </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if any of the following conditions is true:</source>
        </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve">
          <source><ph id="ph1">-   &lt;code&gt;c&lt;/code&gt;</ph> and the current instance represent the same type.</source>
        </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve">
          <source><ph id="ph1">-   &lt;code&gt;c&lt;/code&gt;</ph> is derived either directly or indirectly from the current instance.</source>
        </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;c&lt;/code&gt;</ph> is derived directly from the current instance if it inherits from the current instance; <ph id="ph2">&lt;code&gt;c&lt;/code&gt;</ph> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</source>
        </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve">
          <source>The current instance is an interface that <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">c</ph><ept id="p1">&lt;/code&gt;</ept> implements.</source>
        </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve">
          <source><ph id="ph1">-   &lt;code&gt;c&lt;/code&gt;</ph> is a generic type parameter, and the current instance represents one of the constraints of <ph id="ph2">&lt;code&gt;c&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve">
          <source>In the following example, the current instance is a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the <ph id="ph2">&lt;xref href="System.IO.Stream"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">GenericWithConstraint</ph><ept id="p1">&lt;/code&gt;</ept> is a generic type whose generic type parameter must be of type    <ph id="ph2">&lt;xref href="System.IO.Stream"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve">
          <source>Passing its generic type parameter to the <ph id="ph1">&lt;xref href="System.Type.IsAssignableFrom(System.Type)"&gt;&lt;/xref&gt;</ph> indicates that  an instance of the generic type parameter can be assigned to an <ph id="ph2">&lt;xref href="System.IO.Stream"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.IsAssignableFrom#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.IsAssignableFrom#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve">
          <source><ph id="ph1">-   &lt;code&gt;c&lt;/code&gt;</ph> represents a value type, and the current instance represents <ph id="ph2">&lt;code&gt;</ph>Nullable<ph id="ph3">&lt;c&gt;</ph><ph id="ph4">&lt;/code&gt;</ph> (<ph id="ph5">&lt;code&gt;Nullable(Of c)&lt;/code&gt;</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> if none of these conditions are true, or if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">c</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">`AutoClass`</ph> is selected for the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
        </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
        </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the string format attribute <ph id="ph2">`AutoClass`</ph> is selected for the <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</source>
        </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is provided as a convenience.</source>
        </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is set.</source>
        </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
        </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> when you create the type.</source>
        </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</source>
        </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
        </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
        </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type.Attributes"&gt;&lt;/xref&gt;</ph> property of the current type includes <ph id="ph3">&lt;xref href="System.Reflection.TypeAttributes.AutoLayout"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is passed by reference.</source>
        </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get to the actual type, dereference the type that was passed by reference, and then call <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> on that type.</source>
        </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is passed by reference; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;xref href="System.Type.IsByRef"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is passed by reference.</source>
        </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is passed by reference; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a class or a delegate; that is, not a value type or interface.</source>
        </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns <ph id="ph1">`true`</ph> for classes as well as delegates.</source>
        </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT">
          <source>It returns <ph id="ph1">`false`</ph> for value types (for structures and enumerations) even if they are boxed.</source>
        </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current<ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`true`</ph>.If the current <ph id="ph3">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns <ph id="ph4">`true`</ph> if the generic type definition is a class definition; that is, it does not define an interface or a value type.</source>
        </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns <ph id="ph1">`true`</ph> for <ph id="ph2">`Type`</ph> instances that represent the <ph id="ph3">&lt;xref:System.Enum&gt;</ph> and <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> classes.</source>
        </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT">
          <source>These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</source>
        </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph>and <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you retrieve the value of a type's Attributes property and use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> value to determine whether a type is a class instead of a value type, you must also call the <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example for the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration contains additional information as well as anexample.</source>
        </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a class; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a COM object.</source>
        </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
        </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
        </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also load a COM class and get a <ph id="ph1">`Type`</ph> object for that COM class by using the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
        </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a COM object; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;xref href="System.Type.IsCOMObject"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a COM object.</source>
        </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
        </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
        </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a COM object; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
        </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve">
          <source>You can create instances of a constructed generic type.</source>
        </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT">
          <source>A constructed generic type has had explicit types supplied for all of its generic type parameters.</source>
        </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is also referred to as a closed generic type.</source>
        </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this property is <ph id="ph1">`true`</ph>, you can create instances of the current type; when it is <ph id="ph2">`false`</ph>, you can't.</source>
        </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> can be hosted in a context.</source>
        </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT">
          <source>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</source>
        </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more detailed information on remoting contexts, see <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve">
          <source>Implements the <ph id="ph1">&lt;xref href="System.Type.IsContextful"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> can be hosted in a context.</source>
        </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT">
          <source>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</source>
        </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents an enumeration.</source>
        </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns <ph id="ph1">`true`</ph> for an enumeration, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
        </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents an enumeration; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the specified value exists in the current enumeration type.</source>
        </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve">
          <source>The value to be tested.</source>
        </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the specified value is a member of the current enumeration type; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve">
          <source>The current type is not an enumeration.</source>
        </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that cannot be the underlying type of an enumeration.</source>
        </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve">
          <source>Determines whether two COM types have the same identity and are eligible for type equivalence.</source>
        </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</source>
        </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</source>
        </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each managed assembly has a different <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to represent its view of the COM type.</source>
        </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</source>
        </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</source>
        </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</source>
        </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Type Equivalence and Embedded Interop Types<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve">
          <source>The COM type that is tested for equivalence with the current type.</source>
        </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the COM types are equivalent; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve">
          <source>This method also returns <ph id="ph1">`false`</ph> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</source>
        </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</source>
        </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is provided as a convenience.</source>
        </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is set.</source>
        </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
        </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> when you create the type.</source>
        </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</source>
        </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
        </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type.Attributes"&gt;&lt;/xref&gt;</ph> property of the current type includes <ph id="ph3">&lt;xref href="System.Reflection.TypeAttributes.ExplicitLayout"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a type parameter in the definition of a generic type or method.</source>
        </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent generic type parameters can be obtained by calling the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition, or the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
        </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a generic type or method definition, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for every element of the resulting array.</source>
        </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a closed constructed type or method, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for every element of the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</source>
        </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> returns <ph id="ph2">`false`</ph> for the types and <ph id="ph3">`true`</ph> for the type parameters.</source>
        </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property demonstrates a generic class with a mixture of types and type parameters.</source>
        </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object represents a type parameter of a generic type definition or generic method definition; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current type is a generic type.</source>
        </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents a generic type.</source>
        </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents an open constructed type or a closed constructed type.</source>
        </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> if the immediate type is not generic.</source>
        </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, an array whose elements are of type <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> in Visual Basic) is not itself a generic type.</source>
        </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table summarizes the invariant conditions for common terms used in generic reflection.</source>
        </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" extradata="MT">
          <source>Term</source>
        </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invariant</source>
        </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" extradata="MT">
          <source>generic type definition</source>
        </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" extradata="MT">
          <source>Defines a generic type.</source>
        </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT">
          <source>A constructed type is created by calling the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition and specifying an array of type arguments.</source>
        </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be called only on generic type definitions.</source>
        </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any generic type definition is a generic type (the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>), but the converse is not true.</source>
        </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT">
          <source>generic type</source>
        </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT">
          <source>Can be a generic type definition, an open constructed type, or a closed constructed type.</source>
        </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that an array type whose element type is generic is not itself a generic type.</source>
        </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT">
          <source>The same is true of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing a pointer to a generic type.</source>
        </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT">
          <source>open constructed type</source>
        </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT">
          <source>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not possible to create an instance of an open constructed type.</source>
        </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that not all open constructed types are generic.</source>
        </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</source>
        </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT">
          <source>closed constructed type</source>
        </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT">
          <source>When examined recursively, the type has no unassigned generic parameters.</source>
        </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT">
          <source>generic type parameter</source>
        </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT">
          <source>In a generic type definition, a placeholder for a type that will be assigned later.</source>
        </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT">
          <source>generic type argument</source>
        </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Can be any type, including a generic type parameter.</source>
        </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type arguments are specified as an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method when creating a constructed generic type.</source>
        </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" extradata="MT">
          <source>If instances of the resulting type are to be created, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property must be <ph id="ph2">`false`</ph> for all the type arguments.</source>
        </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code example and table illustrate some of these terms and invariants.</source>
        </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Derived`</ph> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</source>
        </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type.IsGenericType#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type.IsGenericType#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type.IsGenericType#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows examples that use and build on the classes <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, and <ph id="ph3">`G`</ph>.</source>
        </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the C++ and C# code is the same, only one entry is shown.</source>
        </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" extradata="MT">
          <source>Invariants</source>
        </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this type:</source>
        </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this type:</source>
        </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the type of variable <ph id="ph1">`d`</ph>:</source>
        </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because <ph id="ph3">`d`</ph> is an array.</source>
        </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, and <ph id="ph3">`V`</ph> (everywhere they appear)</source>
        </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because there is no way to constrain a type parameter to generic types.</source>
        </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, and <ph id="ph5">`V`</ph> are themselves generic type parameters.</source>
        </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT">
          <source>This does not imply anything about type arguments that are assigned to them later.</source>
        </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of field <ph id="ph1">`F`</ph></source>
        </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph> because a type has been assigned to to the type parameter of <ph id="ph3">`G`</ph>.</source>
        </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is equivalent to having called the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the type of field <ph id="ph3">`F`</ph> has a type argument that is an open constructed type.</source>
        </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT">
          <source>The constructed type is open because its type argument (that is, <ph id="ph1">`Base`</ph>) is a generic type definition.</source>
        </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested class <ph id="ph1">`Nested`</ph></source>
        </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>, even though the <ph id="ph3">`Nested`</ph> class has no generic type parameters of its own, because it is nested in a generic type.</source>
        </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, you can call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method and supply the type parameter of the enclosing type, <ph id="ph2">`Derived`</ph>.</source>
        </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the enclosing type, <ph id="ph3">`Derived`</ph>, has generic type parameters.</source>
        </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current type is a generic type; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> represents a generic type definition, from which other generic types can be constructed.</source>
        </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic type definition is a template from which other types can be constructed.</source>
        </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic), by calling the <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with a generic argument list containing the <ph id="ph7">&lt;xref:System.Int32&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method gets the generic type definition back again.</source>
        </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property to determine whether you can create new types from the current type.</source>
        </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, you can call the <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create new generic types.</source>
        </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> has a <ph id="ph2">&lt;xref href="System.Runtime.InteropServices.ComImportAttribute"&gt;&lt;/xref&gt;</ph> attribute applied, indicating that it was imported from a COM type library.</source>
        </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
        </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> has a <ph id="ph3">&lt;xref href="System.Runtime.InteropServices.ComImportAttribute"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve">
          <source>Determines whether the specified object is an instance of the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT">
          <source>A constructed type is not an instance of its generic type definition.</source>
        </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) is not an instance of <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve">
          <source>The object to compare with the current type.</source>
        </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">`Type`</ph> is in the inheritance hierarchy of the object represented by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">o</ph><ept id="p1">&lt;/code&gt;</ept>, or if the current <ph id="ph4">`Type`</ph> is an interface that <bpt id="p2">&lt;code&gt;</bpt><ph id="ph5">o</ph><ept id="p2">&lt;/code&gt;</ept> implements.</source>
        </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> if neither of these conditions is the case, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">o</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph>, or if the current <ph id="ph4">`Type`</ph> is an open generic type (that is, <ph id="ph5">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> returns <ph id="ph6">`true`</ph>).</source>
        </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an interface; that is, not a class or a value type.</source>
        </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distinguishes a type declaration as class, interface or value type.</source>
        </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is an interface; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</source>
        </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is provided as a convenience.</source>
        </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is set.</source>
        </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
        </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> when you create the type.</source>
        </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> enumeration value to the type, to specify that layout is sequential.</source>
        </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
        </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</source>
        </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
        </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type.Attributes"&gt;&lt;/xref&gt;</ph> property of the current type includes <ph id="ph3">&lt;xref href="System.Reflection.TypeAttributes.SequentialLayout"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is marshaled by reference.</source>
        </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve">
          <source>Implements the <ph id="ph1">&lt;xref href="System.Type.IsMarshalByRef"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is marshaled by reference.</source>
        </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object represents a type whose definition is nested inside the definition of another type.</source>
        </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for all nested types, regardless of visibility.</source>
        </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT">
          <source>To test for nesting and visibility at the same time, use the related properties <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> enumeration member selects the visibility attributes for a type.</source>
        </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested inside another type; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own assembly.</source>
        </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.</source>
        </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own assembly; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly.</source>
        </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.</source>
        </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</source>
        </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`protected internal`</ph> visibility in C# and <ph id="ph2">`Protected Friend`</ph> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</source>
        </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
        </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own family.</source>
        </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.</source>
        </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
        </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own family; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to either its own family or to its own assembly.</source>
        </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the visibility of a type is <ph id="ph1">`protected internal`</ph> in C# or <ph id="ph2">`Protected Friend`</ph> in Visual Basic, the <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.</source>
        </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
        </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and declared private.</source>
        </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.</source>
        </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is nested and declared private; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether a class is nested and declared public.</source>
        </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.</source>
        </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the class is nested and declared public; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is not declared public.</source>
        </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use this property with nested types; use the <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> property instead.</source>
        </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is not declared public and is not a nested type; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a pointer.</source>
        </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a pointer; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;xref href="System.Type.IsPointer"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a pointer.</source>
        </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a pointer; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is one of the primitive types.</source>
        </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, and <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;xref href="System.Type.IsPrimitive"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is one of the primitive types.</source>
        </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, and <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is declared public.</source>
        </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use with nested types; use <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> instead.</source>
        </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.</source>
        </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is declared public and is not a nested type; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is declared sealed.</source>
        </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is declared sealed; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
        </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combinations of these properties are shown in the following table:</source>
        </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security level</source>
        </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityCritical</source>
        </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecuritySafeCritical</source>
        </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityTransparent</source>
        </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" extradata="MT">
          <source>Critical</source>
        </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" extradata="MT">
          <source>Safe critical</source>
        </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT">
          <source>Transparent</source>
        </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
        </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
        </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly and all its types are treated as transparent.</source>
        </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
        </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
        </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current type is security-critical or security-safe-critical at the current trust level; <ph id="ph2">`false`</ph> if it is transparent.</source>
        </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
        </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combinations of these properties are shown in the following table:</source>
        </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security level</source>
        </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityCritical</source>
        </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecuritySafeCritical</source>
        </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityTransparent</source>
        </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT">
          <source>Critical</source>
        </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" extradata="MT">
          <source>Safe critical</source>
        </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT">
          <source>Transparent</source>
        </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
        </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
        </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly and all its types are treated as transparent.</source>
        </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
        </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
        </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current type is security-safe-critical at the current trust level; <ph id="ph2">`false`</ph> if it is security-critical or transparent.</source>
        </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</source>
        </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
        </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
        </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly and all its types are treated as transparent.</source>
        </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
        </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
        </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the type is security-transparent at the current trust level; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is serializable.</source>
        </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is serializable; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the type has a name that requires special handling.</source>
        </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" extradata="MT">
          <source>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</source>
        </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the type has a name that requires special handling; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve">
          <source>Determines whether the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> derives from the specified <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to determine any of the following:</source>
        </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT">
          <source>Whether one class derives from another.</source>
        </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> is a more efficient way to determine whether a type is a value type.</source>
        </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> method is a more efficient way to determine whether a type is an enumeration.</source>
        </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT">
          <source>Whether a type is a delegate, that is, whether it derives from either <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> or <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</source>
        </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the<ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method for that purpose, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Type.IsSubclassOf#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Type.IsSubclassOf#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <ph id="ph2">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> if it has no class constraint.</source>
        </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT">
          <source>Except when used with interfaces, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> is the converse of <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, if <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> is <ph id="ph2">`true`</ph>, then <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> is also <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be overridden by a derived class.</source>
        </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve">
          <source>The type to compare with the current type.</source>
        </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">`Type`</ph> derives from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">c</ph><ept id="p1">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve">
          <source>This method also returns <ph id="ph1">`false`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">c</ph><ept id="p1">&lt;/code&gt;</ept> and the current <ph id="ph3">`Type`</ph> are equal.</source>
        </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;c&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">`UnicodeClass`</ph> is selected for the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> is used to select the string format attributes.</source>
        </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
        </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the string format attribute <ph id="ph2">`UnicodeClass`</ph> is selected for the <ph id="ph3">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a value type.</source>
        </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</source>
        </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value types are referred to as "structs" in some programming languages.</source>
        </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enums are a special case of value types.</source>
        </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns <ph id="ph1">`false`</ph> for the <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> class, because <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> is not a value type itself.</source>
        </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is the base class for all value types, and therefore any value type can be assigned to it.</source>
        </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT">
          <source>This would not be possible if <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> itself was a value type.</source>
        </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value types are boxed when they are assigned to a field of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property returns <ph id="ph1">`true`</ph> for enumerations, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
        </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates this behavior, see <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only.</source>
        </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a value type; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve">
          <source>Implements the <ph id="ph1">&lt;xref href="System.Type.IsValueType"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a value type; that is, not a class or an interface.</source>
        </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is provided to enable the implementation of alternate type systems.</source>
        </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not generally used in application code.</source>
        </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a value type; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> can be accessed by code outside the assembly.</source>
        </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this property to determine whether a type is part of the public interface of a component assembly.</source>
        </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is a public type or a public nested type such that all the enclosing types are public; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing an array of the current type, with the specified number of dimensions.</source>
        </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
        </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
        </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
        </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this method overload to create a vector type; if <ph id="ph1">`rank`</ph> is 1, this method overload returns a multidimensional array type that happens to have one dimension.</source>
        </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> method overload to create vector types.</source>
        </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve">
          <source>The number of dimensions for the array.</source>
        </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve">
          <source>This number must be less than or equal to 32.</source>
        </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve">
          <source>An object representing an array of the current type, with the specified number of dimensions.</source>
        </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;rank&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve">
          <source>For example, 0 or negative.</source>
        </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve">
          <source>The current type is <ph id="ph1">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve">
          <source>The current type is a <ph id="ph1">`ByRef`</ph> type.</source>
        </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Type.IsByRef"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;rank&lt;/code&gt;</ph> is greater than 32.</source>
        </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
        </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
        </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
        </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" extradata="MT">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
        </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload can only be used to create vector types, and it is the only way to create a vector type.</source>
        </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> method overload to create multidimensional array types.</source>
        </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
        </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve">
          <source>Derived classes must provide an implementation.</source>
        </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve">
          <source>The current type is <ph id="ph1">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve">
          <source>The current type is a <ph id="ph1">`ByRef`</ph> type.</source>
        </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Type.IsByRef"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the current type when passed as a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> parameter in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
        </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32&amp;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents the current type when passed as a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> parameter in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve">
          <source>The current type is <ph id="ph1">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve">
          <source>The current type is a <ph id="ph1">`ByRef`</ph> type.</source>
        </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Type.IsByRef"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing the resulting constructed type.</source>
        </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a particular constructed type.</source>
        </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to create run-time instances of the constructed type.</source>
        </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Types constructed with <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</source>
        </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT">
          <source>You might use such open constructed types when you emit dynamic assemblies.</source>
        </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider the classes <ph id="ph1">`Base`</ph> and <ph id="ph2">`Derived`</ph> in the following code.</source>
        </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type.MakeGenericType#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type.MakeGenericType#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type.MakeGenericType#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT">
          <source>To generate <ph id="ph1">`Derived`</ph> in a dynamic assembly, it is necessary to construct its base type.</source>
        </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the class <ph id="ph3">`Base`</ph>, using the generic type arguments <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and the type parameter <ph id="ph5">`V`</ph> from <ph id="ph6">`Derived`</ph>.</source>
        </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because types and generic type parameters are both represented by <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, an array containing both can be passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT">
          <source>A constructed type such as <ph id="ph1">`Base&lt;int, V&gt;`</ph> is useful when emitting code, but you cannot call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on this type because it is not a generic type definition.</source>
        </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create a closed constructed type that can be instantiated, first call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the generic type definition and then call <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> with the desired type arguments.</source>
        </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object returned by <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> is the same as the <ph id="ph3">&lt;xref:System.Type&gt;</ph> obtained by calling the <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> method of the resulting constructed type, or the <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph>method of any constructed type that was created from the same generic type definition using the same type arguments.</source>
        </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" extradata="MT">
          <source>An array of generic types is not itself a generic type.</source>
        </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot call <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on an array type such as <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT">
          <source>To construct a closed generic type from <ph id="ph1">`C&lt;T&gt;[]`</ph>, call <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> to obtain the generic type definition <ph id="ph3">`C&lt;T&gt;`</ph>; call <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on the generic type definition to create the constructed type; and finally call the <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method on the constructed type to create the array type.</source>
        </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" extradata="MT">
          <source>The same is true of pointer types and <ph id="ph1">`ref`</ph> types (<ph id="ph2">`ByRef`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
        </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nested Types</source>
        </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</source>
        </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</source>
        </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider the following classes:</source>
        </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Type.MakeGenericType#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Type.MakeGenericType#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Type.MakeGenericType#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type parameter list of the nested class <ph id="ph1">`Inner`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, the first of which is the type parameter of its enclosing class.</source>
        </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the type parameter list of the nested class <ph id="ph1">`Innermost1`</ph> has three type parameters, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, and <ph id="ph4">`V`</ph>, with <ph id="ph5">`T`</ph> and <ph id="ph6">`U`</ph> coming from its enclosing classes.</source>
        </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nested class <ph id="ph1">`Innermost2`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, which come from its enclosing classes.</source>
        </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</source>
        </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT">
          <source>To construct a generic type from the generic type definition for a nested type, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</source>
        </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create an instance of <ph id="ph1">`Innermost1`</ph>, call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <ph id="ph3">`Innermost2`</ph>, call the <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing two types, to be assigned to T and U.</source>
        </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" extradata="MT">
          <source>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</source>
        </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the type parameters would not be in scope within the bodies of the nested types.</source>
        </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider the following code for the MSIL assembler:</source>
        </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this example, it is not possible to define a field of type <ph id="ph1">`T`</ph> or <ph id="ph2">`U`</ph> in class <ph id="ph3">`Innermost`</ph>, because those type parameters are not in scope.</source>
        </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</source>
        </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine nested classes defined in the high-level languages and observe this naming scheme.</source>
        </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve">
          <source>An array of types to be substituted for the type parameters of the current generic type.</source>
        </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> representing the constructed type formed by substituting the elements of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> for the type parameters of the current generic type.</source>
        </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve">
          <source>The current type does not represent a generic type definition.</source>
        </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Type.IsGenericTypeDefinition"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeArguments&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve">
          <source>Any element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve">
          <source>The number of elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> is not the same as the number of type parameters in the current generic type definition.</source>
        </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve">
          <source>Any element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</source>
        </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeArguments&lt;/code&gt;</ph> contains an element that is a pointer type (<ph id="ph2">&lt;xref href="System.Type.IsPointer"&gt;&lt;/xref&gt;</ph> returns <ph id="ph3">`true`</ph>), a by-ref type (<ph id="ph4">&lt;xref href="System.Type.IsByRef"&gt;&lt;/xref&gt;</ph> returns <ph id="ph5">`true`</ph>), or <ph id="ph6">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve">
          <source>Derived classes must provide an implementation.</source>
        </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents a pointer to the current type.</source>
        </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
        </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32*`</ph>.</source>
        </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object that represents a pointer to the current type.</source>
        </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve">
          <source>The current type is <ph id="ph1">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve">
          <source>The current type is a <ph id="ph1">`ByRef`</ph> type.</source>
        </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Type.IsByRef"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Reflection.MemberTypes"&gt;&lt;/xref&gt;</ph> value indicating that this member is a type or a nested type.</source>
        </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects—for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes?displayProperty=fullName&gt;</ph> when a given member is a nested type.</source>
        </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
        </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns<ph id="ph2">&lt;xref:System.Reflection.MemberTypes?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MemberTypes"&gt;&lt;/xref&gt;</ph> value indicating that this member is a type or a nested type.</source>
        </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve">
          <source>Represents a missing value in the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> information.</source>
        </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve">
          <source>This field is read-only.</source>
        </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`Missing`</ph> field for invocation through reflection to obtain the default value of a parameter.</source>
        </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`Missing`</ph> field is passed in for a parameter value and there is no default value for that parameter, an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve">
          <source>Gets the module (the DLL) in which the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is defined.</source>
        </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</source>
        </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property for the constructed type returns the module in which <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> is defined.</source>
        </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve">
          <source>The module in which the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> is defined.</source>
        </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve">
          <source>Gets the namespace of the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT">
          <source>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</source>
        </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the viewpoint of the runtime, there are no namespaces.</source>
        </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</source>
        </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the namespace that contains the generic type definition that defines <ph id="ph3">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve">
          <source>The namespace of the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>; <ph id="ph2">`null`</ph> if the current instance has no namespace or represents a generic parameter.</source>
        </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve">
          <source>Indicates whether two <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects are equal.</source>
        </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve">
          <source>Indicates whether two <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects are not equal.</source>
        </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is not equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve">
          <source>Gets the class object that was used to obtain this member.</source>
        </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT">
          <source>For <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, the value of this property is always the same as the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Type`</ph> object through which this <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object was obtained.</source>
        </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</source>
        </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve">
          <source>The type is loaded for reflection only, not for execution.</source>
        </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly containing the type is not already loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> method is equivalent to first loading the assembly for reflection only, using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, and then loading the type by calling the assembly's <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about assembly-qualified names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional details on specifying type names, see the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</source>
        </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`throwIfNotFound`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwIfNotFound`</ph>.</source>
        </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the assembly is not valid, a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> is thrown even if <ph id="ph2">`throwIfNotFound`</ph> is <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using the reflection-only context, see <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> to get.</source>
        </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to throw a <ph id="ph2">&lt;xref href="System.TypeLoadException"&gt;&lt;/xref&gt;</ph> if the type cannot be found; <ph id="ph3">`false`</ph> to return <ph id="ph4">`null`</ph> if the type cannot be found.</source>
        </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve">
          <source>Specifying <ph id="ph1">`false`</ph> also suppresses some other exception conditions, but not all of them.</source>
        </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to perform a case-insensitive search for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeName</ph><ept id="p1">&lt;/code&gt;</ept>; <ph id="ph3">`false`</ph> to perform a case-sensitive search for <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">typeName</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve">
          <source>If the type is not found, the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwIfNotFound</ph><ept id="p1">&lt;/code&gt;</ept> parameter specifies whether <ph id="ph2">`null`</ph> is returned or an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve">
          <source>In some cases, an exception is thrown regardless of the value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">throwIfNotFound</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve">
          <source>See the Exceptions section.</source>
        </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve">
          <source>A class initializer is invoked and throws an exception.</source>
        </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the type is not found.</source>
        </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.</source>
        </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.</source>
        </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id="ph2">&lt;xref href="System.TypedReference"&gt;&lt;/xref&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> does not include the assembly name.</source>
        </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax; for example, "MyType[,*,]".</source>
        </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">`ByRef`</ph> type, or <ph id="ph3">&lt;xref href="System.Void"&gt;&lt;/xref&gt;</ph> as one of its type arguments.</source>
        </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
        </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
        </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id="ph2">`true`</ph> and the assembly or one of its dependencies was not found.</source>
        </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
        </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve">
          <source>The assembly or one of its dependencies is not valid.</source>
        </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
        </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.StructLayoutAttribute"&gt;&lt;/xref&gt;</ph> that describes the layout of the current type.</source>
        </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> is not returned by the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, use this property to get it.</source>
        </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Runtime.InteropServices.StructLayoutAttribute"&gt;&lt;/xref&gt;</ph> that describes the gross layout features of the current type.</source>
        </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve">
          <source>The invoked method is not supported in the base class.</source>
        </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">`String`</ph> representing the name of the current <ph id="ph2">`Type`</ph>.</source>
        </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns the fully qualified common language runtime namespace and name for all primitive types.</source>
        </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# instruction, <ph id="ph1">`(long)0.Type().ToString()`</ph> returns "System.Int64" instead of merely "Int64".</source>
        </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</source>
        </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</source>
        </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> representing the name of the current <ph id="ph2">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve">
          <source>Gets the handle for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`TypeHandle`</ph> encapsulates a pointer to an internal data structure that represents the type.</source>
        </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT">
          <source>This handle is unique during the process lifetime.</source>
        </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT">
          <source>The handle is valid only in the application domain in which it was obtained.</source>
        </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve">
          <source>The handle for the current <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve">
          <source>The .NET Compact Framework does not currently support this property.</source>
        </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve">
          <source>Gets the initializer for the type.</source>
        </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Class initializers are also available through the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, or through overloads of the <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> methods that take <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> as a parameter.</source>
        </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve">
          <source>An object that contains the name of the class constructor for the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve">
          <source>Indicates the type provided by the common language runtime that represents this type.</source>
        </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve">
          <source>The underlying system type for the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
        </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
        </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
        </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
        </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
        </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
        </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
        </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
        </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve">
          <source>A pointer to the requested type information object.</source>
        </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
        </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
        </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
        </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
        </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
        </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
        </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
        </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
        </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
        </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
        </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>