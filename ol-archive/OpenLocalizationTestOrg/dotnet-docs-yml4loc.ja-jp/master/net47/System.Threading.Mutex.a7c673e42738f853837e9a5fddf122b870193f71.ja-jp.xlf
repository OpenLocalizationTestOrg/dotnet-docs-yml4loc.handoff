<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b3d0c53d803aeba090c65efd76c652f0e7685061</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Threading.Mutex.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">566f4c3bcd310e7b9651fcdb1e353118dc3d0332</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dd1ff42f49567db8100b7c53f39b4d2fd4fb4b17</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>A synchronization primitive that can also be used for interprocess synchronization.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6)</ept>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method to request ownership of a mutex.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>The calling thread blocks until one of the following occurs:</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The mutex is signaled to indicate that it is not owned.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>When it has finished accessing the resource, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first example in the Examples section illustrates this pattern.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The time-out interval specified in the call to a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method that has a <ph id="ph2">`millisecondsTimeout`</ph> or <ph id="ph3">`timeout`</ph> parameter has elapsed.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`false`</ph>, and the calling thread makes no further attempt to acquire ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the thread never acquired ownership of the mutex, it must not call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The second example in the Examples section illustrates this pattern.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>A mutex can also be passed across application domain boundaries.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread that owns a mutex can request the same mutex in repeated calls to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> without blocking its execution.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method the same number of times to release ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class inherits from <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, you can also call the static <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;</ph> methods to synchronize access to a protected resource.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The state of the mutex is set to signaled, and the next waiting thread gets ownership.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the abandoned mutex.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before version 2.0 of the .NET Framework, no exception was thrown.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>A local mutex exists only within your process.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used by any thread in your process that has a reference to the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the mutex.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each unnamed <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object represents a separate local mutex.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex by using a constructor that accepts a name.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating-system object can be created at the same time, or it can exist before the creation of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex, and you can use the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method to open an existing named system mutex.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> class with default properties.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this constructor overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor overload and specifying <ph id="ph2">`false`</ph> for initial ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the calling thread does not own the mutex.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to give the calling thread initial ownership of the mutex; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initiallyOwned`</ph> when calling this constructor overload.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor if you need to determine initial ownership.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The name of the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`null`</ph>, the <ph id="ph2">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> is unnamed.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexRights.FullControl"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>method.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The name of the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`null`</ph>, the <ph id="ph2">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> is unnamed.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">`true`</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">name</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph4">`false`</ph> if the specified named system mutex already existed.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexRights.FullControl"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named system mutex does not exist, it is created with the specified access control security.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named mutex exists, the specified access control security is ignored.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object even if <ph id="ph2">`mutexSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object to represent the same named mutex, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The name of the system mutex.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>If the value is <ph id="ph1">`null`</ph>, the <ph id="ph2">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> is unnamed.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">`true`</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">name</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph4">`false`</ph> if the specified named system mutex already existed.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexRights.FullControl"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named mutex.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named mutex.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> object represents a named system mutex, but the user does not have <ph id="ph2">&lt;xref href="System.Security.AccessControl.MutexRights.ReadPermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> object represents a named system mutex, and was not opened with <ph id="ph2">&lt;xref href="System.Security.AccessControl.MutexRights.ReadPermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Opens the specified named mutex, if it already exists.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open the specified named system mutex.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not request ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The name of the system mutex to open.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>An object that represents the named system mutex.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The named mutex does not exist.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Opens the specified named mutex, if it already exists, with the desired security access.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open an existing named mutex.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not request ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The name of the system mutex to open.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>An object that represents the named system mutex.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>The named mutex does not exist.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The named mutex exists, but the user does not have the desired security access.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Releases the <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> once.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Whenever a thread acquires a mutex (for example, by calling its <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method), it must subsequently call <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the attempt to get ownership of the mutex fails (for example, when a call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method with a <ph id="ph2">`millisecondsTimeout`</ph> or a <ph id="ph3">`timeout`</ph> parameter returns <ph id="ph4">`false`</ph> because the request times out), the thread shouldn't call <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Mutex.Class#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Mutex.Class#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>The number of calls is kept by the common language runtime.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread must call <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> the same number of times to release ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>The state of the mutex is set to signaled and the next waiting thread gets ownership.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no one owns the mutex, the state of the mutex is signaled.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the mutex.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Prior to version 2.0 of the .NET Framework, no exception was thrown.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The calling thread does not own the mutex.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The current instance has already been disposed.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Sets the access control security for a named system mutex.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;mutexSecurity&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexRights.ChangePermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The mutex was not opened with <ph id="ph1">&lt;xref href="System.Security.AccessControl.MutexRights.ChangePermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> object does not represent a named system mutex.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named mutex does not exist, this method does not create it.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not request ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The name of the system mutex to open.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">`null`</ph> if the call failed.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>This parameter is treated as uninitialized.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named mutex does not exist, this method does not create it.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not request ownership of the mutex.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The name of the system mutex to open.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a <ph id="ph1">&lt;xref href="System.Threading.Mutex"&gt;&lt;/xref&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">`null`</ph> if the call failed.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>This parameter is treated as uninitialized.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>