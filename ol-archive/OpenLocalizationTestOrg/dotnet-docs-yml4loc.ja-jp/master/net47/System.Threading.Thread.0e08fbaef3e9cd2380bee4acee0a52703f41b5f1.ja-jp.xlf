<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b2243f5c26a8e1a31c395fa49fc5d0689c7c4cc8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Threading.Thread.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">88e1f2ff722f6ebfd80538f2ed8fd81fb1fd1341</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a75b404558a5597f67cfeafe0e72360f5b803b2d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>These threads can execute either in the foreground or in the background.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class to execute code on worker threads that are managed by the common language runtime.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Retrieving Thread objects<ept id="p1">](#Retrieving)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Culture and threads<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Getting information about and controlling threads<ept id="p1">](#Properties)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Accessing the source code for the Thread class<ept id="p1">](#Source)</ept></source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting a thread</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>You then call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method to begin execution.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method has no arguments, you pass a <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> delegate to  the constructor.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example creates and starts a thread that executes the <ph id="ph1">`ExecuteInForeground`</ph> method.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Thread#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method has an argument, you pass a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate to the constructor.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>It has the signature:</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example is identical to the previous one, except that it calls the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Thread#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to retain a reference to a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object once you have started the thread.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread continues to execute until the thread procedure is complete.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving Thread objects</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Thread#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>Foreground and background threads</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instances of the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class represent either foreground threads or background threads.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground:</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following threads execute in the background by default:</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can change a thread to execute in the background by setting the <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property at any time.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between foreground and background threads.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Thread#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Culture and threads</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each thread has a culture, represented by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property, and a UI culture, represented by the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor from the primary thread is English (United States), and not French (France).</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to the <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate or the <ph id="ph3">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this is a per-application domain setting.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and examples, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>Getting information about and controlling threads</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can retrieve a number of property values that provide information about a thread.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>These thread properties include:</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>A name.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> is a write-once property that you can use to identify a thread.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash code, which you can retrieve by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread ID.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the read-only <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property is assigned by the runtime and uniquely identifies a thread within its process.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread's current state.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadState&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>A scheduling priority level, which is defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The read-only <ph id="ph1">&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</ph> property, which indicates whether a thread is  a thread pool thread.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accessing the source code for the Thread class</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)</ept>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Thread"&gt;&lt;/xref&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>To pass a data object to the thread, use the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Thread"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread does not begin executing when it is created.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Threading.ThreadStart"&gt;&lt;/xref&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">start</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Thread"&gt;&lt;/xref&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;&lt;/xref&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">maxStackSize</ph><ept id="p1">&lt;/code&gt;</ept> is ignored if it is greater than the default stack size.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.Thread"&gt;&lt;/xref&gt;</ph> class, specifying the maximum stack size for the thread.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Avoid using this constructor overload.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>No exception is thrown.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Threading.ThreadStart"&gt;&lt;/xref&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">maxStackSize</ph><ept id="p1">&lt;/code&gt;</ept> is ignored if it is greater than the default stack size.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>No exception is thrown.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;start&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;maxStackSize&lt;/code&gt;</ph> is less than zero.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Raises a <ph id="ph1">&lt;xref href="System.Threading.ThreadAbortException"&gt;&lt;/xref&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also a chance that a static constructor could be aborted.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee the wait will end.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Raises a <ph id="ph1">&lt;xref href="System.Threading.ThreadAbortException"&gt;&lt;/xref&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Calling this method usually terminates the thread.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is a chance that a static constructor could be aborted.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee that the wait will end.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, an application cannot detect this situation.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The thread that is being aborted is currently suspended.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Allocates an unnamed data slot on all the threads.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;xref href="System.ThreadStaticAttribute"&gt;&lt;/xref&gt;</ph> attribute instead.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>The slot is allocated on all threads.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>Allocates a named data slot on all threads.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;xref href="System.ThreadStaticAttribute"&gt;&lt;/xref&gt;</ph> attribute instead.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is not necessary to use the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method to allocate a named data slot, because the <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method allocates the slot if it has not already been allocated.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no way to test whether a slot has already been allocated.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>Slots allocated with this method must be freed with <ph id="ph1">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be allocated.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>The allocated named data slot on all threads.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>A named data slot with the specified name already exists.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Gets or sets the apartment state of this thread.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>The <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property is obsolete.<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>The non-obsolete alternatives are the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method to retrieve the apartment state and the   <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method to set the apartment state.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>An attempt to use the <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> in this case.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, new threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> if their apartment state has not been set before they are started.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> by default.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can no longer set the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> by setting the <ph id="ph2">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> property on the first line of code.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph> instead.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)</ept> linker option.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.ApartmentState"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The initial value is <ph id="ph1">`Unknown`</ph>.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<ph id="ph1">`STA`</ph>) or multithreaded apartment (<ph id="ph2">`MTA`</ph>)).</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>Gets the current context in which the thread is executing.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Runtime.Remoting.Contexts.Context"&gt;&lt;/xref&gt;</ph> representing the current thread context.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Gets or sets the culture for the current thread.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName&gt;</ph> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, you can set the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property to a neutral culture.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because the behavior of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class has changed: When it represents a neutral culture, its property values (in particular, the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;</ph> properties) now reflect the specific culture that is associated with the neutral culture.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>In earlier versions of the .NET Framework, the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property threw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception when a neutral culture was assigned.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>An object that represents the culture for the current thread.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>The property is set to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Security.Principal.IPrincipal"&gt;&lt;/xref&gt;</ph> value representing the security context.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>The caller does not have the permission required to set the principal.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Gets the currently running thread.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Threading.Thread"&gt;&lt;/xref&gt;</ph> that is the representation of the currently running thread.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName&gt;</ph> property to learn how a thread's default UI culture is determined.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> returned by this property can be a neutral culture.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>Neutral cultures should not be used with formatting methods such as <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName&gt;</ph> method to get a specific culture, or use the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName&gt;</ph> method throws <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>An object that represents the current culture.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>The property is set to <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>The application does its own message pumping.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The application needs to control precisely when message pumping occurs.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such applications can use the <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A&gt;</ph> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application is ready to clean up runtime callable wrappers, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName&gt;</ph> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Message pumping occurs while the method executes.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most tasks are not affected by this switching.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The caller does not have the required permission.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Gets an <ph id="ph1">&lt;xref href="System.Threading.ExecutionContext"&gt;&lt;/xref&gt;</ph> object that contains information about the various contexts of the current thread.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ExecutionContext&gt;</ph> class provides a single container for all information relevant to a logical thread of execution.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Threading.ExecutionContext"&gt;&lt;/xref&gt;</ph> object that consolidates context information for the current thread.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;xref href="System.Threading.Thread"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Threading.Thread.Finalize%2A&gt;</ph> when the current object is ready to be finalized.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;xref href="System.ThreadStaticAttribute"&gt;&lt;/xref&gt;</ph> attribute instead.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> with the same name will allocate a new slot associated with the name.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, any thread that still has a <ph id="ph1">&lt;xref:System.LocalDataStoreSlot?displayProperty=fullName&gt;</ph> returned by an earlier call to <ph id="ph2">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The name of the data slot to be freed.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Returns an <ph id="ph1">&lt;xref href="System.Threading.ApartmentState"&gt;&lt;/xref&gt;</ph> value indicating the apartment state.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method, along with the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph3">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.ApartmentState"&gt;&lt;/xref&gt;</ph> values indicating the apartment state of the managed thread.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">&lt;xref href="System.Threading.ApartmentState.Unknown"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Threading.CompressedStack"&gt;&lt;/xref&gt;</ph> object that can be used to capture the stack for the current thread.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>None.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;xref href="System.ThreadStaticAttribute"&gt;&lt;/xref&gt;</ph> attribute instead.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.GetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.LocalDataStoreSlot"&gt;&lt;/xref&gt;</ph> from which to get the value.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The retrieved value.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Returns the current domain in which the current thread is running.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.AppDomain"&gt;&lt;/xref&gt;</ph> representing the current application domain of the running thread.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Returns a unique application domain identifier.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Returns a hash code for the current thread.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>The hash code is not guaranteed to be unique.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property if you need a unique identifier for a managed thread.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>An integer hash code value.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>Looks up a named data slot.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;xref href="System.ThreadStaticAttribute"&gt;&lt;/xref&gt;</ph> attribute instead.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named slot does not exist, a new slot is allocated.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>Named data slots are public and can be manipulated by anyone.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The name of the local data slot.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.LocalDataStoreSlot"&gt;&lt;/xref&gt;</ph> allocated for this thread.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>Interrupts a thread that is in the <ph id="ph1">`WaitSleepJoin`</ph> thread state.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> is thrown in the interrupted thread, but not until the thread blocks.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the execution status of the current thread.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this thread has been started and has not terminated normally or aborted; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread is either a background thread or a foreground thread.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any remaining background threads are stopped and do not complete.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the foreground (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>):</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>The primary thread (or main application thread).</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the following threads execute in the background  (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>):</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this thread is or is to become a background thread; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The thread is dead.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/docs/standard/threading/the-managed-thread-pool.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this thread belongs to the managed thread pool; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <ph id="ph1">`SendMessage`</ph> pumping.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this method to ensure that a thread has been terminated.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block until <ph id="ph5">`Thread2`</ph> has completed.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should never call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object that represents the current thread from the current thread.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;xref href="System.Threading.ThreadState.Unstarted"&gt;&lt;/xref&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>The thread is interrupted while waiting.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.Int32%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the thread has terminated; <ph id="ph2">`false`</ph> if the thread has not terminated after the amount of time specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> parameter has elapsed.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&lt;xref href="System.Threading.Timeout.Infinite"&gt;&lt;/xref&gt;</ph> in milliseconds.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The thread has not been started.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.TimeSpan%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Threading.Thread.Join#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Threading.Thread.Join#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</ph> is specified for <ph id="ph2">`timeout`</ph>, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the current thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.TimeSpan"&gt;&lt;/xref&gt;</ph> set to the amount of time to wait for the thread to terminate.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the thread terminated; <ph id="ph2">`false`</ph> if the thread has not terminated after the amount of time specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">timeout</ph><ept id="p1">&lt;/code&gt;</ept> parameter has elapsed.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&lt;xref href="System.Threading.Timeout.Infinite"&gt;&lt;/xref&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph> milliseconds.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;xref href="System.Threading.ThreadState.Unstarted"&gt;&lt;/xref&gt;</ph> state.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for the current managed thread.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread's <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property value serves to uniquely identify that thread within its process.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>An integer that represents a unique identifier for this managed thread.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <ph id="ph1">&lt;xref href="System.Threading.Thread.MemoryBarrier"&gt;&lt;/xref&gt;</ph> execute after memory accesses that follow the call to <ph id="ph2">&lt;xref href="System.Threading.Thread.MemoryBarrier"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Gets or sets the name of the thread.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is write-once.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the default value of a thread's <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property is <ph id="ph2">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string assigned to the <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property can include any Unicode character.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>A string containing the name of the thread, or <ph id="ph1">`null`</ph> if no name was set.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>A set operation was requested, but the <ph id="ph1">`Name`</ph> property has already been set.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can be assigned any one of the following priority <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> values:</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>Operating systems are not required to honor the priority of a thread.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.ThreadPriority"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The default value is <ph id="ph1">&lt;xref href="System.Threading.ThreadPriority.Normal"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>The thread has reached a final state, such as <ph id="ph1">&lt;xref href="System.Threading.ThreadState.Aborted"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is not a valid <ph id="ph1">&lt;xref href="System.Threading.ThreadPriority"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Cancels an <ph id="ph1">&lt;xref href="System.Threading.Thread.Abort(System.Object)"&gt;&lt;/xref&gt;</ph> requested for the current thread.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be called by code with the proper permissions.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>See <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> for an example that demonstrates calling the <ph id="ph2">`ResetAbort`</ph> method.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Abort`</ph> was not invoked on the current thread.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>The caller does not have the required security permission for the current thread.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>Resumes a thread that has been suspended.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deadlocks can occur very easily.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> if their apartment state has not been set before they are started.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> by default.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>The apartment state has already been initialized.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>Applies a captured <ph id="ph1">&lt;xref href="System.Threading.CompressedStack"&gt;&lt;/xref&gt;</ph> to the current thread.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is no longer supported.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Threading.CompressedStack"&gt;&lt;/xref&gt;</ph> object to be applied to the current thread.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>For better performance, use fields marked with the <ph id="ph1">&lt;xref href="System.ThreadStaticAttribute"&gt;&lt;/xref&gt;</ph> attribute instead.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object has been reclaimed by garbage collection.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data slots are unique per thread.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>No other thread (not even a child thread) can get that data.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.LocalDataStoreSlot"&gt;&lt;/xref&gt;</ph> in which to set the value.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The value to be set.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</ph> for the <ph id="ph2">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=fullName&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>The number of milliseconds for which the thread is suspended.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>If the value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The time-out value is negative and is not equal to <ph id="ph1">&lt;xref href="System.Threading.Timeout.Infinite"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>Suspends the current thread for the specified amount of time.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=fullName&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> uses the total number of whole milliseconds in <ph id="ph2">`timeout`</ph>.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional milliseconds are discarded.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>The amount of time for which the thread is suspended.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>If the value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">millisecondsTimeout</ph><ept id="p1">&lt;/code&gt;</ept> argument is <ph id="ph2">&lt;xref href="System.TimeSpan.Zero"&gt;&lt;/xref&gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> is negative and is not equal to <ph id="ph2">&lt;xref href="System.Threading.Timeout.Infinite"&gt;&lt;/xref&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;xref href="System.Int32.MaxValue"&gt;&lt;/xref&gt;</ph> milliseconds.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>Causes a thread to wait the number of times defined by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">iterations</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method is useful for implementing locks.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the .NET Framework, such as <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, use this method internally.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph2">`iterations`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying a non-zero interval for <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> is not generally useful for ordinary applications.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</ph> or a statement that wraps <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</ph> (<ph id="ph3">`lock`</ph> in C# or <ph id="ph4">`SyncLock`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method in your loop.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>The code <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> executes is designed to prevent problems that can occur on computers with multiple processors.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> prevents processor starvation in certain situations.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;xref href="System.Threading.ThreadState.Running"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;</ph> state, the operating system can schedule it for execution.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this overload is used with a thread created using a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;xref href="System.Threading.ThreadState.Running"&gt;&lt;/xref&gt;</ph>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState?displayProperty=fullName&gt;</ph> state, the operating system can schedule it for execution.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload and the <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>An object that contains data to be used by the method the thread executes.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>There is not enough memory available to start this thread.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>This thread was created using a <ph id="ph1">&lt;xref href="System.Threading.ThreadStart"&gt;&lt;/xref&gt;</ph> delegate instead of a <ph id="ph2">&lt;xref href="System.Threading.ParameterizedThreadStart"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread is already suspended, this method has no effect.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>Deadlocks can occur very easily.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>The thread has not been started or is dead.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;xref href="System.Security.Permissions.SecurityPermission"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>Gets a value containing the states of the current thread.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property provides more specific information than the <ph id="ph2">&lt;xref:System.Threading.Thread.IsAlive%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thread state is only of interest in debugging scenarios.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.ThreadState"&gt;&lt;/xref&gt;</ph> values indicating the state of the current thread.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The initial value is <ph id="ph1">`Unstarted`</ph>.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Sets the apartment state of a thread before it is started.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> if their apartment state has not been set before they are started.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source>Apartment state must be set before a thread is started.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> by default.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState?displayProperty=fullName&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>The new apartment state.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the apartment state is set; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;state&lt;/code&gt;</ph> is not a valid apartment state.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>The thread has already been started.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>Reads the value of a field.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>The field to be read.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>The latest value written to the field by any processor.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might require flushing processor caches.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this method affects only a single memory access.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>The field to which the value is to be written.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>The value to be written.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>The operating system selects the thread to yield to.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should call the <ph id="ph1">&lt;xref:System.Threading.Thread.Yield%2A&gt;</ph> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the operating system switched execution to another thread; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>