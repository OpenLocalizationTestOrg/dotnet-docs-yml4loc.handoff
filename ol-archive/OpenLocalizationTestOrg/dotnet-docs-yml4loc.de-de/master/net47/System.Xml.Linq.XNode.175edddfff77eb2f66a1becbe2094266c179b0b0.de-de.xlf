<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4260e328ac35f53f29570c4b170a517d7979e5f8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Xml.Linq.XNode.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">031697aa20ecce353f02cde5d153869014385939</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1f84d5be75cc5346845d49ea52d4e683ac70ad2e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> is an abstract common base class for the following types:</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> is an abstract common base class for the following types:</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>Objects of classes that derive from <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> can contain child nodes.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> is not an <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attributes are maintained as a list of name/value pairs on an element.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Adds the specified content immediately after this node.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A content object that contains simple content or a collection of content objects to be added after this node.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The parent is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Adds the specified content immediately after this node.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>A parameter list of content objects.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The parent is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Adds the specified content immediately before this node.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this method might  affect your performance.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A content object that contains simple content or a collection of content objects to be added before this node.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The parent is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Adds the specified content immediately before this node.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.AddBeforeSelf%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this function might affect your performance.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A parameter list of content objects.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The parent is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Returns a collection of the ancestor elements of this node.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not return itself in the results.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The nodes in the returned collection are in reverse document order.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of the ancestor elements of this node.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Returns a filtered collection of the ancestor elements of this node.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will not return itself in the results.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> to match.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of the ancestor elements of this node.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The nodes in the returned collection are in reverse document order.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Compares two nodes to determine their relative XML document order.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this method might affect your performance.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>First <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> to compare.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Second <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> to compare.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`int`</ph> containing 0 if the nodes are equal; -1 if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">n1</ph><ept id="p1">&lt;/code&gt;</ept> is before <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">n2</ph><ept id="p2">&lt;/code&gt;</ept>; 1 if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">n1</ph><ept id="p3">&lt;/code&gt;</ept> is after <bpt id="p4">&lt;code&gt;</bpt><ph id="ph5">n2</ph><ept id="p4">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The two nodes do not share a common ancestor.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Creates an <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> for this node.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>You typically use this method when you have to supply another component with an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can create an <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> from a <ph id="ph2">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> tree, and then pass that reader to <ph id="ph3">&lt;xref:System.Xml.XmlDocument.Load%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>All of the readers returned by <ph id="ph1">&lt;xref:System.Xml.XmlReader.Create%2A&gt;</ph> are normalizing readers.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>They always perform line break normalization and full normalization of attributes.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.CreateReader%2A&gt;</ph> is not a normalizing reader.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not transform any white space.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also returns attributes in the order that they were added, not in attribute name order.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> does not keep information about whether attributes are default attributes.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlReader.IsDefault%2A&gt;</ph> will always return false regardless of whether the attribute was populated from a default value or not.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>The the <ph id="ph1">`PUBLIC`</ph> and <ph id="ph2">`SYSTEM`</ph> pseudo attributes on <ph id="ph3">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> are not available through the <ph id="ph4">&lt;xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>They are only available through the <ph id="ph1">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=fullName&gt;</ph> method that takes the qualified name of the attribute as a parameter.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have to retrieve the <ph id="ph1">`PUBLIC`</ph> or <ph id="ph2">`SYSTEM`</ph> attributes, you should use the <ph id="ph3">&lt;xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>Base64 and BinHex data are not supported.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you attempt to retrieve these types of data (for example, by calling <ph id="ph1">&lt;xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A&gt;</ph>), the reader will throw <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`xml`</ph> declaration is not surfaced by the reader.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>While reading, you will not encounter a node of type <ph id="ph1">&lt;xref:System.Xml.XmlNodeType.XmlDeclaration&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> that can be used to read this node and its descendants.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Creates an <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> with the options specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">readerOptions</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.ReaderOptions"&gt;&lt;/xref&gt;</ph> object that specifies whether to omit duplicate namespaces.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Compares the values of two nodes, including the values of all descendant nodes.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following criteria determine whether two nodes are equal:</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">`null`</ph> node is equal to another <ph id="ph2">`null`</ph> node but unequal to a non-<ph id="ph3">`null`</ph> node.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects of different types are never equal.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XText&gt;</ph> nodes are equal if they contain the same text.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> nodes are equal if their root nodes are equal.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XComment&gt;</ph> nodes are equal if they contain the same comment text.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XProcessingInstruction&gt;</ph> nodes are equal if they have the same target and data.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two <ph id="ph1">&lt;xref:System.Xml.Linq.XDocumentType&gt;</ph> nodes are equal if the have the same name, public ID, system ID, and internal subset.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The first <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> to compare.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The second <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> to compare.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the nodes are equal; otherwise <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Gets a comparer that can compare the relative position of two nodes.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is primarily used internally for implementing the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt;</ph> extension method.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended approach is to use that extension method instead of using this property directly.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XNodeDocumentOrderComparer"&gt;&lt;/xref&gt;</ph> that can compare the relative position of two nodes.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Returns a collection of the sibling elements after this node, in document order.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method only includes siblings in the returned collection.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not include descendants.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of the sibling elements after this node, in document order.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Returns a filtered collection of the sibling elements after this node, in document order.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method only includes siblings in the returned collection.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not include descendants.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> to match.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of the sibling elements after this node, in document order.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Returns a collection of the sibling elements before this node, in document order.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method only includes siblings in the returned collection.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not include descendants.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of the sibling elements before this node, in document order.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Returns a filtered collection of the sibling elements before this node, in document order.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method only includes siblings in the returned collection.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not include descendants.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> to match.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XElement"&gt;&lt;/xref&gt;</ph> of the sibling elements before this node, in document order.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Only elements that have a matching <ph id="ph1">&lt;xref href="System.Xml.Linq.XName"&gt;&lt;/xref&gt;</ph> are included in the collection.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Gets a comparer that can compare two nodes for value equality.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.XNodeEqualityComparer"&gt;&lt;/xref&gt;</ph> that can compare two nodes for value equality.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Determines if the current node appears after a specified node in terms of document order.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this method might affect your performance.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> to compare for document order.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this node appears after the specified node; otherwise <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Determines if the current node appears before a specified node in terms of document order.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.IsBefore%2A&gt;</ph> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this method might affect your performance.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> to compare for document order.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this node appears before the specified node; otherwise <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Gets the next sibling node of this node.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no next node, this property returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> that contains the next sibling node.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Returns a collection of the sibling nodes after this node, in document order.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method only includes siblings in the returned collection.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not include descendants.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> of the sibling nodes after this node, in document order.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Returns a collection of the sibling nodes before this node, in document order.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method only includes siblings in the returned collection.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not include descendants.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses deferred execution.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerable`1"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> of the sibling nodes before this node, in document order.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Gets the previous sibling node of this node.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> does not have a parent, or if there is no previous node, this property returns <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.PreviousNode%2A&gt;</ph> property must traverse the list of direct child nodes under the parent container.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this property might affect your performance.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> that contains the previous sibling node.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Creates an <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> from an <ph id="ph2">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method enables you to process arbitrarily large XML files with a very small memory footprint.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reader that you pass to this method might throw exceptions.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <ph id="ph2">&lt;xref:System.Xml.Linq.XNode.ReadFrom%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>In particular, your code should be prepared to handle <ph id="ph1">&lt;xref:System.Xml.XmlException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example of how to stream a more complex document, see <bpt id="p1">[</bpt>How to: Stream XML Fragments with Access to Header Information<ept id="p1">](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092)</ept>.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Certain standard query operators, such as <ph id="ph1">&lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;</ph>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an example of using <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> to transform extremely large XML documents while maintaining a small memory footprint, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> positioned at the node to read into this <ph id="ph2">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.Linq.XNode"&gt;&lt;/xref&gt;</ph> that contains the node and its descendant nodes that were read from the reader.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The runtime type of the node is determined by the node type (<ph id="ph1">&lt;xref href="System.Xml.Linq.XObject.NodeType"&gt;&lt;/xref&gt;</ph>) of the first node encountered in the reader.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> is not positioned on a recognized node type.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The underlying <ph id="ph1">&lt;xref href="System.Xml.XmlReader"&gt;&lt;/xref&gt;</ph> throws an exception.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Removes this node from its parent.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>In <ph id="ph1">[!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]</ph> programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>In practical terms, this means that you should not iterate over a set of nodes and remove them.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, you should materialize them into a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Linq.Enumerable.ToList%2A&gt;</ph> extension method.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Then, you can iterate over the list to remove the nodes.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)</ept>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>Alternatively, if you want to remove a set of nodes, it is recommended that you use the <ph id="ph1">&lt;xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method copies the nodes to a list, and then iterates over the list to remove the nodes.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.Remove%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this method might affect your performance.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The parent is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Replaces this node with the specified content.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this method might affect your performance.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Content that replaces this node.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Replaces this node with the specified content.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XContainer&gt;</ph> stores its child nodes as a singly-linked list of <ph id="ph2">&lt;xref:System.Xml.Linq.XNode&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ReplaceWith%2A&gt;</ph> method must traverse the list of direct child nodes under the parent container.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using this method might affect your performance.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>For details about the valid content that can be passed to this method, see <bpt id="p1">[</bpt>Valid Content of XElement and XDocument Objects<ept id="p1">](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)</ept>.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method will raise the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> and the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> events.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>A parameter list of the new content.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Returns the indented XML for this node.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> containing the indented XML.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Returns the XML for this node, optionally disabling formatting.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Xml.Linq.SaveOptions"&gt;&lt;/xref&gt;</ph> that specifies formatting behavior.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> containing the XML.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Writes this node to an <ph id="ph1">&lt;xref href="System.Xml.XmlWriter"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this method to write code that does a streaming transform of a very large document.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Perform Streaming Transform of Large XML Documents<ept id="p1">](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73)</ept>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Xml.XmlWriter"&gt;&lt;/xref&gt;</ph> into which this method will write.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>