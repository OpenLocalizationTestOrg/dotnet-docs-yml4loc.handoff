<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a62b3e36cbd9ec5893ad4eb4888f526e6a21aa6d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Threading.LazyThreadSafetyMode.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ef5182b0865fb3ae2a7e55d59212b26525c94c7</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c4e5793b9819b977c8d825405fc8fe1410e86f3c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Specifies how a <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance synchronizes access among multiple threads.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this enumeration to specify the <ph id="ph1">`mode`</ph> parameter of <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> constructors.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The effects of all constructors on thread synchronization can be described in terms of this enumeration, whether or not they have <ph id="ph1">`mode`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance is initialized either by a user-specified initialization method or by the default constructor for <ph id="ph2">`T`</ph>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initialization method is specified by the <ph id="ph1">`valueFactory`</ph> parameter of a <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method returns an instance of <ph id="ph1">`T`</ph>, which is the type that is lazily instantiated by the instance of <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a constructor does not have a <ph id="ph1">`valueFactory`</ph> parameter, the default constructor for <ph id="ph2">`T`</ph> is used to initialize the <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either case, initialization occurs the first time you call the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to specifying the thread safety of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance, this enumeration affects exception caching.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>When exceptions are cached for a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance, you get only one chance to initialize the instance.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an exception is thrown the first time you call the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=fullName&gt;</ph> property, that exception is cached and rethrown on all subsequent calls to the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The advantage of caching exceptions is that any two threads always get the same result, even when errors occur.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you specify the PublicationOnly mode, exceptions are never cached.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you specify None or ExecutionAndPublication, caching depends on whether you specify an initialization method or allow the default constructor for <ph id="ph1">`T`</ph> to be used.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying an initialization method enables exception caching for these two modes.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The initialization method can be very simple.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, it might call the default constructor for <ph id="ph1">`T`</ph>: <ph id="ph2">`new Lazy&lt;Contents&gt;(() =&gt; new Contents(), mode)`</ph> in C#, or <ph id="ph3">`New Lazy(Of Contents)(Function() New Contents())`</ph> in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use a constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <ph id="ph1">`T`</ph> are not cached.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table summarizes exception caching behavior.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mode</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using initialization method</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using default constructor for <ph id="ph1">`T`</ph></source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>None</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cached</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not cached</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>PublicationOnly</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not cached</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not cached</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>ExecutionAndPublication</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Cached</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>Not cached</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize a <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance in a thread-safe manner.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If the initialization method (or the default constructor, if there is no initialization method) uses locks internally, deadlocks can occur.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>If you use a <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> constructor that specifies an initialization method (<bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">valueFactory</ph><ept id="p1">&lt;/code&gt;</ept> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <ph id="ph3">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property, then the exception is cached and thrown again on subsequent calls to the <ph id="ph4">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you use a <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">T</ph><ept id="p1">&lt;/code&gt;</ept> are not cached.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>In that case, a subsequent call to the <ph id="ph1">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property might successfully initialize the <ph id="ph2">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the initialization method recursively accesses the <ph id="ph1">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property of the <ph id="ph2">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance, an <ph id="ph3">&lt;xref href="System.InvalidOperationException"&gt;&lt;/xref&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance is not thread safe; if the instance is accessed from multiple threads, its behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Use this mode only when high performance is crucial and the <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance is guaranteed never to be initialized from more than one thread.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If you use a <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> constructor that specifies an initialization method (<bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">valueFactory</ph><ept id="p1">&lt;/code&gt;</ept> parameter), and if that initialization method throws an exception (or fails to handle an exception) the first time you call the <ph id="ph3">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property, then the exception is cached and thrown again on subsequent calls to the <ph id="ph4">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If you use a <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">T</ph><ept id="p1">&lt;/code&gt;</ept> are not cached.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In that case, a subsequent call to the <ph id="ph1">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property might successfully initialize the <ph id="ph2">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If the initialization method recursively accesses the <ph id="ph1">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property of the <ph id="ph2">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance, an <ph id="ph3">&lt;xref href="System.InvalidOperationException"&gt;&lt;/xref&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>When multiple threads try to initialize a <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance simultaneously, all threads are allowed to run the initialization method (or the default constructor, if there is no initialization method).</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The first thread to complete initialization sets the value of the <ph id="ph1">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>That value is returned to any other threads that were simultaneously running the initialization method, unless the initialization method throws exceptions on those threads.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Any instances of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">T</ph><ept id="p1">&lt;/code&gt;</ept> that were created by the competing threads are discarded.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the initialization method throws an exception on any thread, the exception is propagated out of the <ph id="ph1">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property on that thread.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The exception is not cached.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The value of the <ph id="ph1">&lt;xref href="System.Lazy`1.IsValueCreated"&gt;&lt;/xref&gt;</ph> property remains <ph id="ph2">`false`</ph>, and subsequent calls to the <ph id="ph3">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property, either by the thread where the exception was thrown or by other threads, cause the initialization method to run again.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If the initialization method recursively accesses the <ph id="ph1">&lt;xref href="System.Lazy`1.Value"&gt;&lt;/xref&gt;</ph> property of the <ph id="ph2">&lt;xref href="System.Lazy`1"&gt;&lt;/xref&gt;</ph> instance, no exception is thrown.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>