<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">61df740eff06dbd8a7d3a52d3718a2baa6ac9748</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Double.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">94dc5ce26854ad6195488353c7bf7c67bed7472e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64e135d9932679640dc69c6a1f79d214bdcfbe0b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a double-precision floating-point number.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double&gt;</ph> value type represents a double-precision 64-bit number with values ranging from negative 1.79769313486232e308 to positive 1.79769313486232e308, as well as positive or negative zero, <ph id="ph2">&lt;xref:System.Double.PositiveInfinity&gt;</ph>, <ph id="ph3">&lt;xref:System.Double.NegativeInfinity&gt;</ph>, and not a number (<ph id="ph4">&lt;xref:System.Double.NaN&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is intended to represent values that are extremely large (such as distances between planets or galaxies) or extremely small (the molecular mass of a substance in kilograms) and that often are imprecise (such as the distance from earth to another solar system), The <ph id="ph1">&lt;xref:System.Double&gt;</ph> type complies with the IEC 60559:1989 (IEEE 754) standard for binary floating-point arithmetic.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>This topic consists of the following sections:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Floating-point representation and precision<ept id="p1">](#Precision)</ept></source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Testing for equality<ept id="p1">](#Equality)</ept></source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Floating-point values and exceptions<ept id="p1">](#Exceptions)</ept></source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Type conversions and the Double structure<ept id="p1">](#Conversions)</ept></source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Floating-point functionality<ept id="p1">](#Functionality)</ept></source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-Point Representation and Precision</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type stores double-precision floating-point values in a 64-bit binary format, as shown in the following table:</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Part</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bits</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Significand or mantissa</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>0-51</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Exponent</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>52-62</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sign (0 = Positive, 1 = Negative)</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>63</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Just as decimal fractions are unable to precisely represent some fractional values (such as 1/3 or <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=fullName&gt;</ph>), binary fractions are unable to represent some fractional values.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, 1/10, which is represented precisely by .1 as a decimal fraction, is represented by .001100110011 as a binary fraction, with the pattern "0011" repeating to infinity.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the floating-point value provides an imprecise representation of the number that it represents.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performing additional mathematical operations on the original floating-point value often tends to increase its lack of precision.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if we compare the result of multiplying .1 by 10 and adding .1 to .1 nine times, we see that addition, because it has involved eight more operations, has produced the less precise result.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this disparity is apparent only if we display the two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values by using the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, which if necessary displays all 17 digits of precision supported by the <ph id="ph2">&lt;xref:System.Double&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because some numbers cannot be represented exactly as fractional binary values, floating-point numbers can only approximate real numbers.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>All floating-point numbers also have a limited number of significant digits, which also determines how accurately a floating-point value approximates a real number.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Double&gt;</ph> value has up to 15 decimal digits of precision, although a maximum of 17 digits is maintained internally.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that some floating-point operations may lack the precision to change a floating point value.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a very large floating-point value, and then adds the product of <ph id="ph1">&lt;xref:System.Double.Epsilon?displayProperty=fullName&gt;</ph> and one quadrillion to it.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>The product, however, is too small to modify the original floating-point value.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its least significant digit is thousandths, whereas the most significant digit in the product is 1<bpt id="p1">&lt;sup&gt;</bpt>-312<ept id="p1">&lt;/sup&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The limited precision of a floating-point number has several consequences:</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two floating-point numbers that appear equal for a particular precision might not compare equal because their least significant digits are different.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, a series of numbers are added together, and their total is compared with their expected total.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the two values appear to be the same, a call to the <ph id="ph1">`Equals`</ph> method indicates that they are not.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you change the format items in the <ph id="ph1">&lt;xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=fullName&gt;</ph> statement from <ph id="ph2">`{0}`</ph> and <ph id="ph3">`{1}`</ph> to <ph id="ph4">`{0:R}`</ph> and <ph id="ph5">`{1:R}`</ph> to display all significant digits of the two <ph id="ph6">&lt;xref:System.Double&gt;</ph> values, it is clear that the two values are unequal because of a loss of precision during the addition operations.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the issue can be resolved by calling the <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=fullName&gt;</ph> method to round the <ph id="ph2">&lt;xref:System.Double&gt;</ph> values to the desired precision before performing the comparison.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>A mathematical or comparison operation that uses a floating-point number might not yield the same result if a decimal number is used, because the binary floating-point number might not equal the decimal number.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>A previous example illustrated this by displaying the result of multiplying .1 by 10 and adding .1 times.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>When accuracy in numeric operations with fractional values is important, you can use the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> rather than the <ph id="ph2">&lt;xref:System.Double&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>When accuracy in numeric operations with integral values beyond the range of the <ph id="ph1">&lt;xref:System.Int64&gt;</ph> or <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> types is important, use the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value might not round-trip if a floating-point number is involved.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>A value is said to round-trip if an operation converts an original floating-point number to another form, an inverse operation transforms the converted form back to a floating-point number, and the final floating-point number is not equal to the original floating-point number.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>The roundtrip might fail because one or more least significant digits are lost or changed in a conversion.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, three <ph id="ph1">&lt;xref:System.Double&gt;</ph> values are converted to strings and saved in a file.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output shows, however, even though the values appear to be identical, the restored values are not equal to the original values.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#7<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#7<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the values can be successfully round-tripped by using the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> to preserve the full precision of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#8<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#8<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Single&gt;</ph> values have less precision than <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Single&gt;</ph> value that is converted to a seemingly equivalent <ph id="ph2">&lt;xref:System.Double&gt;</ph> often does not equal the <ph id="ph3">&lt;xref:System.Double&gt;</ph> value because of differences in precision.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, the result of identical division operations is assigned to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> and a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value is cast to a <ph id="ph2">&lt;xref:System.Double&gt;</ph>, a comparison of the two values shows that they are unequal.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>To avoid this problem, use either the <ph id="ph1">&lt;xref:System.Double&gt;</ph> in place of the <ph id="ph2">&lt;xref:System.Single&gt;</ph> data type, or use the <ph id="ph3">&lt;xref:System.Math.Round%2A&gt;</ph> method so that both values have the same precision.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the result of arithmetic and assignment operations with <ph id="ph1">&lt;xref:System.Double&gt;</ph> values may differ slightly by platform because of the loss of precision of the <ph id="ph2">&lt;xref:System.Double&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the result of assigning a literal <ph id="ph1">&lt;xref:System.Double&gt;</ph> value may differ in the 32-bit and 64-bit versions of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates this difference when the literal value -4.42330604244772E-305 and a variable whose value is -4.42330604244772E-305 are assigned to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> variable.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the result of the <ph id="ph1">&lt;xref:System.Double.Parse%28System.String%29&gt;</ph> method in this case does not suffer from a loss of precision.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Class.Precision#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Class.Precision#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Testing for Equality</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be considered equal, two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values must represent identical values.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because of differences in precision between values, or because of a loss of precision by one or both values, floating-point values that are expected to be identical often turn out to be unequal because of differences in their least significant digits.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a result, calls to the <ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> method to determine whether two values are equal, or calls to the <ph id="ph2">&lt;xref:System.Double.CompareTo%2A&gt;</ph> method to determine the relationship between two <ph id="ph3">&lt;xref:System.Double&gt;</ph> values, often yield unexpected results.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is evident in the following example, where two apparently equal <ph id="ph1">&lt;xref:System.Double&gt;</ph> values turn out to be unequal because the first has 15 digits of precision, while the second has 17.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#9<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#9<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calculated values that follow different code paths and that are manipulated in different ways often prove to be unequal.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, one <ph id="ph1">&lt;xref:System.Double&gt;</ph> value is squared, and then the square root is calculated to restore the original value.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>A second <ph id="ph1">&lt;xref:System.Double&gt;</ph> is multiplied by 3.51 and squared before the square root of the result is divided by 3.51 to restore the original value.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the two values appear to be identical, a call to the <ph id="ph1">&lt;xref:System.Double.Equals%28System.Double%29&gt;</ph> method indicates that they are not equal.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using the "R" standard format string to return a result string that displays all the significant digits of each Double value shows that the second value is .0000000000001 less than the first.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#10<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#10<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>In cases where a loss of precision is likely to affect the result of a comparison, you can adopt any of the following alternatives to calling the <ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.CompareTo%2A&gt;</ph> method:</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Math.Round%2A?displayProperty=fullName&gt;</ph> method to ensure that both values have the same precision.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example modifies a previous example to use this approach so that two fractional values are equivalent.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#11<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#11<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note, though, that the problem of precision still applies to rounding of midpoint values.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Test for approximate equality rather than equality.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>This requires that you define either an absolute amount by which the two values can differ but still be equal, or that you define a relative amount by which the smaller value can diverge from the larger value.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double.Epsilon?displayProperty=fullName&gt;</ph> is sometimes used as an absolute measure of the distance between two <ph id="ph2">&lt;xref:System.Double&gt;</ph> values when testing for equality.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">&lt;xref:System.Double.Epsilon?displayProperty=fullName&gt;</ph> measures the smallest possible value that can be added to, or subtracted from, a <ph id="ph2">&lt;xref:System.Double&gt;</ph> whose value is zero.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>For most positive and negative <ph id="ph1">&lt;xref:System.Double&gt;</ph> values, the value of <ph id="ph2">&lt;xref:System.Double.Epsilon?displayProperty=fullName&gt;</ph> is too small to be detected.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, except for values that are zero, we do not recommend its use in tests for equality.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the latter approach to define an <ph id="ph1">`IsApproximatelyEqual`</ph> method that tests the relative difference between two values.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also contrasts the result of calls to the <ph id="ph1">`IsApproximatelyEqual`</ph> method and the <ph id="ph2">&lt;xref:System.Double.Equals%28System.Double%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#12<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#12<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-Point Values and Exceptions</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike operations with integral types, which throw exceptions in cases of overflow or illegal operations such as division by zero, operations with floating-point values do not throw exceptions.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, in exceptional situations, the result of a floating-point operation is zero, positive infinity, negative infinity, or not a number (NaN):</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the result of a floating-point operation is too small for the destination format, the result is zero.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can occur when two very small numbers are multiplied, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the magnitude of the result of a floating-point operation exceeds the range of the destination format, the result of the operation is <ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity&gt;</ph>, as appropriate for the sign of the result.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result of an operation that overflows <ph id="ph1">&lt;xref:System.Double.MaxValue?displayProperty=fullName&gt;</ph> is <ph id="ph2">&lt;xref:System.Double.PositiveInfinity&gt;</ph>, and the result of an operation that overflows <ph id="ph3">&lt;xref:System.Double.MinValue?displayProperty=fullName&gt;</ph> is <ph id="ph4">&lt;xref:System.Double.NegativeInfinity&gt;</ph>, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> also results from a division by zero with a positive dividend, and <ph id="ph2">&lt;xref:System.Double.NegativeInfinity&gt;</ph> results from a division by zero with a negative dividend.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a floating-point operation is invalid, the result of the operation is <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> results from the following operations:</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Division by zero with a dividend of zero.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that other cases of division by zero result in either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any floating-point operation with an invalid input.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, calling the <ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=fullName&gt;</ph> method with a negative value returns <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph>, as does calling the <ph id="ph3">&lt;xref:System.Math.Acos%2A?displayProperty=fullName&gt;</ph> method with a value that is greater than one or less than negative one.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any operation with an argument whose value is <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type conversions and the Double structure</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double&gt;</ph> structure does not define any explicit or implicit conversion operators; instead, conversions are implemented by the compiler.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion of the value of any primitive numeric type to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> is a widening conversion and therefore does not require an explicit cast operator or call to a conversion method unless a compiler explicitly requires it.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# compiler requires a casting operator for conversions from <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> to <ph id="ph2">&lt;xref:System.Double&gt;</ph>, while the Visual Basic compiler does not.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example converts the minimum or maximum value of other primitive numeric types to a <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#20<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#20<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Single&gt;</ph> values <ph id="ph2">&lt;xref:System.Single.NaN?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Single.PositiveInfinity?displayProperty=fullName&gt;</ph>, and <ph id="ph4">&lt;xref:System.Single.NegativeInfinity?displayProperty=fullName&gt;</ph> covert to <ph id="ph5">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>, <ph id="ph6">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, and <ph id="ph7">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>, respectively.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the conversion of the value of some numeric types to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value can involve a loss of precision.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the example illustrates, a loss of precision is possible when converting <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>, <ph id="ph2">&lt;xref:System.Int64&gt;</ph>, <ph id="ph3">&lt;xref:System.Single&gt;</ph>, and <ph id="ph4">&lt;xref:System.UInt64&gt;</ph> values to <ph id="ph5">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value to a value of any other primitive numeric data type is a narrowing conversion and requires a cast operator (in C#), a conversion method (in Visual Basic), or a call to a <ph id="ph2">&lt;xref:System.Convert&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Values that are outside the range of the target data type, which are defined by the target type's <ph id="ph1">`MinValue`</ph> and <ph id="ph2">`MaxValue`</ph> properties, behave as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Target type</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Result</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any integral type</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> exception if the conversion occurs in a checked context.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion occurs in an unchecked context (the default in C#), the conversion operation succeeds but the value overflows.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Single.NegativeInfinity?displayProperty=fullName&gt;</ph> for negative values.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Single.PositiveInfinity?displayProperty=fullName&gt;</ph> for positive values.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph> throw an <ph id="ph4">&lt;xref:System.OverflowException&gt;</ph> for conversions to integers in a checked context, but these values overflow when converted to integers in an unchecked context.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>For conversions to <ph id="ph1">&lt;xref:System.Decimal&gt;</ph>, they always throw an <ph id="ph2">&lt;xref:System.OverflowException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>For conversions to <ph id="ph1">&lt;xref:System.Single&gt;</ph>, they convert to <ph id="ph2">&lt;xref:System.Single.NaN?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Single.PositiveInfinity?displayProperty=fullName&gt;</ph>, and <ph id="ph4">&lt;xref:System.Single.NegativeInfinity?displayProperty=fullName&gt;</ph>, respectively.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that a loss of precision may result from converting a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value to another numeric type.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the case of converting non-integral <ph id="ph1">&lt;xref:System.Double&gt;</ph> values, as the output from the example shows, the fractional component is lost when the <ph id="ph2">&lt;xref:System.Double&gt;</ph> value is either rounded (as in Visual Basic) or truncated (as in C#).</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>For conversions to <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> and <ph id="ph2">&lt;xref:System.Single&gt;</ph> values, the <ph id="ph3">&lt;xref:System.Double&gt;</ph> value may not have a precise representation in the target data type.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example converts a number of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values to several other numeric types.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversions occur in a checked context in Visual Basic (the default) and in C# (because of the <bpt id="p1">[</bpt>checked<ept id="p1">](~/docs/csharp/language-reference/keywords/checked.md)</ept> keyword).</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>The output from the example shows the result for conversions in both a checked an unchecked context.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can perform conversions in an unchecked context in Visual Basic by compiling with the <ph id="ph1">`/removeintchecks+`</ph> compiler switch and in C# by commenting out the <ph id="ph2">`checked`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#21<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#21<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on the conversion of numeric types, see <bpt id="p1">[</bpt>Type Conversion in the .NET Framework<ept id="p1">](~/docs/standard/base-types/type-conversion.md)</ept> and <bpt id="p2">[</bpt>Type Conversion Tables<ept id="p2">](~/docs/standard/base-types/conversion-tables.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-Point Functionality</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double&gt;</ph> structure and related types provide methods to perform operations in the following areas:</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Comparison of values<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> method to determine whether two <ph id="ph2">&lt;xref:System.Double&gt;</ph> values are equal, or the <ph id="ph3">&lt;xref:System.Double.CompareTo%2A&gt;</ph> method to determine the relationship between two values.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double&gt;</ph> structure also supports a complete set of comparison operators.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can test for equality or inequality, or determine whether one value is greater than or equal to another.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If one of the operands is a numeric type other than a <ph id="ph1">&lt;xref:System.Double&gt;</ph>, it is converted to a <ph id="ph2">&lt;xref:System.Double&gt;</ph> before performing the comparison.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of differences in precision, two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values that you expect to be equal may turn out to be unequal, which affects the result of the comparison.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <bpt id="p1">[</bpt>Testing for Equality<ept id="p1">](#Equality)</ept> section for more information about comparing two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also call the <ph id="ph1">&lt;xref:System.Double.IsNaN%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.IsInfinity%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Double.IsPositiveInfinity%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Double.IsNegativeInfinity%2A&gt;</ph> methods to test for these special values.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Mathematical operations<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>Common arithmetic operations, such as addition, subtraction, multiplication, and division, are implemented by language compilers and Common Intermediate Language (CIL) instructions, rather than by <ph id="ph1">&lt;xref:System.Double&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>If one of the operands in a mathematical operation is a numeric type other than a <ph id="ph1">&lt;xref:System.Double&gt;</ph>, it is converted to a <ph id="ph2">&lt;xref:System.Double&gt;</ph> before performing the operation.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result of the operation is also a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>Other mathematical operations can be performed by calling <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) methods in the <ph id="ph3">&lt;xref:System.Math?displayProperty=fullName&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>It includes additional methods commonly used for arithmetic (such as <ph id="ph1">&lt;xref:System.Math.Abs%2A?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Math.Sign%2A?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Math.Sqrt%2A?displayProperty=fullName&gt;</ph>), geometry (such as <ph id="ph4">&lt;xref:System.Math.Cos%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Math.Sin%2A?displayProperty=fullName&gt;</ph>), and calculus (such as <ph id="ph6">&lt;xref:System.Math.Log%2A?displayProperty=fullName&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also manipulate the individual bits in a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=fullName&gt;</ph> method preserves a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value's bit pattern in a 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=fullName&gt;</ph> method returns its bit pattern in a byte array.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Rounding<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>Rounding is often used as a technique for reducing the impact of differences between values caused by problems of floating-point representation and precision.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can round a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value by calling the <ph id="ph2">&lt;xref:System.Math.Round%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Formatting<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can convert a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value to its string representation by calling the <ph id="ph2">&lt;xref:System.Double.ToString%2A&gt;</ph> method or by using the composite formatting feature.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about how format strings control the string representation of floating-point values, see the <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> topics.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Parsing strings<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can convert the string representation of a floating-point value to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value by calling either the <ph id="ph2">&lt;xref:System.Double.Parse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Double.TryParse%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the parse operation fails, the <ph id="ph1">&lt;xref:System.Double.Parse%2A&gt;</ph> method throws an exception, whereas the <ph id="ph2">&lt;xref:System.Double.TryParse%2A&gt;</ph> method returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Type conversion<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double&gt;</ph> structure provides an explicit interface implementation for the <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface, which supports conversion between any two standard .NET Framework data types.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>Language compilers also support the implicit conversion of values of all other standard numeric types to <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>Conversion of a value of any standard numeric type to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> is a widening conversion and does not require the user of a casting operator or conversion method,</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, conversion of <ph id="ph1">&lt;xref:System.Int64&gt;</ph> and <ph id="ph2">&lt;xref:System.Single&gt;</ph> values can involve a loss of precision.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the differences in precision for each of these types:</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>Maximum precision</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>Internal precision</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>15</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>17</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>19 decimal digits</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>19 decimal digits</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>7 decimal digits</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>9 decimal digits</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>The problem of precision most frequently affects <ph id="ph1">&lt;xref:System.Single&gt;</ph> values that are converted to <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, two values produced by identical division operations are unequal because one of the values is a a single-precision floating point value converted to a <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Structure#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Structure#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Compares this instance to a specified double-precision floating-point number and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified double-precision floating-point number.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>Values must be identical to be considered equal.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>Particularly when floating-point values depend on multiple mathematical operations, it is common for them to lose precision and for their values to be nearly identical except for their least significant digits.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of this, the return value of the <ph id="ph1">&lt;xref:System.Double.CompareTo%2A&gt;</ph> method at times may seem surprising.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, multiplication by a particular value followed by division by the same value should produce the original value.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, however, the computed value turns out to be greater than the original value.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Showing all significant digits of the two values by using the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> indicates that the computed value differs from the original value in its least significant digits.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on handling such comparisons, see the Remarks section of the <ph id="ph1">&lt;xref:System.Double.Equals%28System.Double%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.CompareTo#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.CompareTo#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=fullName&gt;</ph> interface and performs slightly better than the <ph id="ph2">&lt;xref:System.Double.CompareTo%2A?displayProperty=fullName&gt;</ph> method because it does not have to convert the <ph id="ph3">`value`</ph> parameter to an object.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that, although an object whose value is <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> is not considered equal to another object whose value is <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph> (even itself), the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interface requires that <ph id="ph4">`A.CompareTo(A)`</ph> return zero.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Widening Conversions</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on your programming language, it might be possible to code a <ph id="ph1">&lt;xref:System.Double.CompareTo%2A&gt;</ph> method where the parameter type has fewer bits (is narrower) than the instance type.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is possible because some programming languages perform an implicit widening conversion that represents the parameter as a type with as many bits as the instance.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose the instance type is <ph id="ph1">&lt;xref:System.Double&gt;</ph> and the parameter type is <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Microsoft C# compiler generates instructions to represent the value of the parameter as a <ph id="ph1">&lt;xref:System.Double&gt;</ph> object, then generates a <ph id="ph2">&lt;xref:System.Double.CompareTo%28System.Double%29?displayProperty=fullName&gt;</ph> method that compares the values of the instance and the widened representation of the parameter.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consult your programming language's documentation to determine if its compiler performs implicit widening conversions of numeric types.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Conversion Tables<ept id="p1">](~/docs/standard/base-types/conversion-tables.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precision in Comparisons</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number to compare.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>A signed number indicating the relative values of this instance and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>This instance is less than <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>This instance is not a number (<ph id="ph1">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>) and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> is a number.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>This instance is equal to <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Both this instance and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> are not a number (<ph id="ph2">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>), <ph id="ph3">&lt;xref href="System.Double.PositiveInfinity"&gt;&lt;/xref&gt;</ph>, or <ph id="ph4">&lt;xref href="System.Double.NegativeInfinity"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>This instance is greater than <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>This instance is a number and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not a number (<ph id="ph2">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter must be <ph id="ph2">`null`</ph> or an instance of <ph id="ph3">`Double`</ph>; otherwise, an exception is thrown.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any instance of <ph id="ph1">&lt;xref:System.Double&gt;</ph>, regardless of its value, is considered greater than <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>Values must be identical to be considered equal.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Particularly when floating-point values depend on multiple mathematical operations, it is common for them to lose precision and for their values to be nearly identical except for their least significant digits.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of this, the return value of the <ph id="ph1">&lt;xref:System.Double.CompareTo%2A&gt;</ph> method at times may seem surprising.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, multiplication by a particular value followed by division by the same value should produce the original value.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, however, the computed value turns out to be greater than the original value.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>Showing all significant digits of the two values by using the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> indicates that the computed value differs from the original value in its least significant digits.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on handling such comparisons, see the Remarks section of the <ph id="ph1">&lt;xref:System.Double.Equals%28System.Double%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.CompareTo#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.CompareTo#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is implemented to support the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that, although a <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> is not considered to be equal to another <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph> (even itself), the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface requires that <ph id="ph4">`A.CompareTo(A)`</ph> return zero.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precision in Comparisons</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>An object to compare, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>A signed number indicating the relative values of this instance and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>A negative integer</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>This instance is less than <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>This instance is not a number (<ph id="ph1">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>) and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> is a number.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>This instance is equal to <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>This instance and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> are both <ph id="ph2">`Double.NaN`</ph>, <ph id="ph3">&lt;xref href="System.Double.PositiveInfinity"&gt;&lt;/xref&gt;</ph>, or <ph id="ph4">&lt;xref href="System.Double.NegativeInfinity"&gt;&lt;/xref&gt;</ph></source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>A positive integer</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>This instance is greater than <ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>This instance is a number and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is not a number (<ph id="ph2">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Represents the smallest positive <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value that is greater than zero.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>This field is constant.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> property reflects the smallest positive <ph id="ph2">&lt;xref:System.Double&gt;</ph> value that is significant in numeric operations or comparisons when the value of the <ph id="ph3">&lt;xref:System.Double&gt;</ph> instance is zero.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the following code shows that zero and <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> are considered to be unequal values, whereas zero and half the value of <ph id="ph2">&lt;xref:System.Double.Epsilon&gt;</ph> are considered to be equal.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Epsilon#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Epsilon#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>More precisely, the floating point format consists of a sign, a 52-bit mantissa or significand, and an 11-bit exponent.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the following example shows, zero has an exponent of -1022 and a mantissa of 0.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> has an exponent of -1022 and a mantissa of 1.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> is the smallest positive <ph id="ph2">&lt;xref:System.Double&gt;</ph> value greater than zero and represents the smallest possible value and the smallest possible increment for a <ph id="ph3">&lt;xref:System.Double&gt;</ph> whose exponent is -1022.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Epsilon#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Epsilon#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> property is not a general measure of precision of the <ph id="ph2">&lt;xref:System.Double&gt;</ph> type; it applies only to <ph id="ph3">&lt;xref:System.Double&gt;</ph> instances that have a value of zero or an exponent of -1022.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> property is not equivalent to machine epsilon, which represents the upper bound of the relative error due to rounding in floating-point arithmetic.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this constant is 4.94065645841247e-324.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two apparently equivalent floating-point numbers might not compare equal because of differences in their least significant digits.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the C# expression, <ph id="ph1">`(double)1/3 == (double)0.33333`</ph>, does not compare equal because the division operation on the left side has maximum precision while the constant on the right side is precise only to the specified digits.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you create a custom algorithm that determines whether two floating-point numbers can be considered equal, we do not recommend that you base your algorithm on the value of the <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> constant to establish the acceptable absolute margin of difference for the two values to be considered equal.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Typically, that margin of difference is many times greater than <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph>.) For information about comparing two double-precision floating-point values, see <ph id="ph2">&lt;xref:System.Double&gt;</ph> and <ph id="ph3">&lt;xref:System.Double.Equals%28System.Double%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>Platform Notes</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>On ARM systems, the value of the <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> constant is too small to be detected, so it equates to zero.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can define an alternative epsilon value that equals 2.2250738585072014E-308 instead.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Returns a value indicating whether this instance and a specified <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> object represent the same value.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IEquatable%601?displayProperty=fullName&gt;</ph> interface, and performs slightly better than <ph id="ph2">&lt;xref:System.Double.Equals%2A&gt;</ph> because it does not have to convert the <ph id="ph3">`obj`</ph> parameter to an object.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>Widening Conversions</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on your programming language, it might be possible to code a <ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> method where the parameter type has fewer bits (is narrower) than the instance type.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is possible because some programming languages perform an implicit widening conversion that represents the parameter as a type with as many bits as the instance.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose the instance type is <ph id="ph1">&lt;xref:System.Double&gt;</ph> and the parameter type is <ph id="ph2">&lt;xref:System.Int32&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Microsoft C# compiler generates instructions to represent the value of the parameter as a <ph id="ph1">&lt;xref:System.Double&gt;</ph> object, then generates a <ph id="ph2">&lt;xref:System.Double.Equals%28System.Double%29?displayProperty=fullName&gt;</ph> method that compares the values of the instance and the widened representation of the parameter.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consult your programming language's documentation to determine if its compiler performs implicit widening conversions of numeric types.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <bpt id="p1">[</bpt>Type Conversion Tables<ept id="p1">](~/docs/standard/base-types/conversion-tables.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precision in Comparisons</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> method should be used with caution, because two apparently equivalent values can be unequal due to the differing precision of the two values.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example reports that the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value .333333 and the <ph id="ph2">&lt;xref:System.Double&gt;</ph> value returned by dividing 1 by 3 are unequal.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Epsilon#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Epsilon#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>Rather than comparing for equality, one technique involves defining an acceptable relative margin of difference between two values (such as .001% of one of the values).</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to differences in precision and, therefore, the values are likely to be equal.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses this technique to compare .33333 and 1/3, the two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values that the previous code example found to be unequal.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the values are equal.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Epsilon#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Epsilon#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> defines the minimum expression of a positive value whose range is near zero, the margin of difference between two similar values must be greater than <ph id="ph2">&lt;xref:System.Double.Epsilon&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, it is many times greater than <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of this, we recommend that you do not use <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> when comparing <ph id="ph2">&lt;xref:System.Double&gt;</ph> values for equality.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>A second technique involves comparing the difference between two floating-point numbers with some absolute value.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the difference is less than or equal to that absolute value, the numbers are equal.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it is greater, the numbers are not equal.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>One alternative is to arbitrarily select an absolute value.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is problematic, however, because an acceptable margin of difference depends on the magnitude of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>A second alternative takes advantage of a design feature of the floating-point format: The difference between the integer representation of two floating-point values indicates the number of possible floating-point values that separates them.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the difference between 0.0 and <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> is 1, because <ph id="ph2">&lt;xref:System.Double.Epsilon&gt;</ph> is the smallest representable value when working with a <ph id="ph3">&lt;xref:System.Double&gt;</ph> whose value is zero.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses this technique to compare .33333 and 1/3, which are the two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values that the previous code example with the <ph id="ph2">&lt;xref:System.Double.Equals%28System.Double%29&gt;</ph> method found to be unequal.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the example uses the <ph id="ph1">&lt;xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=fullName&gt;</ph> method to convert a double-precision floating-point value to its integer representation.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Equals#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Equals#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> values are tested for equality by calling the <ph id="ph2">&lt;xref:System.Double.Equals%2A&gt;</ph> method, the method returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if two <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> values are tested for equality by using the equality operator, the operator returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you want to determine whether the value of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> is not a number (NaN), an alternative is to call the <ph id="ph2">&lt;xref:System.Double.IsNaN%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> object to compare to this instance.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> is equal to this instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Returns a value indicating whether this instance is equal to a specified object.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>The<ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> method should be used with caution, because two apparently equivalent values can be unequal due to the differing precision of the two values.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example reports that the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value .3333 and the <ph id="ph2">&lt;xref:System.Double&gt;</ph> returned by dividing 1 by 3 are unequal.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Epsilon#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Epsilon#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>For alternatives to calling the <ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> method, see the documentation for the <ph id="ph2">&lt;xref:System.Double.Equals%28System.Double%29&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph> defines the minimum expression of a positive value whose range is near zero, the margin of difference between two similar values must be greater than <ph id="ph2">&lt;xref:System.Double.Epsilon&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, it is many times greater than <ph id="ph1">&lt;xref:System.Double.Epsilon&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precision of floating-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> values are tested for equality by calling the <ph id="ph2">&lt;xref:System.Double.Equals%2A&gt;</ph> method, the method returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if two <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> values are tested for equality by using the equality operator, the operator returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you want to determine whether the value of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> is not a number (NaN), an alternative is to call the <ph id="ph2">&lt;xref:System.Double.IsNaN%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>An object to compare with this instance.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> is an instance of <ph id="ph3">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> and equals the value of this instance; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Returns the hash code for this instance.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer hash code.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Returns the <ph id="ph1">&lt;xref href="System.TypeCode"&gt;&lt;/xref&gt;</ph> for value type <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The enumerated constant, <ph id="ph1">&lt;xref href="System.TypeCode.Double"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Returns a value indicating whether the specified number evaluates to negative or positive infinity</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity&gt;</ph> to signal an overflow condition.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">d</ph><ept id="p1">&lt;/code&gt;</ept> evaluates to <ph id="ph3">&lt;xref href="System.Double.PositiveInfinity"&gt;&lt;/xref&gt;</ph> or <ph id="ph4">&lt;xref href="System.Double.NegativeInfinity"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph5">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the specified value is not a number (<ph id="ph1">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> to signal that that result of the operation is undefined.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, dividing 0.0 by 0.0 results in <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double.IsNaN%2A&gt;</ph> returns <ph id="ph2">`false`</ph> if a <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is either <ph id="ph4">&lt;xref:System.Double.PositiveInfinity&gt;</ph> or <ph id="ph5">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>To test for these values, use the <ph id="ph1">&lt;xref:System.Double.IsInfinity%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.IsPositiveInfinity%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Double.IsNegativeInfinity%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">d</ph><ept id="p1">&lt;/code&gt;</ept> evaluates to <ph id="ph3">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Returns a value indicating whether the specified number evaluates to negative infinity.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Double.NegativeInfinity&gt;</ph> to signal an overflow condition.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">d</ph><ept id="p1">&lt;/code&gt;</ept> evaluates to <ph id="ph3">&lt;xref href="System.Double.NegativeInfinity"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Returns a value indicating whether the specified number evaluates to positive infinity.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>Floating-point operations return <ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> to signal an overflow condition.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">d</ph><ept id="p1">&lt;/code&gt;</ept> evaluates to <ph id="ph3">&lt;xref href="System.Double.PositiveInfinity"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Represents the largest possible value of a <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>This field is constant.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this constant is positive 1.7976931348623157E+308.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result of an operation that exceeds <ph id="ph1">&lt;xref:System.Double.MaxValue?displayProperty=fullName&gt;</ph> is <ph id="ph2">&lt;xref:System.Double?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, <ph id="ph1">&lt;xref:System.Double?displayProperty=fullName&gt;</ph> results from addition, multiplication, and exponentiation operations when the result exceeds <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.MaxValue#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.MaxValue#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Represents the smallest possible value of a <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>This field is constant.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this constant is negative 1.7976931348623157E+308.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result of an operation that is less than <ph id="ph1">&lt;xref:System.Double.MinValue?displayProperty=fullName&gt;</ph> is <ph id="ph2">&lt;xref:System.Double?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, <ph id="ph1">&lt;xref:System.Double?displayProperty=fullName&gt;</ph> results from subtraction and multiplication operations when the result is less than <ph id="ph2">&lt;xref:System.Double.MinValue?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.MinValue#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.MinValue#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Represents a value that is not a number (<ph id="ph1">`NaN`</ph>).</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>This field is constant.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method or operator returns <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> when the result of an operation is undefined.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the result of dividing zero by zero is <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph>, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>(But note that dividing a non-zero number by zero returns either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity&gt;</ph>, depending on the sign of the divisor.)</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.NaN#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.NaN#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, a method call with a <ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph> value or an operation on a <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph> value returns <ph id="ph3">&lt;xref:System.Double.NaN&gt;</ph>, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.NaN#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.NaN#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Double.IsNaN%2A&gt;</ph> method to determine whether a value is not a number.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.op_Equality%2A&gt;</ph> operator considers two <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph> values to be unequal to one another.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>In general, <ph id="ph1">&lt;xref:System.Double&gt;</ph> operators cannot be used to compare <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> with other <ph id="ph3">&lt;xref:System.Double&gt;</ph> values, although comparison methods (such as <ph id="ph4">&lt;xref:System.Double.Equals%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Double.CompareTo%2A&gt;</ph>) can.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference in behavior between <ph id="ph1">&lt;xref:System.Double&gt;</ph> comparison operators and methods.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.NaN#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.NaN#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Represents negative infinity.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>This field is constant.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this constant is the result of dividing a negative number by zero.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constant is returned when the result of an operation is less than <ph id="ph1">&lt;xref:System.Double.MinValue&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Double.IsNegativeInfinity%2A&gt;</ph> to determine whether a value evaluates to negative infinity.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether two specified <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> values are equal.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.op_Equality%2A&gt;</ph> method defines the equality operator for <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two <ph id="ph1">&lt;xref:System.Double?displayProperty=fullName&gt;</ph> values are tested for equality by using the equality operator, the result is <ph id="ph2">`false`</ph>; two <ph id="ph3">&lt;xref:System.Double?displayProperty=fullName&gt;</ph> values are not considered equal.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>If they are tested for equality by calling the <ph id="ph1">&lt;xref:System.Double.Equals%2A&gt;</ph> method, the result is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you want to determine whether the value of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> is not a number (NaN), an alternative is to call the <ph id="ph2">&lt;xref:System.Double.IsNaN%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value is greater than another specified <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater-than operator for <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value is greater than or equal to another specified <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater-than-or-equal operator for <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than or equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether two specified <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> values are not equal.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.op_Inequality%2A&gt;</ph> method defines the inequality operator for <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are not equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value is less than another specified <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.op_LessThan%2A&gt;</ph> method defines the operation of the less-than operator for <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a specified <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value is less than or equal to another specified <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less-than-or-equal operator for <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than or equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number in a specified culture-specific format to its double-precision floating-point number equivalent.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method is typically used to convert text that can be formatted in a variety of ways to a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, it can be used to convert the text that is entered by a user into an HTML text box to a numeric value.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter is interpreted using a combination of the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flags.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can contain <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, or <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName&gt;</ph> for the culture specified by <ph id="ph5">`provider`</ph>, or it can contain a string of the form:</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>integral-digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>.<ept id="p4">*</ept>[<bpt id="p5">*</bpt>fractional-digits<ept id="p5">*</ept>]][E[<bpt id="p6">*</bpt>sign<ept id="p6">*</ept>]<bpt id="p7">*</bpt>exponential-digits<ept id="p7">*</ept>][<bpt id="p8">*</bpt>ws<ept id="p8">*</ept>]</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional elements are framed in square brackets ([ and ]).</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements that contain the term "digits" consist of a series of numeric characters ranging from 0 to 9.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of white-space characters.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source>A negative sign symbol (-) or a positive sign symbol (+).</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT">
          <source>Runs of <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> can be partitioned by a group-separator symbol.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in some cultures a comma (,) separates groups of thousands.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source>.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>E</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric formats, see the <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept> topic.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies culture-specific information used in interpreting the format of <ph id="ph5">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, it is a <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph> or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> cannot be obtained, the formatting information for the current system culture is used.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Double.Parse%2A?displayProperty=fullName&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Double.ToString%2A?displayProperty=fullName&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is returned.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because of a loss of precision, the values may not be equal.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, attempting to parse the string representation of either <ph id="ph1">&lt;xref:System.Double.MinValue&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph> throws an <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Parse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Parse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>A string that contains a number to convert.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information about <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number that is equivalent to the numeric value or symbol specified in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> does not represent a number in a valid format.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> represents a number that is less than <ph id="ph2">&lt;xref href="System.Double.MinValue"&gt;&lt;/xref&gt;</ph> or greater than <ph id="ph3">&lt;xref href="System.Double.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number in a specified style and culture-specific format to its double-precision floating-point number equivalent.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, thousands separators, and currency symbols) that are allowed in the <ph id="ph2">`s`</ph> parameter for the parse operation to succeed.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members are not supported:</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can contain <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, or <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName&gt;</ph> for the culture specified by <ph id="ph5">`provider`</ph>.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, it can also take the form:</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>] [<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>] [<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>integral-digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>integral-digits<ept id="p5">*</ept>[.[<bpt id="p6">*</bpt>fractional-digits<ept id="p6">*</ept>]][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential-digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements framed in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of white-space characters.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>White space can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific currency symbol.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName&gt;</ph> properties of the current culture.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>A negative sign symbol (-) or a positive sign symbol (+).</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>Parentheses can be used in <ph id="ph1">`s`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>,</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific group separator.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's group separator symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT">
          <source>.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional digits can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>E</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style) always parses successfully.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>The remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> flags affect the elements that may be present in <ph id="ph2">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>NumberStyles value</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements permitted in <ph id="ph1">`s`</ph> in addition to digits</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element only.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>The decimal point (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) and <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> elements.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates exponential notation.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>This flag by itself supports values in the form <bpt id="p1">*</bpt>digits<ept id="p1">*</ept>E<bpt id="p2">*</bpt>digits<ept id="p2">*</ept>; additional flags are needed to successfully parse strings with such elements as positive or negative signs and decimal point symbols.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thousands separator (,) element.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>The currency ($) element.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning or end of <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the beginning of <ph id="ph2">`s`</ph>, and the decimal point (.) symbol.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, thousands separator (,) and decimal point (.) elements.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies culture-specific information used in interpreting the format of <ph id="ph5">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, it is a <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph> or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> cannot be obtained, the formatting information for the current system culture is used.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Double.Parse%2A?displayProperty=fullName&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Double.ToString%2A?displayProperty=fullName&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is returned.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because of a loss of precision, the values may not be equal.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, attempting to parse the string representation of either <ph id="ph1">&lt;xref:System.Double.MinValue&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph> throws an <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Parse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Parse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>A string that contains a number to convert.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>A bitwise combination of enumeration values that indicate the style elements that can be present in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>A typical value to specify is <ph id="ph1">&lt;xref href="System.Globalization.NumberStyles.Float"&gt;&lt;/xref&gt;</ph> combined with <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowThousands"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information about <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number that is equivalent to the numeric value or symbol specified in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> does not represent a numeric value.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> is the <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowHexSpecifier"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> represents a number that is less than <ph id="ph2">&lt;xref href="System.Double.MinValue"&gt;&lt;/xref&gt;</ph> or greater than <ph id="ph3">&lt;xref href="System.Double.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number to its double-precision floating-point number equivalent.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can contain the current culture's <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName&gt;</ph>, or a string of the form:</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>][<bpt id="p3">*</bpt>integral-digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>,<ept id="p4">*</ept>]]<bpt id="p5">*</bpt>integral-digits<ept id="p5">*</ept>[<bpt id="p6">*</bpt>.<ept id="p6">*</ept>[<bpt id="p7">*</bpt>fractional-digits<ept id="p7">*</ept>]][E[<bpt id="p8">*</bpt>sign<ept id="p8">*</ept>]<bpt id="p9">*</bpt>exponential-digits<ept id="p9">*</ept>][<bpt id="p10">*</bpt>ws<ept id="p10">*</ept>]</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of white-space characters.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>A negative sign symbol (-) or a positive sign symbol (+).</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only a leading sign can be used.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>Runs of <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> can be partitioned by a group-separator symbol.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in some cultures a comma (,) separates groups of thousands.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>,</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific thousands separator symbol.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>E</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter is interpreted using a combination of the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flags.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that white space and thousands separators are allowed, for example, while currency symbols are not.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>For finer control over which style elements are permitted in <ph id="ph1">`s`</ph> for the parse operation to succeed, call the <ph id="ph2">&lt;xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=fullName&gt;</ph> or the <ph id="ph3">&lt;xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter is interpreted using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current thread culture.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>To parse a string using the formatting information of some other culture, call the <ph id="ph1">&lt;xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Double.Parse%2A?displayProperty=fullName&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Double.ToString%2A?displayProperty=fullName&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is returned.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because of a loss of precision, the values may not be equal.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, attempting to parse the string representation of either <ph id="ph1">&lt;xref:System.Double.MinValue&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph> throws an <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Parse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Parse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>A string that contains a number to convert.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number that is equivalent to the numeric value or symbol specified in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> does not represent a number in a valid format.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> represents a number that is less than <ph id="ph2">&lt;xref href="System.Double.MinValue"&gt;&lt;/xref&gt;</ph> or greater than <ph id="ph3">&lt;xref href="System.Double.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number in a specified style to its double-precision floating-point number equivalent.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, thousands separators, and currency symbols) that are allowed in the <ph id="ph2">`s`</ph> parameter for the parse operation to succeed.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members are not supported:</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can contain the current culture's <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, or <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, it can also take the form:</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>integral-digits<ept id="p4">*</ept>[<bpt id="p5">*</bpt>,<ept id="p5">*</ept>]]<bpt id="p6">*</bpt>integral-digits<ept id="p6">*</ept>[<bpt id="p7">*</bpt>.<ept id="p7">*</ept>[<bpt id="p8">*</bpt>fractional-digits<ept id="p8">*</ept>]][E[<bpt id="p9">*</bpt>sign<ept id="p9">*</ept>]<bpt id="p10">*</bpt>exponential-digits<ept id="p10">*</ept>][<bpt id="p11">*</bpt>ws<ept id="p11">*</ept>]</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of white-space characters.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source>White space can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific currency symbol.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName&gt;</ph> properties of the current culture.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT">
          <source>A negative sign symbol (-) or a positive sign symbol (+).</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>Parentheses can be used in <ph id="ph1">`s`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element can be absent if the string contains the <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> element.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>,</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific group separator.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's group separator symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional digits can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>E</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style) always parses successfully.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>The remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> flags affect the elements that may be present in <ph id="ph2">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>NumberStyles value</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements permitted in <ph id="ph1">`s`</ph> in addition to digits</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element only.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>The decimal point (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) and <bpt id="p2">*</bpt>fractional-digits<ept id="p2">*</ept> elements.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates exponential notation.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>This flag by itself supports values in the form <bpt id="p1">*</bpt>digits<ept id="p1">*</ept>E<bpt id="p2">*</bpt>digits<ept id="p2">*</ept>; additional flags are needed to successfully parse strings with such elements as positive or negative signs and decimal point symbols.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thousands separator (,) element.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>The currency ($) element.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning or end of <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the beginning of <ph id="ph2">`s`</ph>, and the decimal point (.) symbol.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, thousands separator (,) and decimal point (.) elements.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`s`</ph> cannot represent a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter is parsed using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current system culture.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Double.Parse%2A?displayProperty=fullName&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Double.ToString%2A?displayProperty=fullName&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is returned.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because of a loss of precision, the values may not be equal.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, attempting to parse the string representation of either <ph id="ph1">&lt;xref:System.Double.MinValue&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph> throws an <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.Parse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.Parse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>A string that contains a number to convert.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>A bitwise combination of enumeration values that indicate the style elements that can be present in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>A typical value to specify is a combination of <ph id="ph1">&lt;xref href="System.Globalization.NumberStyles.Float"&gt;&lt;/xref&gt;</ph> combined with <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowThousands"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number that is equivalent to the numeric value or symbol specified in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> does not represent a number in a valid format.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;s&lt;/code&gt;</ph> represents a number that is less than <ph id="ph2">&lt;xref href="System.Double.MinValue"&gt;&lt;/xref&gt;</ph> or greater than <ph id="ph3">&lt;xref href="System.Double.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> includes the <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowHexSpecifier"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>Represents positive infinity.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>This field is constant.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of this constant is the result of dividing a positive number by zero.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constant is returned when the result of an operation is greater than <ph id="ph1">&lt;xref:System.Double.MaxValue&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Double.IsPositiveInfinity%2A&gt;</ph> to determine whether a value evaluates to positive infinity.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of this instance to its equivalent string representation using the specified format and culture-specific format information.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value in a specified format of a specified culture.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a different format or culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Double.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default ("G") format</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default ("G") format</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format or precision</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or the string representation of a number, as specified by <ph id="ph4">`format`</ph>.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier except for D and X, as well as any combination of custom numeric format specifiers.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is <ph id="ph2">`null`</ph> or an empty string, the return value for this instance is formatted with the general numeric format specifier ("G").</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, <ph id="ph1">`provider`</ph> is a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter supplies culture-specific information used in formatting.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the return value is formatted using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the return value only contains 15 digits of precision although a maximum of 17 digits is maintained internally.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value of this instance has greater than 15 digits, <ph id="ph1">&lt;xref:System.Double.ToString%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph> instead of the expected number.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you require more precision, specify <ph id="ph1">`format`</ph> with the "G17" format specification, which always returns 17 digits of precision, or "R", which returns 15 digits if the number can be represented with that precision or 17 digits if the number can only be represented with maximum precision.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>A numeric format string.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>The string representation of the value of this instance as specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">provider</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of this instance to its equivalent string representation, using the specified format.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.ToString%28System.String%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value in a specified format by using the conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a different format or culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Double.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default ("G") format</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default ("G") format</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format or precision</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or the string representation of a number, as specified by <ph id="ph4">`format`</ph>.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier except for D and X, as well as any combination of custom numeric format specifiers.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is <ph id="ph2">`null`</ph> or an empty string, the return value is formatted with the general numeric format specifier ("G").</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the return value only contains 15 digits of precision although a maximum of 17 digits is maintained internally.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value of this instance has greater than 15 digits, <ph id="ph1">&lt;xref:System.Double.ToString%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph> instead of the expected number.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you require more precision, specify <ph id="ph1">`format`</ph> with the "G17" format specification, which always returns 17 digits of precision, or "R", which returns 15 digits if the number can be represented with that precision or 17 digits if the number can only be represented with maximum precision.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>A numeric format string.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>The string representation of the value of this instance as specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of this instance to its equivalent string representation using the specified culture-specific format information.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.ToString%28System.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value in the default ("G", or general) format of a specified culture.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a different format or culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Double.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default ("G") format</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current)</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format or precision</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format or precision</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or a string of the form:</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT">
          <source>[sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional elements are framed in square brackets ([ and ]).</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements that contain the term "digits" consist of a series of numeric characters ranging from 0 to 9.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements listed in the following table are supported.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>A negative sign or positive sign symbol.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits specifying the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>'<bpt id="p1">*</bpt>.<ept id="p1">*</ept>'</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits specifying the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>'<bpt id="p1">*</bpt>e<ept id="p1">*</ept>'</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>A lowercase character 'e', indicating exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits specifying an exponent.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some examples of the return value are "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123", and "-Infinity".</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>This instance is formatted with the general numeric format specifier ("G").</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, <ph id="ph1">`provider`</ph> is a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter supplies culture-specific information used in formatting.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the return value is formatted using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>The string representation of the value of this instance as specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">provider</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of this instance to its equivalent string representation.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.ToString&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value in the default ("G", or general) format of the current culture.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a different format, precision, or culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Double.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default ("G") format</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format or precision</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format or precision</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value can be <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A&gt;</ph>, or a string of the form:</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT">
          <source>[sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional elements are framed in square brackets ([ and ]).</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements that contain the term "digits" consist of a series of numeric characters ranging from 0 to 9.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements listed in the following table are supported.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT">
          <source>A negative sign or positive sign symbol.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits specifying the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT">
          <source>'<bpt id="p1">*</bpt>.<ept id="p1">*</ept>'</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits specifying the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>'<bpt id="p1">*</bpt>e<ept id="p1">*</ept>'</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>A lowercase character 'e', indicating exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits specifying an exponent.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some examples of the return value are "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123", and "-Infinity".</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>The string representation of the value of this instance.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number in a specified style and culture-specific format to its double-precision floating-point number equivalent.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>A return value indicates whether the conversion succeeded or failed.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Double.TryParse%2A&gt;</ph> method is like the <ph id="ph2">&lt;xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method, except this method does not throw an exception if the conversion fails.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion succeeds, the return value is <ph id="ph1">`true`</ph> and the <ph id="ph2">`result`</ph> parameter is set to the outcome of the conversion.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the conversion fails, the return value is <ph id="ph1">`false`</ph> and the <ph id="ph2">`result`</ph> parameter is set to zero.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>This eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> in the event that <ph id="ph2">`s`</ph> is invalid and cannot be successfully parsed.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter defines the allowable format of the <ph id="ph2">`s`</ph> parameter for the parse operation to succeed.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members are not supported:</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can contain <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, or <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName&gt;</ph> for the culture indicated by <ph id="ph5">`provider`</ph>.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`s`</ph> parameter may include the following elements:</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>[ws] [$] [sign][integral-digits,]integral-digits[.fractional-digits][e[sign]exponential-digits][ws]</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional white space.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>White space can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can appear at the end of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific currency symbol.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName&gt;</ph> properties of the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object returned by the <ph id="ph4">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=fullName&gt;</ph> method of the <ph id="ph5">`provider`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT">
          <source>The currency symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT">
          <source>An optional sign.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign can appear at the beginning of <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`s`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Parentheses can be used in <ph id="ph1">`s`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific thousands separator symbol.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's thousands separator symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional digits can appear in <ph id="ph1">`s`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>e<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>The e or E character, which indicates that <ph id="ph1">`s`</ph> can represent a number using exponential notation.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can represent a number in exponential notation if style includes the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of digits ranging from 0 to 9 that specify an exponent.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style) always parses successfully.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>The remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> members control elements that may be but are not required to be present in the input string.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> flags affect the elements that may be present in <ph id="ph2">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>NumberStyles value</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements permitted in s in addition to digits</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept> element only.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>and <bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept> elements.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>This flag by itself supports values in the form <bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept>E<bpt id="p2">*</bpt>exponential-digits<ept id="p2">*</ept>; additional flags are needed to successfully parse strings in exponential notation with such elements as positive or negative signs and decimal point symbols.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the beginning of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`s`</ph>.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>,<ept id="p1">*</ept> element.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt><ph id="ph1">$</ph><ept id="p1">*</ept> element.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>All.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter cannot represent a hexadecimal number or a number in exponential notation.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the beginning or end of <ph id="ph1">`s`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the beginning of <ph id="ph2">`s`</ph>, and the <bpt id="p3">*</bpt>.<ept id="p3">*</ept></source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>symbol.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can also use exponential notation.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, thousands separator (<bpt id="p1">*</bpt>,),<ept id="p1">*</ept> and decimal point (<bpt id="p2">*</bpt>.<ept id="p2">*</ept>) elements.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT">
          <source>All styles, except <ph id="ph1">`s`</ph> cannot represent a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is a <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation, such as a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> or <ph id="ph4">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter supplies culture-specific information used in parsing.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph> or a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object cannot be obtained, the format information for the current culture is used.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conversion fails if the <ph id="ph1">`s`</ph> parameter is <ph id="ph2">`null`</ph> or not a numeric value, the <ph id="ph3">`provider`</ph> parameter does not yield a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object, or the <ph id="ph5">`style`</ph> parameter is not a combination of bit flags from the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Double.TryParse%2A?displayProperty=fullName&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Double.ToString%2A?displayProperty=fullName&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is returned.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because of a loss of precision, the values may not be equal.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, attempting to parse the string representation of either <ph id="ph1">&lt;xref:System.Double.MinValue&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph> throws an <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.TryParse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.TryParse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the applicable currency or number decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>A string containing a number to convert.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>A bitwise combination of <ph id="ph1">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> values that indicates the permitted format of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>A typical value to specify is <ph id="ph1">&lt;xref href="System.Globalization.NumberStyles.Float"&gt;&lt;/xref&gt;</ph> combined with <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowThousands"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IFormatProvider"&gt;&lt;/xref&gt;</ph> that supplies culture-specific formatting information about <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">s</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a double-precision floating-point number equivalent of the numeric value or symbol contained in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept>, if the conversion succeeded, or zero if the conversion failed.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>The conversion fails if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> or <ph id="ph3">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, is not in a format compliant with <bpt id="p2">&lt;code&gt;</bpt><ph id="ph4">style</ph><ept id="p2">&lt;/code&gt;</ept>, represents a number less than <ph id="ph5">&lt;xref href="System.SByte.MinValue"&gt;&lt;/xref&gt;</ph> or greater than <ph id="ph6">&lt;xref href="System.SByte.MaxValue"&gt;&lt;/xref&gt;</ph>, or if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph7">style</ph><ept id="p3">&lt;/code&gt;</ept> is not a valid combination of <ph id="ph8">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> enumerated constants.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized; any value originally supplied in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">result</ph><ept id="p1">&lt;/code&gt;</ept> will be overwritten.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">s</ph><ept id="p1">&lt;/code&gt;</ept> was converted successfully; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> includes the <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowHexSpecifier"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number to its double-precision floating-point number equivalent.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>A return value indicates whether the conversion succeeded or failed.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload differs from the <ph id="ph1">&lt;xref:System.Double.Parse%28System.String%29?displayProperty=fullName&gt;</ph> method by returning a Boolean value that indicates whether the parse operation succeeded instead of returning the parsed numeric value.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT">
          <source>It eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> in the event that <ph id="ph2">`s`</ph> is invalid and cannot be successfully parsed.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter can contain the current culture's <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName&gt;</ph> (the string comparison is case-sensitive), or a string of the form:</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>[ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets are optional.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of white-space characters.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>A negative sign or positive sign symbol.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>integral-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of numeric characters ranging from 0 to 9 that specify the integral part of the number.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT">
          <source>Integral-digits can be absent if there are fractional-digits.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific group separator symbol.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of numeric characters ranging from 0 to 9 that specify the fractional part of the number.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>E<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>An uppercase or lowercase character 'e', that indicates exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential-digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT">
          <source>A series of numeric characters ranging from 0 to 9 that specify an exponent.</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric formats, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter is interpreted by using a combination of the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flags.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that white space and thousands separators are allowed but currency symbols are not.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>To explicitly define the elements (such as currency symbols, thousands separators, and white space) that can be present in <ph id="ph1">`s`</ph>, use the <ph id="ph2">&lt;xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=fullName&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`s`</ph> parameter is parsed using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current system culture.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT">
          <source>To parse a string using the formatting information of some other specified culture, use the <ph id="ph1">&lt;xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=fullName&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT">
          <source>Ordinarily, if you pass the <ph id="ph1">&lt;xref:System.Double.TryParse%2A?displayProperty=fullName&gt;</ph> method a string that is created by calling the <ph id="ph2">&lt;xref:System.Double.ToString%2A?displayProperty=fullName&gt;</ph> method, the original <ph id="ph3">&lt;xref:System.Double&gt;</ph> value is returned.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because of a loss of precision, the values may not be equal.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, attempting to parse the string representation of either <ph id="ph1">&lt;xref:System.Double.MinValue&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.MaxValue&gt;</ph> throws an <ph id="ph3">&lt;xref:System.OverflowException&gt;</ph>, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Double.TryParse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Double.TryParse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a separator is encountered in the <ph id="ph1">`s`</ph> parameter during a parse operation, and the decimal and group separators are the same, the parse operation assumes that the separator is a decimal separator rather than a group separator.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about separators, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>A string containing a number to convert.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>When this method returns, contains the double-precision floating-point number equivalent of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept> parameter, if the conversion succeeded, or zero if the conversion failed.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>The conversion fails if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">s</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> or <ph id="ph3">&lt;xref href="System.String.Empty"&gt;&lt;/xref&gt;</ph>, is not a number in a valid format, or represents a number less than <ph id="ph4">&lt;xref href="System.Double.MinValue"&gt;&lt;/xref&gt;</ph> or greater than <ph id="ph5">&lt;xref href="System.Double.MaxValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized; any value originally supplied in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">result</ph><ept id="p1">&lt;/code&gt;</ept> will be overwritten.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">s</ph><ept id="p1">&lt;/code&gt;</ept> was converted successfully; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToBoolean(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the current instance is not zero; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToByte(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>This conversion is not supported.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>Attempting to use this method throws an <ph id="ph1">&lt;xref href="System.InvalidCastException"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>This conversion is not supported.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>No value is returned.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>This conversion is not supported.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>Attempting to use this method throws an <ph id="ph1">&lt;xref href="System.InvalidCastException"&gt;&lt;/xref&gt;</ph></source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>This conversion is not supported.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>No value is returned.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>In all cases.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToDecimal(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;xref href="System.Decimal"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToDouble(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>The value of the current instance, unchanged.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToInt16(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;xref href="System.Int16"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToInt32(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToInt64(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;xref href="System.Int64"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToSByte(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to an <ph id="ph1">&lt;xref href="System.SByte"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToSingle(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;xref href="System.Single"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToType(System.Type,System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Convert.ChangeType%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>The type to which to convert this <ph id="ph1">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IFormatProvider"&gt;&lt;/xref&gt;</ph> implementation that supplies culture-specific information about the format of the returned value.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">type</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToUInt16(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;xref href="System.UInt16"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToUInt32(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;xref href="System.UInt32"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.IConvertible.ToUInt64(System.IFormatProvider)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Double&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>The value of the current instance, converted to a <ph id="ph1">&lt;xref href="System.UInt64"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>