<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6fbc5bbdc68355a62ff590cc56ea76528fcf65fc</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Net.Sockets.Socket.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7a11f0044b4c4f914c97bff5397733dd6127741e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df0357f649cf96a4f9e253a439a465ffaddb3e58</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Implements the Berkeley sockets interface.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class provides a rich set of methods and properties for network communications.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class follows the .NET Framework naming pattern for asynchronous methods.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method corresponds to the asynchronous <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method processes any incoming connection requests and returns a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to communicate data with the remote host.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method prior to calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method if you want to specify the local IP address and port number.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use a port number of zero if you want the underlying service provider to assign a free port for you.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to connect to a listening host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>To communicate data, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method to accept any incoming datagrams.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method to send datagrams to a remote host.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol such as TCP, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> methods to connect with a listening host.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods to communicate data asynchronously.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Incoming connection requests can be processed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> to send datagrams, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>and<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> to receive datagrams.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you are finished sending and receiving data, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to release all resources associated with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to configure your <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieve these settings using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are writing a relatively simple application and do not require maximum performance, consider using <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>These classes provide a simpler and more user-friendly interface to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> class using the specified value returned from <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s with the same underlying socket.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>This practice is strongly discouraged.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The socket information returned by <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> class using the specified socket type and protocol.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`socketType`</ph> parameter specifies the type of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class and the <ph id="ph3">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>The two parameters are not independent.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the combination of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.ProtocolType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The combination of  <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">socketType</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">protocolType</ph><ept id="p2">&lt;/code&gt;</ept> results in an invalid socket.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> class using the specified address family, socket type and protocol.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`addressFamily`</ph> parameter specifies the addressing scheme that the<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class uses, the <ph id="ph3">`socketType`</ph> parameter specifies the type of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class, and the <ph id="ph5">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The three parameters are not independent.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some address families restrict which protocols can be used with them, and often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the combination of address family, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type, and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.ProtocolType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The combination of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">addressFamily</ph><ept id="p1">&lt;/code&gt;</ept>, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">socketType</ph><ept id="p2">&lt;/code&gt;</ept>, and <bpt id="p3">&lt;code&gt;</bpt><ph id="ph3">protocolType</ph><ept id="p3">&lt;/code&gt;</ept> results in an invalid socket.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Creates a new <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> for a newly created connection.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> method of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>In blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blocks until an incoming connection attempt is queued.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a connection is accepted, the original <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continues queuing incoming connection requests until you close it.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call this method using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and no connection requests are queued, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method, you must first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> for a newly created connection.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The accepting socket is not listening for connections.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You must call <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Bind(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph> before calling <ph id="ph3">&lt;xref href="System.Net.Sockets.Socket.Accept"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and hook it to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required:</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller can optionally specify an existing <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use for the incoming connection by specifying the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName&gt;</ph> property is null, a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is constructed with the same <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> as the current <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and set as the <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> property needs to be set to the buffer containing the data to receive and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property needs to be set to the maximum number of bytes of data to receive in the buffer.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>These properties can be set using the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the amount of data returned will always be less than the value of the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> instance provided.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>The amount of the buffer used internally varies based on the address family of the socket.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>The minimum buffer size required is 288 bytes.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a larger buffer size is specified, then the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a timeout occurs, the connection is reset.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>The completion callback method should examine the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> property to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> operation was successful.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event can occur in some cases when no connection has been accepted and cause the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> property to be set to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence).</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>Applications using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method should be prepared to handle this condition.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>An argument is not valid.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This exception occurs if the buffer provided is not large enough.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This exception also occurs if multiple buffers are specified, the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.BufferList"&gt;&lt;/xref&gt;</ph> property is not null.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>An argument is out of range.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The exception occurs if the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Count"&gt;&lt;/xref&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>An invalid operation was requested.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>This exception occurs if the accepting <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is not listening for connections or the accepted socket is bound.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>You must call the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Bind(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph> method before calling the <ph id="ph3">&lt;xref href="System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Gets the address family of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> specifies the addressing scheme that an instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can use.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is read-only and is set when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Gets the amount of data that has been received from the network and is available to be read.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is a good way to determine whether data is queued for reading, before calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The available data is the total amount of data queued in the network buffer for reading.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is queued in the network buffer, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> returns 0.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down or closes the connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> can throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The number of bytes of data received from the network and available to be read.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload allows you to specify the accepted socket in the <ph id="ph1">`acceptSocket`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this parameter is <ph id="ph1">`null`</ph>, the accepted socket is created by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system may also use the calling thread to invoke the callback method.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>method completed synchronously.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The accepted <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>This value may be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that references the asynchronous <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object creation.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Windows NT is required for this method.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The accepting socket is not listening for connections.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>You must call <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Bind(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph> before calling <ph id="ph3">&lt;xref href="System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The accepted socket is bound.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;receiveSize&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload allows you to specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to send and receive data with the remote host.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system may also use the calling thread to invoke the callback method.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>method completed synchronously.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The number of bytes to accept from the sender.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> creation.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Windows NT is required for this method.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The accepting socket is not listening for connections.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>You must call <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Bind(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph> before calling <ph id="ph3">&lt;xref href="System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>The accepted socket is bound.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;receiveSize&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> will return a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>The system may also use the calling thread to invoke the callback method.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>method completed synchronously.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> creation.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Windows NT is required for this method.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The accepting socket is not listening for connections.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>You must call <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Bind(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph> before calling <ph id="ph3">&lt;xref href="System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The accepted socket is bound.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;receiveSize&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request for a remote host connection.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method starts an asynchronous request for a connection to the <ph id="ph2">`remoteEP`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> establishes a default remote host.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>At the very minimum, you must pass the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connects successfully or throws an exception.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> to communicate with a remote host.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you wish to set your default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you cannot, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method again with the desired endpoint.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous connection.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request for a remote host connection.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The host is specified by an <ph id="ph1">&lt;xref href="System.Net.IPAddress"&gt;&lt;/xref&gt;</ph> and a port number.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.IPAddress"&gt;&lt;/xref&gt;</ph> of the remote host.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>The port number of the remote host.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains information about the connect operation.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>This object is passed to the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">requestCallback</ph><ept id="p1">&lt;/code&gt;</ept> delegate when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous connection.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is not in the socket family.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>The port number is not valid.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">address</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request for a remote host connection.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>The host is specified by an <ph id="ph1">&lt;xref href="System.Net.IPAddress"&gt;&lt;/xref&gt;</ph> array and a port number.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>At least one <ph id="ph1">&lt;xref href="System.Net.IPAddress"&gt;&lt;/xref&gt;</ph>, designating the remote host.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>The port number of the remote host.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains information about the connect operation.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>This object is passed to the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">requestCallback</ph><ept id="p1">&lt;/code&gt;</ept> delegate when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous connections.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;addresses&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>This method is valid for sockets that use <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>The port number is not valid.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">address</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request for a remote host connection.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>The host is specified by a host name and a port number.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending call to the  <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>The name of the remote host.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The port number of the remote host.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains information about the connect operation.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>This object is passed to the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">requestCallback</ph><ept id="p1">&lt;/code&gt;</ept> delegate when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous connection.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;host&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph> families.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>The port number is not valid.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method to request a disconnect from a remote endpoint.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method uses a separate thread to invoke the specified callback method.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the pending disconnect is complete.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this socket can be reused after the connection is closed; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that references the asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>The location in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> to store the received data.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains information about the receive operation.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>This object is passed to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>The zero-based position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter at which to store the received data.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains information about the receive operation.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>This object is passed to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains information about the receive operation.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>This object is passed to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation is complete.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>methods.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains information about the receive operation.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>This object is passed to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive data from a specified network device.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method starts asynchronously reading connectionless datagrams from a remote host.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method gives you the ability to receive data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and it will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> reads data or throws an exception.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will throw a <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>In these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method and then call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method with the <ph id="ph4">`optionLevel`</ph> parameter set to <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> or <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> as appropriate, the <ph id="ph7">`optionName`</ph> parameter set to <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, and the <ph id="ph9">`optionValue`</ph> parameter to enable this option before calling the <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method or accept an incoming connection request by calling the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method before establishing or accepting a connection, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>The zero-based position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter at which to store the data.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>, and stores the endpoint and packet information..</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source>The asynchronous receive operation must be completed by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, the method is invoked by the <ph id="ph1">`asyncCallback`</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method does not block until the operation completes.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT">
          <source>To block until the operation completes, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The zero-based position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter at which to store the data.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> that represents the source of the data.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to send.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to send.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to send.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>The zero-based position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter at which to begin sending data.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> `state`</ph> is an instantiation of a user-defined class.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to send.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>The zero-based position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter at which to begin sending data.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>Sends the file <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> to a connected <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object using the <ph id="ph3">&lt;xref href="System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread"&gt;&lt;/xref&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method enables you to send a file within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source>A string that contains the path and name of the file to send.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that represents the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>The socket is not connected to a remote host.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>The file <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> was not found.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>Sends a file and buffers of data asynchronously to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method gives you the ability to send a file within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this custom object to the<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>A string that contains the path and name of the file to be sent.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> array that contains data to be sent before the file is sent.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> array that contains data to be sent after the file is sent.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>A bitwise combination of <ph id="ph1">&lt;xref href="System.Net.Sockets.TransmitFileOptions"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate to be invoked when this operation completes.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>A user-defined object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that represents the asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>The operating system is not Windows NT or later.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>The socket is not connected to a remote host.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>The file <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> was not found.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>Sends data asynchronously to a specific remote host.</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">`remoteEP`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>For additional information about writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will throw a <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph4">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method successfully completes.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT">
          <source>-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to send.</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>The zero-based position in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> at which to begin sending data.</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.AsyncCallback"&gt;&lt;/xref&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>An object that contains state information for this request.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source>Associates a <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> with a local endpoint.</source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you need to use a specific local endpoint.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT">
          <source>You do not need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method unless you need to use a specific local endpoint.</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method on both connectionless and connection-oriented protocols.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, you must first create the local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> from which you intend to communicate data.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not care which local address is assigned, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=fullName&gt;</ph> as the address parameter, and the underlying service provider will assign the most appropriate network address.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>This might help simplify your application if you have multiple network interfaces.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not care which local port is used, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using 0 for the port number.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the service provider will assign an available port number between 1024 and 5000.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> will not return the locally assigned network address until after you have made a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a UDP socket wants to receive interface information on received packets,  the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method should be explicitly called with the socket option set to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immediately after calling the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you intend to receive multicast datagrams, you must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method with a multicast port number.</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you intend to receive connectionless datagrams using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>The local <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> to associate with the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;localEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that indicates whether the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is in blocking mode.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property indicates whether a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is in blocking mode.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want execution to continue even though the requested operation is not complete, change the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property has no effect on asynchronous methods.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are sending and receiving data asynchronously and want to block execution, use the <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> will block; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>Cancels an asynchronous request for a remote host connection.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> method cancels an asynchronous request for a remote host connection.</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object used to request the connection to the remote host by calling one of the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)"&gt;&lt;/xref&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter cannot be null and the <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> cannot be null.</source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>Closes the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option to <ph id="ph4">`false`</ph> and specifying a non-zero time-out interval.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time-out period.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>Wait up to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">timeout</ph><ept id="p1">&lt;/code&gt;</ept> seconds to send any remaining data, then close the socket.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>Closes the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> connection and releases all associated resources.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specifying a non-zero time-out interval.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time out period.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source>Establishes a connection to a remote host.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> that represents the remote device.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>Establishes a connection to a remote host.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>The host is specified by an IP address and a port number.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve">
          <source>The IP address of the remote host.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve">
          <source>The port number of the remote host.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve">
          <source>is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve">
          <source>The port number is not valid.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph> families.</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">address</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve">
          <source>Establishes a connection to a remote host.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve">
          <source>The host is specified by an array of IP addresses and a port number.</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is typically used immediately after a call to <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, which can return multiple IP addresses for a single host.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve">
          <source>The IP addresses of the remote host.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve">
          <source>The port number of the remote host.</source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;addresses&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve">
          <source>The port number is not valid.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph> families.</source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve">
          <source>The length of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">address</ph><ept id="p1">&lt;/code&gt;</ept> is zero.</source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve">
          <source>Establishes a connection to a remote host.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve">
          <source>The host is specified by a host name and a port number.</source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote host.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT">
          <source>If IPv6 is enabled and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT">
          <source>This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a limitation of the underlying provider.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve">
          <source>The name of the remote host.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve">
          <source>The port number of the remote host.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;host&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve">
          <source>The port number is not valid.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph> families.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph>ing.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method starts an asynchronous request for a connection to the remote host.</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required:</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a connection is established, this buffer of data is sent.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> are not the same address family.</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve">
          <source>An argument is not valid.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.BufferList"&gt;&lt;/xref&gt;</ph> property is not null.</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter cannot be null and the <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> cannot be null.</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> are not the same address family.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host specified by the <ph id="ph2">`socketType`</ph> and <ph id="ph3">`protocolType`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required:</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT">
          <source>Once a connection is established, this buffer of data is sent.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> are not the same address family.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.ProtocolType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve">
          <source>An argument is not valid.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.BufferList"&gt;&lt;/xref&gt;</ph> property is not null.</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter cannot be null and the <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> cannot be null.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> are not the same address family.</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether a <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is connected to a remote host as of the last <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Send*"&gt;&lt;/xref&gt;</ph> or <ph id="ph3">&lt;xref href="System.Net.Sockets.Socket.Receive*"&gt;&lt;/xref&gt;</ph> operation.</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Connected`</ph> property gets the connection state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> as of the last I/O operation.</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT">
          <source>When it returns <ph id="ph1">`false`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was either never connected, or is no longer connected.</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property reflects the state of the connection as of the most recent operation.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> on a User Datagram Protocol (UDP) socket, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property always returns <ph id="ph3">`true`</ph>; however, this action does not change the inherent connectionless nature of UDP.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> was connected to a remote resource as of the most recent operation; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve">
          <source>Closes the socket connection and allows reuse of the socket.</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you can use this method to close the socket.</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method ends the connection and sets the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that all data is sent and received before the socket is closed, you should call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can set the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> then blocks until the data is sent or until the specified time-out expires.</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this socket can be reused after the current connection is closed; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve">
          <source>This method requires Windows 2000 or earlier, or the exception will be thrown.</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT">
          <source>When using a connection-oriented protocol, calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> method requests a disconnect from a remote endpoint.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=fullName&gt;</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`e`</ph> parameter, the socket can be reused.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter cannot be null.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in an unusable state.</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was occupying.</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>, and optionally disposes of the managed resources.</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> references.</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to release both managed and unmanaged resources; <ph id="ph2">`false`</ph> to releases only unmanaged resources.</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve">
          <source>Gets or sets a <ph id="ph1">&lt;xref href="System.Boolean"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> allows Internet Protocol (IP) datagrams to be fragmented.</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT">
          <source>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT">
          <source>Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a datagram must be fragmented, and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> allows datagram fragmentation; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph> families.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve">
          <source>Gets or sets a <ph id="ph1">&lt;xref href="System.Boolean"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is a dual-mode socket used for both IPv4 and IPv6.</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is a  dual-mode socket; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve">
          <source>Duplicates the socket reference for the target process, and closes the socket for this process.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The target process should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> to create the duplicate socket instance.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances with the same underlying socket.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT">
          <source>This practice is strongly discouraged.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the process creating the socket uses asynchronous methods (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), the process must first set the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> to be thrown on the target process.</source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve">
          <source>The ID of the target process where a duplicate of the socket reference is created.</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve">
          <source>The socket reference to be passed to the target process.</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;targetProcessID&lt;/code&gt;</ph> is not a valid process id.</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve">
          <source>Duplication of the socket reference failed.</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve">
          <source>Gets or sets a <ph id="ph1">&lt;xref href="System.Boolean"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> can send or receive broadcast packets.</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT">
          <source>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> allows broadcast packets; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve">
          <source>This option is valid for a datagram socket only.</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object to handle remote host communication.</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve">
          <source>This method returns a buffer that contains the initial data and the number of bytes transferred.</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the bytes transferred.</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve">
          <source>The number of bytes transferred.</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object to handle communication with the remote host.</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve">
          <source>Windows NT is required for this method.</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not created by a call to <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> method was previously called.</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> to handle remote host communication.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> to handle communication with the remote host.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> was not created by a call to <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve">
          <source>See the Remarks section for more information.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> method was previously called.</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve">
          <source>Windows NT is required for this method.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object to handle remote host communication.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve">
          <source>This method returns a buffer that contains the initial data transferred.</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the bytes transferred.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object to handle communication with the remote host.</source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve">
          <source>Windows NT is required for this method.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not created by a call to <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> method was previously called.</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph></source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous connection request.</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> is a blocking method that completes the asynchronous remote host connection request started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method to successfully complete the connection attempt.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous connection.</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous disconnect request.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the disconnect completes.</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that stores state information and any user-defined data for this asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous connection.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve">
          <source>The disconnect request has timed out.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous read.</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous read.</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>method to successfully complete the read operation and return the number of bytes read.</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> object, and extract the buffer contained in the resulting state object.</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT">
          <source>To identify the originating host, extract the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> and cast it to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName&gt;</ph> method to obtain the IP address and the <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName&gt;</ph> method to obtain the port number.</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve">
          <source>If successful, the number of bytes received.</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve">
          <source>If unsuccessful, returns 0.</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
        </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve">
          <source>This method also reveals more information about the packet than <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the operation has not completed, this method blocks until it does.</source>
        </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform this operation synchronously, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT">
          <source>Examine <ph id="ph1">`ipPacketInformation`</ph> if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
        </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values for the received packet.</source>
        </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve">
          <source>The source <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.IPAddress"&gt;&lt;/xref&gt;</ph> and interface of the received packet.</source>
        </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve">
          <source>If successful, the number of bytes received.</source>
        </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve">
          <source>If unsuccessful, returns 0.</source>
        </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph></source>
        </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;endPoint&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.</source>
        </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous send.</source>
        </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
        </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
        </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
        </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> error.</source>
        </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndSend(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous send.</source>
        </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
        </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
        </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
        </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
        </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
        </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> that stores state information for this asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> error.</source>
        </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndSend(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous send of a file.</source>
        </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, you must create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method to successfully complete the send operation.</source>
        </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
        </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IAsyncResult"&gt;&lt;/xref&gt;</ph> object that stores state information for this asynchronous operation.</source>
        </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve">
          <source>Windows NT is required for this method.</source>
        </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve">
          <source>Ends a pending asynchronous send to a specific location.</source>
        </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
        </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method as a parameter.</source>
        </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
        </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the requested number of bytes are sent.</source>
        </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve">
          <source>If successful, the number of bytes sent; otherwise, an invalid <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> error.</source>
        </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)"&gt;&lt;/xref&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous send.</source>
        </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve">
          <source>Gets or sets a <ph id="ph1">&lt;xref href="System.Boolean"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> allows only one process to bind to a port.</source>
        </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`false`</ph>, multiple sockets can use the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</source>
        </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT">
          <source>If more than one socket attempts to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</source>
        </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the first use of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to that port will fail until the original bound socket is destroyed.</source>
        </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property must be set before <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> is called; otherwise an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown.</source>
        </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> allows only one socket to bind to a specific port; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`true`</ph> for Windows Server 2003 and Windows XP Service Pack 2, and <ph id="ph2">`false`</ph> for all other versions.</source>
        </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Bind(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph> has been called for this <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve">
          <source>Frees resources used by the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class finalizer calls the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to close the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and free resources associated with the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve">
          <source>Returns the value of the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> option in an array.</source>
        </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`optionLength`</ph> parameter sets the maximum size of the returned byte array.</source>
        </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the option value requires fewer bytes, the array will contain only that many bytes.</source>
        </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the option value requires more bytes, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
        </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionLevel"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionName"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve">
          <source>The length, in bytes, of the expected return value.</source>
        </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the value of the socket option.</source>
        </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
        </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
        </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.SetSocketOption*"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve">
          <source>Returns the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> option setting, represented as a byte array.</source>
        </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT">
          <source>Upon successful completion of this method, the array specified by the <ph id="ph1">`optionValue`</ph> parameter contains the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.</source>
        </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the length of the <ph id="ph1">`optionValue`</ph> array is smaller than the number of bytes required to store the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
        </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionLevel"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionName"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is to receive the option setting.</source>
        </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
        </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
        </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.SetSocketOption*"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve">
          <source>Returns the value of a specified <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> option, represented as an object.</source>
        </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this overload to get the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
        </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to set the value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionLevel"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionName"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve">
          <source>An object that represents the value of the option.</source>
        </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">optionName</ph><ept id="p1">&lt;/code&gt;</ept> parameter is set to <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketOptionName.Linger"&gt;&lt;/xref&gt;</ph> the return value is an instance of the <ph id="ph3">&lt;xref href="System.Net.Sockets.LingerOption"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">optionName</ph><ept id="p1">&lt;/code&gt;</ept> is set to <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketOptionName.AddMembership"&gt;&lt;/xref&gt;</ph> or <ph id="ph3">&lt;xref href="System.Net.Sockets.SocketOptionName.DropMembership"&gt;&lt;/xref&gt;</ph>, the return value is an instance of the <ph id="ph4">&lt;xref href="System.Net.Sockets.MulticastOption"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">optionName</ph><ept id="p1">&lt;/code&gt;</ept> is any other value, the return value is an integer.</source>
        </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;optionName&lt;/code&gt;</ph> was set to the unsupported value <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketOptionName.MaxConnections"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve">
          <source>Gets the operating system handle for the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.IntPtr"&gt;&lt;/xref&gt;</ph> that represents the operating system handle for the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> using numerical control codes.</source>
        </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> method provides low-level access to the operating system <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the WSAIoctl documentation in the MSDN library.</source>
        </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> value that specifies the control code of the operation to perform.</source>
        </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> array that contains the input data required by the operation.</source>
        </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> array that contains the output data returned by the operation.</source>
        </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve">
          <source>The number of bytes in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">optionOutValue</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Blocking"&gt;&lt;/xref&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> using the <ph id="ph2">&lt;xref href="System.Net.Sockets.IOControlCode"&gt;&lt;/xref&gt;</ph> enumeration to specify control codes.</source>
        </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method provides low-level access to the operating system <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more, see the WSAIoctl documentation in the MSDN library.</source>
        </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.IOControlCode"&gt;&lt;/xref&gt;</ph> value that specifies the control code of the operation to perform.</source>
        </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the input data required by the operation.</source>
        </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the output data returned by the operation.</source>
        </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve">
          <source>The number of bytes in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">optionOutValue</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Blocking"&gt;&lt;/xref&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is bound to a specific local port.</source>
        </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT">
          <source>A socket is considered bound to a local port if it is explicitly bound by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or implicitly bound by calling members like <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a well-known port so that clients may connect to them.</source>
        </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is bound to a local port; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that specifies whether the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> will delay closing a socket in an attempt to send all pending data.</source>
        </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property changes the way <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method behaves.</source>
        </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property when set modifies the conditions under which the connection can be reset by Winsock.</source>
        </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Connection resets can still occur based on the IP protocol behavior.</source>
        </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property controls the length of time that a connection-oriented connection will remain open after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when data remains to be sent.</source>
        </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</source>
        </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property can be used to ensure that this data is sent to the remote host before the <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> method drops the connection.</source>
        </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT">
          <source>To enable lingering, create a <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instance containing the desired values, and set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property to this instance.</source>
        </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes the behavior of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method for the possible values of the <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT">
          <source>LingerState.Enabled</source>
        </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT">
          <source>LingerState.LingerTime</source>
        </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Behavior</source>
        </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`false`</ph> (disabled), the default value</source>
        </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT">
          <source>The time-out is not applicable, (default).</source>
        </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempts to send pending data until the default IP protocol time-out expires.</source>
        </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
        </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT">
          <source>A nonzero time-out</source>
        </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</source>
        </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
        </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT">
          <source>A zero timeout.</source>
        </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Discards any pending data.</source>
        </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT">
          <source>For connection-oriented socket (TCP, for example), Winsock resets the connection.</source>
        </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT">
          <source>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</source>
        </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT">
          <source>In most cases, the time-out computed by the stack is more relevant than one defined by an application.</source>
        </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the default behavior for a socket when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is not set.</source>
        </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</source>
        </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.LingerOption"&gt;&lt;/xref&gt;</ph> that specifies how to linger while closing a socket.</source>
        </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve">
          <source>Places a <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> in a listening state.</source>
        </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> causes a connection-oriented <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connection attempts.</source>
        </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`backlog`</ph> parameter specifies the number of incoming connections that can be queued for acceptance.</source>
        </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the maximum number of connections you can specify, retrieve the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> does not block.</source>
        </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to accept a connection from the queue.</source>
        </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT">
          <source>The backlog parameter is limited to different values depending on the Operating System.</source>
        </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT">
          <source>You may specify a higher value, but the backlog will be limited based on the Operating System.</source>
        </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve">
          <source>The maximum length of the pending connections queue.</source>
        </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve">
          <source>Gets the local endpoint.</source>
        </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property gets an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the local IP address and port number to which your <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is bound.</source>
        </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
        </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName&gt;</ph> method to retrieve the local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName&gt;</ph> method to retrieve the local port number.</source>
        </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property is usually set after you make a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you allow the system to assign your socket's local IP address and port number, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property will be set after the first I/O operation.</source>
        </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT">
          <source>For connection-oriented protocols, the first I/O operation would be a call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT">
          <source>For connectionless protocols, the first I/O operation would be any of the send or receive calls.</source>
        </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> that the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is using for communications.</source>
        </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</source>
        </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multicast is a scalable method for many-to-many communication on the Internet.</source>
        </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT">
          <source>A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</source>
        </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
        </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> receives outgoing multicast packets; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve">
          <source>Gets or sets a <ph id="ph1">&lt;xref href="System.Boolean"&gt;&lt;/xref&gt;</ph> value that specifies whether the stream <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is using the Nagle algorithm.</source>
        </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</source>
        </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT">
          <source>A TCP packet consists of 40 bytes of header plus the data being sent.</source>
        </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT">
          <source>When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</source>
        </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT">
          <source>The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</source>
        </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT">
          <source>The majority of network applications should use the Nagle algorithm.</source>
        </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</source>
        </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`false`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> uses the Nagle algorithm; otherwise, <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</source>
        </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
        </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the operating system and network adaptors support the IPv4 protocol; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</source>
        </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
        </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the operating system and network adaptors support the IPv6 protocol; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve">
          <source>Determines the status of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method will check the state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode?displayProperty=fullName&gt;</ph> for the <ph id="ph2">`selectMode`</ph> parameter to determine if the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is readable.</source>
        </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode?displayProperty=fullName&gt;</ph> to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is writable.</source>
        </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode?displayProperty=fullName&gt;</ph> to detect an error condition.</source>
        </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> will block execution until the specified time period, measured in <ph id="ph2">`microseconds`</ph>, elapses.</source>
        </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT">
          <source>Set the <ph id="ph1">`microSeconds`</ph> parameter to a negative integer if you would like to wait indefinitely for a response.</source>
        </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to check the status of multiple sockets, you might prefer to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
        </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
        </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve">
          <source>The time to wait for a response, in microseconds.</source>
        </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SelectMode"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve">
          <source>The status of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> based on the polling mode value passed in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">mode</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve">
          <source>Mode</source>
        </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve">
          <source>Return Value</source>
        </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Listen(System.Int32)"&gt;&lt;/xref&gt;</ph> has been called and a connection is pending;</source>
        </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if data is available for reading;</source>
        </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the connection has been closed, reset, or terminated;</source>
        </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve">
          <source>otherwise, returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph>, if processing a <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Connect(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph>, and the connection has succeeded;</source>
        </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if data can be sent;</source>
        </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve">
          <source>otherwise, returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if processing a <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Connect(System.Net.EndPoint)"&gt;&lt;/xref&gt;</ph> that does not block, and the connection has failed;</source>
        </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketOptionName.OutOfBandInline"&gt;&lt;/xref&gt;</ph> is not set and out-of-band data is available;</source>
        </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve">
          <source>otherwise, returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">mode</ph><ept id="p1">&lt;/code&gt;</ept> parameter is not one of the <ph id="ph2">&lt;xref href="System.Net.Sockets.SelectMode"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve">
          <source>See remarks below.</source>
        </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve">
          <source>Gets the protocol type of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> property is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created, and specifies the protocol used by that <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.ProtocolType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve">
          <source>Receives data from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>The <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT">
          <source>See Remarks below.</source>
        </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
        </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve">
          <source>The position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter to store the received data.</source>
        </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.LocalEndPoint"&gt;&lt;/xref&gt;</ph> property is not set.</source>
        </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve">
          <source>Receives the specified number of bytes from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into the specified offset position of the receive buffer, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT">
          <source>See Remarks below.</source>
        </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
        </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.</source>
        </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve">
          <source>The location in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> to store the received data.</source>
        </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.LocalEndPoint"&gt;&lt;/xref&gt;</ph> property was not set.</source>
        </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve">
          <source>Receives data from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires you to provide one or more receive buffers.</source>
        </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve">
          <source>A list of <ph id="ph1">&lt;xref href="System.ArraySegment`1"&gt;&lt;/xref&gt;</ph>s of type <ph id="ph2">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the received data.</source>
        </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph>.Count is zero.</source>
        </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve">
          <source>An error occurred while attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve">
          <source>Receives the specified number of bytes of data from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
        </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the <ph id="ph3">`size`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> exceeds the size of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve">
          <source>Receives data from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into the list of receive buffers.</source>
        </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method reads data into the buffers parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires you to provide one or more receive buffers.</source>
        </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve">
          <source>A list of <ph id="ph1">&lt;xref href="System.ArraySegment`1"&gt;&lt;/xref&gt;</ph>s of type <ph id="ph2">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the received data.</source>
        </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve">
          <source>An error occurred while attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve">
          <source>Receives data from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload only requires you to provide a receive buffer and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</source>
        </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
        </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available up to the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve">
          <source>Receives data from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into a receive buffer.</source>
        </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload only requires you to provide a receive buffer.</source>
        </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve">
          <source>Receives data from a bound <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
        </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
        </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires you to provide one or more receive buffers.</source>
        </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
        </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve">
          <source>A list of <ph id="ph1">&lt;xref href="System.ArraySegment`1"&gt;&lt;/xref&gt;</ph>s of type <ph id="ph2">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the received data.</source>
        </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph>.Count is zero.</source>
        </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve">
          <source>An error occurred while attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve">
          <source>Begins an asynchronous request to receive data from a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</source>
        </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The socket's local address must be known.</source>
        </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT">
          <source>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</source>
        </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT">
          <source>The function only returns messages from the remote address specified in the connection.</source>
        </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Messages from other addresses are silently discarded.</source>
        </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
        </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:</source>
        </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set</source>
        </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set</source>
        </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT">
          <source>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
        </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <ph id="ph1">`e`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the message is larger than the buffer, the buffer is filled with the first part of the message.</source>
        </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT">
          <source>For connection-oriented sockets, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</source>
        </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT">
          <source>For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</source>
        </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For message-oriented sockets, where a zero byte message is often allowable, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</source>
        </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT">
          <source>In any case, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</source>
        </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve">
          <source>An argument was invalid.</source>
        </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Buffer"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.BufferList"&gt;&lt;/xref&gt;</ph> properties on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter must reference valid buffers.</source>
        </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
        </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that specifies the size of the receive buffer of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT">
          <source>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</source>
        </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
        </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> that contains the size, in bytes, of the receive buffer.</source>
        </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve">
          <source>The default is 8192.</source>
        </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is less than 0.</source>
        </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve">
          <source>Receives a datagram into the data buffer and stores the endpoint.</source>
        </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
        </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
        </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload only requires you to provide a receive <ph id="ph1">`buffer`</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
        </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer offset defaults to 0.</source>
        </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The size defaults to the length of the <ph id="ph1">`buffer`</ph> parameter and the <ph id="ph2">`socketFlags`</ph> value defaults to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
        </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
        </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
        </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
        </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
        </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.</source>
        </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.</source>
        </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve">
          <source>Receives a datagram into the data buffer, using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>, and stores the endpoint.</source>
        </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
        </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
        </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload only requires you to provide a receive buffer, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
        </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The offset defaults to 0 and the size defaults to the length of the buffer parameter.</source>
        </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
        </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
        </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
        </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT">
          <source>When<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
        </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
        </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.</source>
        </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.</source>
        </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve">
          <source>Receives the specified number of bytes into the data buffer, using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>, and stores the endpoint.</source>
        </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
        </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
        </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
        </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer offset defaults to 0.</source>
        </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
        </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
        </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
        </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
        </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.</source>
        </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.</source>
        </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.LocalEndPoint"&gt;&lt;/xref&gt;</ph> property was not set.</source>
        </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>, and stores the endpoint.</source>
        </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
        </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
        </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
        </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
        </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
        </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
        </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
        </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
        </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the amount of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
        </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.</source>
        </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve">
          <source>The position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter to store the received data.</source>
        </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.</source>
        </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of the <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the offset parameter.</source>
        </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.LocalEndPoint"&gt;&lt;/xref&gt;</ph> property was not set.</source>
        </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive data from a specified network device.</source>
        </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method is used primarily to receive data on a connectionless socket.</source>
        </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT">
          <source>The socket's local address must be known.</source>
        </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
        </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
        </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:</source>
        </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
        </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT">
          <source>For byte streamstyle sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
        </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
        </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> cannot be null.</source>
        </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>, and stores the endpoint and packet information.</source>
        </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</source>
        </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
        </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT">
          <source>The socket's local address must be known.</source>
        </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be used with datagram and raw sockets.</source>
        </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
        </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT">
          <source>For message-oriented sockets, an incoming message is placed into the <ph id="ph1">`buffer`</ph> parameter up to the total size specified in the <ph id="ph2">`size`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`offset`</ph> parameter determines where in the <ph id="ph2">`buffer`</ph> the data is placed.</source>
        </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual amount of data placed into the <ph id="ph1">`buffer`</ph> is returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method automatically method sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the returned <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
        </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and its first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method will return invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
        </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT">
          <source>An application can examine the <ph id="ph1">`ipPacketInformation`</ph> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
        </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.</source>
        </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve">
          <source>The position in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">buffer</ph><ept id="p1">&lt;/code&gt;</ept> parameter to store the received data.</source>
        </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve">
          <source>The number of bytes to receive.</source>
        </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.</source>
        </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Net.Sockets.IPPacketInformation"&gt;&lt;/xref&gt;</ph> holding address and interface information.</source>
        </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve">
          <source>The number of bytes received.</source>
        </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or-</source>
        </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of the <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the offset parameter.</source>
        </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.LocalEndPoint"&gt;&lt;/xref&gt;</ph> property was not set.</source>
        </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve">
          <source>The .NET Framework is running on an AMD 64-bit processor.</source>
        </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
        </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.SocketFlags"&gt;&lt;/xref&gt;</ph>, and stores the endpoint and packet information.</source>
        </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
        </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT">
          <source>The socket's local address must be known.</source>
        </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can only be used with datagram and raw sockets.</source>
        </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
        </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
        </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:</source>
        </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
        </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method automatically sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
        </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and the first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method will result in invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
        </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to<ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT">
          <source>An application can examine the resulting <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
        </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> cannot be null.</source>
        </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Receive*"&gt;&lt;/xref&gt;</ph> call will time out.</source>
        </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> calls only.</source>
        </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve">
          <source>The time-out value, in milliseconds.</source>
        </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
        </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
        </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is less than -1.</source>
        </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve">
          <source>Gets the remote endpoint.</source>
        </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property gets the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the remote IP address and port number to which the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is connected.</source>
        </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contains the default remote IP address and port number with which the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will communicate.</source>
        </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
        </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName&gt;</ph> method to retrieve the remote <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName&gt;</ph> method to retrieve the remote port number.</source>
        </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> is set after a call to either <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you try to access this property earlier, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> with which the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is communicating.</source>
        </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve">
          <source>Determines the status of one or more sockets.</source>
        </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> is a static method that determines the status of one or more <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.</source>
        </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must place one or more sockets into an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> before you can use the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT">
          <source>Check for readability by calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> as the <ph id="ph3">`checkRead`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT">
          <source>To check your sockets for writability, use the <ph id="ph1">`checkWrite`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT">
          <source>For detecting error conditions, use <ph id="ph1">`checkError`</ph>.</source>
        </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> will be filled with only those sockets that satisfy the conditions.</source>
        </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are in a listening state, readability means that a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> will succeed without blocking.</source>
        </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have already accepted the connection, readability means that data is available for reading.</source>
        </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT">
          <source>In these cases, all receive operations will succeed without blocking.</source>
        </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT">
          <source>Readability can also indicate whether the remote <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> has shut down the connection; in that case a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will return immediately, with zero bytes returned.</source>
        </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> returns when at least one of the sockets of interest (the sockets in the <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, and <ph id="ph4">`checkError`</ph> lists) meets its specified criteria, or the <ph id="ph5">`microSeconds`</ph> parameter is exceeded, whichever comes first.</source>
        </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">`microSeconds`</ph> to -1 specifies an infinite time-out.</source>
        </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you make a nonblocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, writability means that you have connected successfully.</source>
        </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you already have a connection established, writability means that all send operations will succeed without blocking.</source>
        </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you have made a non-blocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the <ph id="ph2">`checkerror`</ph> parameter identifies sockets that have not connected successfully.</source>
        </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method if you only want to determine the status of a single <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
        </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
        </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> instances to check for readability.</source>
        </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> instances to check for writability.</source>
        </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> of <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> instances to check for errors.</source>
        </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve">
          <source>The time-out value, in microseconds.</source>
        </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve">
          <source>A -1 value indicates an infinite time-out.</source>
        </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">checkRead</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> or empty.</source>
        </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">checkWrite</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> or empty</source>
        </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve">
          <source>-and-</source>
        </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">checkError</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> or empty.</source>
        </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve">
          <source>Sends data to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
        </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires a buffer that contains the data you want to send.</source>
        </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
        </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve">
          <source>A list of <ph id="ph1">&lt;xref href="System.ArraySegment`1"&gt;&lt;/xref&gt;</ph>s of type <ph id="ph2">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve">
          <source>See remarks section below.</source>
        </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve">
          <source>Sends data to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
        </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method can be used for both connection-oriented and connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires a buffer that contains the data you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT">
          <source>The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter value, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
        </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
        </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
        </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve">
          <source>A list of <ph id="ph1">&lt;xref href="System.ArraySegment`1"&gt;&lt;/xref&gt;</ph>s of type <ph id="ph2">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
        </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT">
          <source>With a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
        </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
        </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0 or exceeds the size of the buffer.</source>
        </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve">
          <source>An operating system error occurs while accessing the socket.</source>
        </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>, using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
        </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
        </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
        </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve">
          <source>A list of <ph id="ph1">&lt;xref href="System.ArraySegment`1"&gt;&lt;/xref&gt;</ph>s of type <ph id="ph2">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.</source>
        </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
        </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
        </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
        </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve">
          <source>The position in the data buffer at which to begin sending data.</source>
        </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph></source>
        </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
        </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
        </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
        </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
        </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve">
          <source>The position in the data buffer at which to begin sending data.</source>
        </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketError"&gt;&lt;/xref&gt;</ph> object that stores the socket error.</source>
        </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</source>
        </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</source>
        </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:</source>
        </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set</source>
        </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set</source>
        </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph><ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT">
          <source>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</source>
        </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> set to the native Winsock WSAEMSGSIZE error code (10040).</source>
        </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Buffer"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.BufferList"&gt;&lt;/xref&gt;</ph> properties on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter must reference valid buffers.</source>
        </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
        </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is not yet connected or was not obtained via an <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket.Accept"&gt;&lt;/xref&gt;</ph>, <ph id="ph3">&lt;xref href="System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)"&gt;&lt;/xref&gt;</ph>,or <ph id="ph4">&lt;xref href="System.Net.Sockets.Socket.BeginAccept*"&gt;&lt;/xref&gt;</ph>, method.</source>
        </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that specifies the size of the send buffer of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT">
          <source>A larger buffer size might delay the recognition of connection difficulties.</source>
        </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
        </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Int32"&gt;&lt;/xref&gt;</ph> that contains the size, in bytes, of the send buffer.</source>
        </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve">
          <source>The default is 8192.</source>
        </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is less than 0.</source>
        </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve">
          <source>Sends the file <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> to a connected <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object with the <ph id="ph3">&lt;xref href="System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread"&gt;&lt;/xref&gt;</ph> transmit flag.</source>
        </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
        </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`flags`</ph> parameter defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), and the <ph id="ph3">`preBuffer`</ph> and <ph id="ph4">`postBuffer`</ph> parameters default to <ph id="ph5">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
        </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
        </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
        </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the file is sent.</source>
        </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
        </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains the path and name of the file to be sent.</source>
        </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve">
          <source>The socket is not connected to a remote host.</source>
        </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
        </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve">
          <source>The file <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> was not found.</source>
        </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve">
          <source>Sends the file <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> and buffers of data to a connected <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object using the specified <ph id="ph3">&lt;xref href="System.Net.Sockets.TransmitFileOptions"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
        </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
        </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`fileName`</ph> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
        </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
        </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
        </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
        </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
        </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method; otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
        </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
        </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
        </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> that contains the path and name of the file to be sent.</source>
        </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> array that contains data to be sent before the file is sent.</source>
        </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> array that contains data to be sent after the file is sent.</source>
        </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve">
          <source>This parameter can be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve">
          <source>One or more of <ph id="ph1">&lt;xref href="System.Net.Sockets.TransmitFileOptions"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve">
          <source>The operating system is not Windows NT or later.</source>
        </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\-</ph> or -</source>
        </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve">
          <source>The socket is not connected to a remote host.</source>
        </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
        </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve">
          <source>The file <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">fileName</ph><ept id="p1">&lt;/code&gt;</ept> was not found.</source>
        </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve">
          <source>Sends a collection of files or in memory data buffers asynchronously to a connected <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is used to send a collection of files or in memory data buffers to remote host.</source>
        </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> must already be connected to the remote host.</source>
        </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName&gt;</ph> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
        </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT">
          <source>Wildcards and UNC share names are supported.</source>
        </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
        </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:</source>
        </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the TransmitPackets function found in the Windows Sockets 2 API.</source>
        </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connection-oriented protocols, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method to establish a default remote host.</source>
        </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
        </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized according to the operating system on which it is used.</source>
        </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT">
          <source>On Windows server editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for high performance.</source>
        </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT">
          <source>On Windows client editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for minimum memory and resource utilization.</source>
        </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use of the <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions?displayProperty=fullName&gt;</ph> flag in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id="ph3">`e`</ph> parameter can deliver significant performance benefits.</source>
        </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the thread initiating the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</source>
        </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that there is a difference between kernel and user-mode APCs.</source>
        </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT">
          <source>Kernel APCs launch when a thread is in a wait state.</source>
        </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT">
          <source>User-mode APCs launch when a thread is in an alertable wait state</source>
        </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve">
          <source>The file specified in the <ph id="ph1">&lt;xref href="System.Net.Sockets.SendPacketsElement.FilePath"&gt;&lt;/xref&gt;</ph> property was not found.</source>
        </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve">
          <source>This exception also occurs if the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is not connected to a remote host.</source>
        </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve">
          <source>A connectionless <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</source>
        </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket.Send*"&gt;&lt;/xref&gt;</ph> call will time out.</source>
        </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> calls only.</source>
        </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve">
          <source>The time-out value, in milliseconds.</source>
        </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve">
          <source>If you set the property with a value between 1 and 499, the value will be changed to 500.</source>
        </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
        </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
        </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve">
          <source>The value specified for a set operation is less than -1.</source>
        </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve">
          <source>Sends data to the specified endpoint.</source>
        </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph> parameter, and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
        </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
        </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
        </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
        </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT">
          <source>Blocking sockets will block until the all of the bytes in the buffer are sent.</source>
        </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since a nonblocking<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
        </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
        </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
        </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> that represents the destination for the data.</source>
        </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve">
          <source>The number of bytes sent.</source>
        </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve">
          <source>Sends data to a specific endpoint using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph>.</source>
        </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
        </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
        </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
        </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT">
          <source>Blocking sockets will block until the requested all of the bytes in the <ph id="ph1">`buffer`</ph> are sent.</source>
        </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since a nonblocking<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
        </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
        </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
        </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> that represents the destination location for the data.</source>
        </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve">
          <source>The number of bytes sent.</source>
        </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve">
          <source>Sends the specified number of bytes of data to the specified endpoint using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this overload, the buffer offset defaults to 0.</source>
        </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
        </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
        </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
        </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
        </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since a nonblocking<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
        </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
        </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
        </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> that represents the destination location for the data.</source>
        </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve">
          <source>The number of bytes sent.</source>
        </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve">
          <source>The specified <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">size</ph><ept id="p1">&lt;/code&gt;</ept> exceeds the size of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">buffer</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve">
          <source>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
        </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
        </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
        </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
        </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
        </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
        </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT">
          <source>Since a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
        </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
        </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
        </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
        </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
        </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
        </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.</source>
        </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve">
          <source>The position in the data buffer at which to begin sending data.</source>
        </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve">
          <source>The number of bytes to send.</source>
        </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketFlags"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.EndPoint"&gt;&lt;/xref&gt;</ph> that represents the destination location for the data.</source>
        </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve">
          <source>The number of bytes sent.</source>
        </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id="ph2">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id="ph3">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.</source>
        </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve">
          <source>A caller in the call stack does not have the required permissions.</source>
        </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve">
          <source>Sends data asynchronously to a specific remote host.</source>
        </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property of the <ph id="ph3">`e`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
        </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although this method is intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
        </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.</source>
        </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:</source>
        </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
        </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
        </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT">
          <source>When using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method will ignore the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=fullName&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, the <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property will override the specified default remote host for that send operation only.</source>
        </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</source>
        </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
        </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you need to identify the assigned local network IP address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event is signaled and the associated delegates are called.</source>
        </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph> to true.</source>
        </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
        </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you specify the DontRoute flag in the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName&gt;</ph> property, the data you are sending will not be routed.</source>
        </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT">
          <source>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</source>
        </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT">
          <source>The successful completion of a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
        </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.</source>
        </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`true`</ph> if the I/O operation is pending.</source>
        </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.</source>
        </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`false`</ph> if the I/O operation completed synchronously.</source>
        </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve">
          <source>In this case, The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.Completed"&gt;&lt;/xref&gt;</ph> event on the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">e</ph><ept id="p2">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
        </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint"&gt;&lt;/xref&gt;</ph> cannot be null.</source>
        </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketAsyncEventArgs"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">e</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve">
          <source>Windows XP or later is required for this method.</source>
        </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve">
          <source>The protocol specified is connection-oriented, but the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> is not yet connected.</source>
        </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve">
          <source>Set the IP protection level on a socket.</source>
        </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</source>
        </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT">
          <source>This socket option enables applications to place access restrictions on IPv6 or IP sockets.</source>
        </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</source>
        </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT">
          <source>This socket option can also be used to remove access restrictions if the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT">
          <source>This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</source>
        </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT">
          <source>This socket option has defined protection levels specified in the <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method is used to enable or disable Network Address Traversal (NAT) for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT">
          <source>NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</source>
        </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, this explicitly disables NAT traversal for a <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
        </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, this may allow NAT traversal for a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depending on firewall rules in place on the system.</source>
        </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve">
          <source>The IP protection level to set on this socket.</source>
        </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">level</ph><ept id="p1">&lt;/code&gt;</ept> parameter cannot be <ph id="ph2">&lt;xref href="System.Net.Sockets.IPProtectionLevel.Unspecified"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve">
          <source>The IP protection level cannot be set to unspecified.</source>
        </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily"&gt;&lt;/xref&gt;</ph> of the socket must be either <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph> or <ph id="ph3">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve">
          <source>Sets the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> option to the specified <ph id="ph2">&lt;xref href="System.Boolean"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Set <ph id="ph1">`optionValue`</ph> to <ph id="ph2">`true`</ph> to enable the option, or to <ph id="ph3">`false`</ph> to disable the option.</source>
        </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
        </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionLevel"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionName"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve">
          <source>The value of the option, represented as a <ph id="ph1">&lt;xref href="System.Boolean"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> object has been closed.</source>
        </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve">
          <source>Sets the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> option to the specified value, represented as a byte array.</source>
        </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this overload to set those <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that require a byte array as an option value.</source>
        </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionLevel"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionName"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">&lt;xref href="System.Byte"&gt;&lt;/xref&gt;</ph> that represents the value of the option.</source>
        </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve">
          <source>Sets the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> option to the specified integer value.</source>
        </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an option with a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</source>
        </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an option with an integer data type, specify the appropriate value.</source>
        </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
        </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.</source>
        </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionLevel"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionName"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve">
          <source>A value of the option.</source>
        </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve">
          <source>Sets the specified <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> option to the specified value, represented as an object.</source>
        </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this overload to set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
        </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to get the current value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionLevel"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketOptionName"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.LingerOption"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.MulticastOption"&gt;&lt;/xref&gt;</ph> that contains the value of the option.</source>
        </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;optionValue&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve">
          <source>Disables sends and receives on a <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT">
          <source>When using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, always call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method before closing the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
        </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to free all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not attempt to reuse the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> after closing.</source>
        </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> enumeration values that are valid for the <ph id="ph2">`how`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT">
          <source>Send</source>
        </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disable sending on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT">
          <source>Receive</source>
        </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disable receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both</source>
        </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT">
          <source>Disable both sending and receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> are not allowed.</source>
        </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, specifying <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> will have no effect.</source>
        </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> are not allowed.</source>
        </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT">
          <source>This has no effect on lower protocol layers.</source>
        </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</source>
        </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT">
          <source>Data is in the incoming network buffer waiting to be received.</source>
        </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT">
          <source>More data has arrived.</source>
        </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are using a connectionless protocol, datagrams are accepted and queued.</source>
        </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</source>
        </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> on a connectionless <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is not recommended.</source>
        </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> disables both sends and receives as described above.</source>
        </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
        </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketShutdown"&gt;&lt;/xref&gt;</ph> values that specifies the operation that will no longer be allowed.</source>
        </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve">
          <source>Gets the type of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> is read-only and is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
        </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether IPv4 support is available and enabled on the current host.</source>
        </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
        </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current host supports the IPv4 protocol; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <ph id="ph1">&lt;xref href="System.Net.Dns"&gt;&lt;/xref&gt;</ph> members.</source>
        </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
        </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the Framework supports IPv6 for certain obsolete <ph id="ph2">&lt;xref href="System.Net.Dns"&gt;&lt;/xref&gt;</ph> methods; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve">
          <source>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT">
          <source>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</source>
        </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The TTL value may be set to a value from 0 to 255.</source>
        </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT">
          <source>When this property is not set, the default TTL value for a socket is 32.</source>
        </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" extradata="MT">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</source>
        </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.</source>
        </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
        </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve">
          <source>The TTL value.</source>
        </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve">
          <source>The TTL value can't be set to a negative number.</source>
        </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph> or <ph id="ph2">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetworkV6"&gt;&lt;/xref&gt;</ph> families.</source>
        </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve">
          <source>An error occurred when attempting to access the socket.</source>
        </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve">
          <source>This error is also returned when an attempt was made to set TTL to a value higher than 255.</source>
        </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> has been closed.</source>
        </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve">
          <source>Specifies whether the socket should only use Overlapped I/O mode.</source>
        </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT">
          <source>Set this property to <ph id="ph1">`true`</ph> for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> you intend to call <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> uses only overlapped I/O; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve">
          <source>The default is <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve">
          <source>The socket has been bound to a completion port.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>