<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1bee411b0d7de3444042b3cf73622595d81189a7</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Reflection.MethodInfo.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">52196394d274b63cdc0ea5a74684374c6d976944</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ae1d241ffee19ed5e9733f83162cd3bd86616ab</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Discovers the attributes of a method and provides access to method metadata.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class represents a method of a type.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object to obtain information about the method that the object represents and to invoke the method.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the method's visibility by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can discover what attributes are applied to the method by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> property or calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph>method.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can get information about the method's parameters and return type from the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can execute a method on a class instance by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a constructed generic method from one that represents a generic method definition by calling the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> instances by calling the <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=fullName&gt;</ph> or <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=fullName&gt;</ph> method, or by calling the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=fullName&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type from this method.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The type of the delegate to create.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The delegate for this method.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Creates a delegate of the specified type with the specified target from this method.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The type of the delegate to create.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The object targeted by the delegate.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The delegate for this method.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>An object to compare with this instance, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> equals the type and value of this instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the first definition of the specified method in the class hierarchy.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the type on which the first definition of the method is found by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method behaves as follows:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an interface implementation, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that overrides a virtual definition in a base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the virtual definition.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is specified with the <ph id="ph2">`new`</ph> keyword in C# or the <ph id="ph3">`Shadows`</ph> keyword in Visual Basic (as in <ph id="ph4">`newslot`</ph>, as described in <bpt id="p1">[</bpt>Common Type System<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an inherited method (that is, the current method does not provide its own implementation), the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the lowest method in the class hierarchy.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`Base.ToString`</ph> overrides <ph id="ph2">`Object.ToString`</ph>, and <ph id="ph3">`Derived.ToString`</ph> overrides <ph id="ph4">`Base.ToString`</ph>, calling the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method on a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph7">`Derived.ToString`</ph> returns a <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph9">`Object.ToString`</ph>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is not present in any base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>system.reflection.methodinfo.getbasedefinition#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>system.reflection.methodinfo.getbasedefinition#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>To call the <ph id="ph1">`GetBaseDefinition`</ph> method:</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type (the class or structure) that contains the property.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are working with an object (an instance of a type), you can call its <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Get a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method in which you're interested.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can do this by getting an array of all methods from the <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=fullName&gt;</ph> method and then iterating the elements in the array, or you can retrieve the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method directly by calling the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=fullName&gt;</ph> method and specifying the method name.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method to get the value of the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the base method definition.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object for the first implementation of this method.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Returns an empty array if the current method is not a generic method.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This method is not supported.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object that represents a generic method definition from which the current method can be constructed.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic method definition is a template from which methods can be constructed.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, from the generic method definition <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (expressed in C# syntax; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> in Visual Basic) you can construct and invoke the method <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Given a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object representing this constructed method, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the generic method definition.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two constructed methods are created from the same generic method definition, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for both methods.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you call <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that already represents a generic method definition, it returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider the following C#, Visual Basic, and C++ code:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the generic method <ph id="ph3">`M`</ph> returns <ph id="ph4">`B&lt;int, S&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the open type <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> returns <ph id="ph3">`B&lt;T, S&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents <ph id="ph4">`M`</ph>, so <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> can be called on both <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the case of the constructed type, the result of calling <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> is a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can be invoked.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the case of the open type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> cannot be invoked.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object representing a generic method definition from which the current method can be constructed.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The current method is not a generic method.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo.IsGenericMethod"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>This method is not supported.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Returns the hash code for this instance.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer hash code.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object representing the resulting constructed method.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a particular constructed method.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A&gt;</ph> property of this <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object returns <ph id="ph3">`true`</ph>, you can use it to invoke the method or to create a delegate to invoke the method.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods constructed with the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>You might use such open constructed methods when you generate dynamic assemblies.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider the following C#, Visual Basic, and C++ code.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method body of <ph id="ph1">`M`</ph> contains a call to method <ph id="ph2">`N`</ph>, specifying the type parameter of <ph id="ph3">`M`</ph> and the type <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for method <ph id="ph3">`N&lt;V,int&gt;`</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, so method <ph id="ph3">`N&lt;V,int&gt;`</ph> cannot be invoked.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>An array of types to be substituted for the type parameters of the current generic method definition.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> object that represents the constructed method formed by substituting the elements of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> for the type parameters of the current generic method definition.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> does not represent a generic method definition.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>That is, <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo.IsGenericMethodDefinition"&gt;&lt;/xref&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;typeArguments&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Any element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The number of elements in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> is not the same as the number of type parameters of the current generic method definition.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>An element of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">typeArguments</ph><ept id="p1">&lt;/code&gt;</ept> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This method is not supported.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Reflection.MemberTypes"&gt;&lt;/xref&gt;</ph> value indicating that this member is a method.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects — for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes?displayProperty=fullName&gt;</ph> only when a given member is a method.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the <ph id="ph1">`MemberType`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`MemberType`</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MemberTypes"&gt;&lt;/xref&gt;</ph> value indicating that this member is a method.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Indicates whether two <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> objects are equal.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Indicates whether two <ph id="ph1">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> objects are not equal.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is not equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Reflection.ParameterInfo"&gt;&lt;/xref&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.ParameterInfo"&gt;&lt;/xref&gt;</ph> object that contains information about the return type.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This method is not implemented.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Gets the return type of this method.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the return type property, first get the class <ph id="ph1">`Type`</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`ReturnType`</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The return type of this method.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Gets the custom attributes for the return type.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`ICustomAttributeProvider`</ph> object representing the custom attributes for the return type.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Provides access to the <ph id="ph1">&lt;xref href="System.Object.GetType"&gt;&lt;/xref&gt;</ph> method from COM.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> object representing the <ph id="ph2">&lt;xref href="System.Reflection.MethodInfo"&gt;&lt;/xref&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can be used to get the type information for an interface.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>