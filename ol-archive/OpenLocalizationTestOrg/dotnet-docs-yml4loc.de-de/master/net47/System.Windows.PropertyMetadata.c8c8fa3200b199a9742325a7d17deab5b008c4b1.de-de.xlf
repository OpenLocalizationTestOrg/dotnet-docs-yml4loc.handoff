<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c8bbcdfb5865d4fc8bcad2b18f9f69e5bf1c4adf</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Windows.PropertyMetadata.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">528267407d7bfec8114ba4ad89dba807ea77deb7</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2138605cb94cfda5c1400b5ed57277a01c9d12ee</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Property metadata can be defined and used during dependency property registration when calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> also takes property metadata.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>This class is a concrete base class that can be used in each of these calls.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, it is very common to specify metadata using one of the derived classes such as <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> framework level.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each of these properties could also have been set by the constructor but are exposed so that <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.Merge%2A&gt;</ph> method implementations can set them.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>XAML Text Usage</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>This type, and members of this type, are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Windows.PropertyMetadata"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Windows.PropertyMetadata"&gt;&lt;/xref&gt;</ph> class with a specified default value for the dependency property that this metadata will be applied to.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The default value to specify for a dependency property, usually provided as a value of some specific type.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <ph id="ph2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Windows.PropertyMetadata"&gt;&lt;/xref&gt;</ph> class with the specified <ph id="ph2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;&lt;/xref&gt;</ph> implementation reference.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Windows.PropertyMetadata"&gt;&lt;/xref&gt;</ph> class with the specified default value and <ph id="ph2">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;&lt;/xref&gt;</ph> implementation reference.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <ph id="ph2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Windows.PropertyMetadata"&gt;&lt;/xref&gt;</ph> class with the specified default value and callbacks.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> but not a <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, you can pass <ph id="ph3">`null`</ph> for the <ph id="ph4">`propertyChangedCallback`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be specified.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The default value of the dependency property, usually provided as a value of some specific type.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Reference to a handler implementation that is to be called whenever the property system calls <ph id="ph1">&lt;xref href="System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)"&gt;&lt;/xref&gt;</ph> against this property.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;defaultValue&lt;/code&gt;</ph> cannot be set to the value <ph id="ph2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <ph id="ph1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;&lt;/xref&gt;</ph> implementation specified in this metadata.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the default merge logic for a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> is to replace the previous one.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> is defined in the object model as read-write.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Windows.CoerceValueCallback"&gt;&lt;/xref&gt;</ph> implementation reference.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Gets or sets the default value of the dependency property.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> is defined in the object model as read-write.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is the default per the parameterless constructor, a <ph id="ph1">`defaultValue`</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> cannot be set using either <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> or the constructor.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to do so will raise an exception.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>XAML Text Usage</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>Members of this type are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The default value of the property.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The default value on a <ph id="ph1">&lt;xref href="System.Windows.PropertyMetadata"&gt;&lt;/xref&gt;</ph> instance created with the parameterless constructor will be <ph id="ph2">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Cannot be set to the value <ph id="ph1">&lt;xref href="System.Windows.DependencyProperty.UnsetValue"&gt;&lt;/xref&gt;</ph> once created.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>Various properties of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, such as <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are defined in the object model as read-write.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so those properties can be adjusted after initialization of the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is applied to a dependency property as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>At the time of one of these calls, <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> is called, and the value of this property is set to <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the metadata instance is immutable; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Merges this metadata with the base metadata.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used internally when metadata is being overridden (<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method).</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The base metadata to merge with this instance's values.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The dependency property to which this metadata is being applied.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subclasses should assure that any mutability of the data structure of a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> subclass should be marked as immutable once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.OnApply%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The dependency property to which the metadata has been applied.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If this is default metadata, this value is a null reference.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Gets or sets a reference to a <ph id="ph1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;&lt;/xref&gt;</ph> implementation specified in this metadata.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default merge logic for is to maintain all <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> is defined in the object model as read-write.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is so <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> can be adjusted after initialization of the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object itself.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and the properties are now considered immutable.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attempting to set <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A&gt;</ph> once <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph3">`true`</ph> on this metadata instance will raise an exception.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Windows.PropertyChangedCallback"&gt;&lt;/xref&gt;</ph> implementation reference.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Cannot set a metadata property once it is applied to a dependency property operation.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>