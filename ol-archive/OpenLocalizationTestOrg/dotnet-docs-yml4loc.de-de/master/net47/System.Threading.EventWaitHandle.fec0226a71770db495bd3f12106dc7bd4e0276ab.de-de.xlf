<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1cf7885ddf5f416cbdcb66dafa51a14d07ec77ce</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Threading.EventWaitHandle.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c4046bf09140338cf4f7bd46f57c5c49c625fee6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">319b47e5bc751dfbcfebf864acc94d026644be03</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a thread synchronization event.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class allows threads to communicate with each other by signaling.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, one or more threads block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> until an unblocked thread calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, releasing one or more of the blocked threads.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>A thread can signal an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and then block on it, by calling the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class provides access to named system synchronization events.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> that has been signaled depends on its reset mode.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName&gt;</ph> flag resets automatically when signaled, after releasing a single waiting thread.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName&gt;</ph> flag remains signaled until its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Automatic reset events provide exclusive access to a resource.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>The event releases the thread and immediately resets, blocking subsequent threads.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Manual reset events are like gates.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the event is not signaled, threads that wait on it will block.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>Manual reset events are useful when one thread must complete an activity before other threads can proceed.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects can be used with the <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about thread synchronization mechanisms, see <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to set the initial state to signaled; <ph id="ph2">`false`</ph> to set it to nonsignaled.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.EventResetMode"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`name`</ph> is <ph id="ph2">`null`</ph> or an empty string, a local <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is created.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>When using this constructor for named system events, specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initialState`</ph>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a named event was created, use the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">`false`</ph> to set it to nonsignaled.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.EventResetMode"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The name of a system-wide synchronization event.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleRights.FullControl"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic)<ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">`false`</ph> to set it to nonsignaled.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.EventResetMode"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The name of a system-wide synchronization event.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When this method returns, contains <ph id="ph1">`true`</ph> if a local event was created (that is, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">name</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph> or an empty string) or if the specified named system event was created; <ph id="ph4">`false`</ph> if the specified named system event already existed.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleRights.FullControl"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor initializes an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object that represents a system event.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects that represent the same system event.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the system event does not exist, it is created with the specified access control security.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the event exists, the specified access control security is ignored.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object even if <ph id="ph2">`eventSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object to represent the same named event, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic) <ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">`false`</ph> to set it to nonsignaled.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Threading.EventResetMode"&gt;&lt;/xref&gt;</ph> values that determines whether the event resets automatically or manually.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The name of a system-wide synchronization event.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When this method returns, contains <ph id="ph1">`true`</ph> if a local event was created (that is, if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">name</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph3">`null`</ph> or an empty string) or if the specified named system event was created; <ph id="ph4">`false`</ph> if the specified named system event already existed.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleRights.FullControl"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Gets an <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named system event represented by the current <ph id="ph2">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named system event.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> object represents a named system event, and the user does not have <ph id="ph2">&lt;xref href="System.Security.AccessControl.EventWaitHandleRights.ReadPermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> object represents a named system event, and was not opened with <ph id="ph2">&lt;xref href="System.Security.AccessControl.EventWaitHandleRights.ReadPermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Threading.WaitHandle.Close"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id="ph2">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Opens the specified named synchronization event, if it already exists.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open the specified named system event.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The name of the system synchronization event to open.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>An  object that represents the named system event.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The named system event does not exist.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The named event exists, but the user does not have the security access required to use it.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open an existing named system event.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The name of the system synchronization event to open.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>An object that represents the named system event.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The named system event does not exist.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The named event exists, but the user does not have the desired security access.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Sets the state of the event to nonsignaled, causing threads to block.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the operation succeeds; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Threading.WaitHandle.Close"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id="ph2">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method releases a single thread.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no guarantee that every call to the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method will release a thread from an <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> whose reset mode is <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is as if the second call did not happen.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>Also, if <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> is called when there are no threads waiting and the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is already signaled, the call has no effect.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=fullName&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), calling the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method leaves the wait handle in a signaled state until its <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the operation succeeds; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Threading.WaitHandle.Close"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id="ph2">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Sets the access control security for a named system event.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleSecurity"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;eventSecurity&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The user does not have <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleRights.ChangePermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The event was not opened with <ph id="ph1">&lt;xref href="System.Security.AccessControl.EventWaitHandleRights.ChangePermissions"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The current <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> object does not represent a named system event.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Threading.WaitHandle.Close"&gt;&lt;/xref&gt;</ph> method was previously called on this <ph id="ph2">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The name of the system synchronization event to open.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">`null`</ph> if the call failed.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This parameter is treated as uninitialized.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The named event exists, but the user does not have the desired security access.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The name of the system synchronization event to open.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a <ph id="ph1">&lt;xref href="System.Threading.EventWaitHandle"&gt;&lt;/xref&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">`null`</ph> if the call failed.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This parameter is treated as uninitialized.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>A Win32 error occurred.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The named event exists, but the user does not have the desired security access.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>