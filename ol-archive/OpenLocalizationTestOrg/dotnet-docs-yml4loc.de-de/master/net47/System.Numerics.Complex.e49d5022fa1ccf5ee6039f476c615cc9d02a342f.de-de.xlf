<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">93c2730895e0202a5798cb3734be8c8441b56de3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Numerics.Complex.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e48dd288667c50c58e344b88c567c6bbe14246af</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df5f72f8d837b923ca3638f4da33cf08e4dd7be3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a complex number.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>A complex number is a number that comprises a real number part and an imaginary number part.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>A complex number z is usually written in the form z = x + yi, where <bpt id="p1">*</bpt>x<ept id="p1">*</ept> and <bpt id="p2">*</bpt>y<ept id="p2">*</ept> are real numbers, and <bpt id="p3">*</bpt>i<ept id="p3">*</ept> is the imaginary unit that has the property <bpt id="p4">*</bpt>i<ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept> = -1.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The real part of the complex number is represented by <bpt id="p1">*</bpt>x<ept id="p1">*</ept>, and the imaginary part of the complex number is represented by <bpt id="p2">*</bpt>y<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instantiating a Complex Number</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can assign a value to a complex number in one of the following ways:</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>By passing two <ph id="ph1">&lt;xref:System.Double&gt;</ph> values to its constructor.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first value represents the real part of the complex number, and the second value represents its imaginary part.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>By calling the static (<ph id="ph1">`Shared`</ph> in Visual Basic) <ph id="ph2">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=fullName&gt;</ph> method to create a complex number from its polar coordinates.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>By assigning a <ph id="ph1">&lt;xref:System.Byte&gt;</ph>, <ph id="ph2">&lt;xref:System.SByte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph5">&lt;xref:System.Int32&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph7">&lt;xref:System.Int64&gt;</ph>, <ph id="ph8">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph9">&lt;xref:System.Single&gt;</ph>, or <ph id="ph10">&lt;xref:System.Double&gt;</ph> value to a <ph id="ph11">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value becomes the real part of the complex number, and its imaginary part equals 0.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>By casting (in C#) or converting (in Visual Basic) a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> or <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value becomes the real part of the complex number, and its imaginary part equals 0.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>By assigning the complex number that is returned by a method or operator to a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A?displayProperty=fullName&gt;</ph> is a static method that returns a complex number that is the sum of two complex numbers, and the <ph id="ph2">&lt;xref:System.Numerics.Complex.op_Addition%2A?displayProperty=fullName&gt;</ph> operator adds two complex numbers and returns the result.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example demonstrates each of these five ways of assigning a value to a complex number.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Class#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Class#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>Operations with Complex Numbers</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> structure in the .NET Framework includes members that provide the following functionality:</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods to compare two complex numbers to determine whether they are equal.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>Operators to perform arithmetic operations on complex numbers.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods to perform other numerical operations on complex numbers.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods to perform trigonometric operations on complex numbers.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can calculate the tangent of an angle represented by a complex number.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> and  <ph id="ph2">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> properties are read-only, you cannot modify the value of an existing <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>All methods that perform an operation on a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> number, if their return value is of type <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph>, return a new <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> number.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Precision and Complex Numbers</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that strict comparisons for equality of two <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> values may fail, even if the difference between the two values is due to a loss of precision.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Double&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, performing exponentiation on the logarithm of a number should return the original number.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Class#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Class#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the following example, which calculates the square root of a <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Class#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Class#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Complex Numbers, Infinity, and NaN</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>The real and imaginary parts of a complex number are represented by <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to ranging from <ph id="ph1">&lt;xref:System.Double.MinValue?displayProperty=fullName&gt;</ph> to <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=fullName&gt;</ph>, the real or imaginary part of a complex number can have a value of <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>, or <ph id="ph5">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> all propagate in any arithmetic or trigonometric operation.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, division by <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> produces a complex number whose real and imaginary parts are both <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, performing a multiplication that overflows the range of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> type produces a complex number whose real part is <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> and whose imaginary part is <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>Subsequently performing division with this complex number returns a complex number whose real part is <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> and whose imaginary part is <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Class#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Class#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mathematical operations with complex numbers that are invalid or that overflow the range of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type do not throw an exception.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, they return a <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> under the following conditions:</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The division of a positive number by zero returns <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any operation that overflows the upper bound of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type returns <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>The division of a negative number by zero returns <ph id="ph1">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any operation that overflows the lower bound of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type returns <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The division of a zero by zero returns <ph id="ph1">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any operation that is performed on operands whose values are <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>, or <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> returns <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, <ph id="ph5">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>, or <ph id="ph6">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>, depending on the specific operation.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that this applies to any intermediate calculations performed by a method.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the multiplication of <ph id="ph1">`new Complex(9e308, 9e308) and new Complex(2.5, 3.5)`</ph> uses the formula (ac - bd) + (ad + bc)i.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Each intermediate multiplication in this expression returns <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph>, and the attempt to subtract <ph id="ph2">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> from <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> returns <ph id="ph4">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>Formatting a Complex Number</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>By default, the string representation of a complex number takes the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>real<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>imaginary<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>real<ept id="p3">*</ept> and <bpt id="p4">*</bpt>imaginary<ept id="p4">*</ept> are the string representations of the <ph id="ph4">&lt;xref:System.Double&gt;</ph> values that form the complex number's real and imaginary components.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some overloads of the <ph id="ph1">&lt;xref:System.Numerics.Complex.ToString%2A&gt;</ph> method allow customization of the string representations of these <ph id="ph2">&lt;xref:System.Double&gt;</ph> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For more information, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>In electrical engineering, a complex number is most commonly expressed as a + bj.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can return the string representation of a complex number in either of these two forms.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>To do this, define a custom format provider by implementing the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfaces, and then call the <ph id="ph3">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example defines a <ph id="ph1">`ComplexFormatter`</ph> class that represents a complex number as a string in the form of either a + bi or a + bj.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Class#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Class#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example then uses this custom formatter to display the string representation of a complex number.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Class#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Class#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> structure using the specified real and imaginary values.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`real`</ph> or <ph id="ph2">`imaginary`</ph> arguments may lose precision if they are data types that require an explicit cast to <ph id="ph3">&lt;xref:System.Double&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The real part of the complex number.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The imaginary part of the complex number.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Gets the absolute value (or magnitude) of a complex number.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>The absolute value of a complex number is equivalent to its <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The absolute value of a real number a + bi is calculated as follows:</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>If b = 0, the result is 0.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a &gt; b, the result is a *<ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=fullName&gt;</ph>(1 + b<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>/a<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>).</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>If b &gt; a, the result is b * <ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=fullName&gt;</ph>(1 + a<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>/b<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>).</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the calculation of the absolute value results in an overflow, the method returns either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>If either the <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph> and the other property is neither <ph id="ph4">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> nor <ph id="ph5">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>, the method returns <ph id="ph6">&lt;xref:System.Double.NaN?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The absolute value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Returns the angle that is the arc cosine of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Acos%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Acos%2A&gt;</ph> method uses the following formula:</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>(-<ph id="ph1">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph>) * <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph><ph id="ph6">*</ph><ph id="ph7">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph>(<ph id="ph8">&lt;xref:System.Numerics.Complex.One&gt;</ph><ph id="ph9"> - </ph><ph id="ph10">`value`</ph><ph id="ph11"> * </ph><ph id="ph12">`value`</ph>)))</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A complex number that represents a cosine.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The angle, measured in radians, which is the arc cosine of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Adds two complex numbers and returns the result.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>(a + c) + (b + d)i.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of the component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A&gt;</ph> method to perform addition with complex numbers.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The first complex number to add.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The second complex number to add.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Returns the angle that is the arc sine of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Asin%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Asin%2A&gt;</ph> method uses the following formula:</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">-</ph><ph id="ph2">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph><ph id="ph3"> * </ph><ph id="ph4">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> * value + <ph id="ph6">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph>(<ph id="ph7">&lt;xref:System.Numerics.Complex.One&gt;</ph> - value * value))</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The angle which is the arc sine of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Returns the angle that is the arc tangent of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Atan%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Atan%2A&gt;</ph> method uses the following formula:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> / new Complex(2.0, 0.0)) * (<ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph3">&lt;xref:System.Numerics.Complex.One&gt;</ph><ph id="ph4"> - </ph><ph id="ph5">&lt;xref:System.Numerics.Complex.ImaginaryOne&gt;</ph> * value) - <ph id="ph6">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>(<ph id="ph7">&lt;xref:System.Numerics.Complex.One&gt;</ph> + ImaginaryOne * value)</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The angle that is the arc tangent of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Computes the conjugate of a complex number and returns the result.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a + bi is a complex number, its conjugate is a - bi.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The conjugate of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Returns the cosine of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Cos%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph> method uses the following formula to calculate the cosine of the complex number a + bi:</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Math.Cos%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cosh%2A&gt;</ph>(b), -(<ph id="ph3">&lt;xref:System.Math.Sin%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sinh%2A&gt;</ph>(b)))</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The cosine of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic cosine of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Cosh%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Math.Cosh%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cos%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Sinh%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sin%2A&gt;</ph>(b))</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Divides one complex number by another and returns the result.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>((ac + bd) / (c<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> + d<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>)) + ((bc - ad) / (c<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + d<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>)i</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%2A&gt;</ph> method can be used by languages that do not support custom operators.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its behavior is identical to division using the division operator.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The complex number to be divided.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The complex number to divide by.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The quotient of the division.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the current instance and a specified complex number have the same value.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method provides the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> implementation for the <ph id="ph3">&lt;xref:System.Numerics.Complex&gt;</ph> structure.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT">
          <source>It performs slightly better than <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> method because it does not have to convert its parameter to a complex number.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method is equivalent to the following expression:</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Equals#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Equals#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The complex number to compare.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this complex number and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> have the same value; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the current instance and a specified object have the same value.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> method is equivalent to the following expression:</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Equals#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Equals#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`obj`</ph> parameter is not a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> object, but it is a data type for which an implicit conversion is defined, the <ph id="ph3">&lt;xref:System.Numerics.Complex.Equals%28System.Object%29&gt;</ph> method converts <ph id="ph4">`obj`</ph> to a <ph id="ph5">&lt;xref:System.Numerics.Complex&gt;</ph> object whose real part is equal to the value of <ph id="ph6">`obj`</ph> and whose imaginary part is equal to zero before it performs the comparison.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Equals#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Equals#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The object to compare.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> parameter is a <ph id="ph3">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> object or a type capable of implicit conversion to a <ph id="ph4">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> object, and its value is equal to the current <ph id="ph5">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> object; otherwise, <ph id="ph6">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Returns <ph id="ph1">`e`</ph> raised to the power specified by a complex number.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Numerics.Complex.Pow%2A&gt;</ph> method to calculate the powers of other bases.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Exp%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.Exp%2A&gt;</ph> is the inverse of <ph id="ph2">&lt;xref:System.Numerics.Complex.Log%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>A complex number that specifies a power.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The number <ph id="ph1">`e`</ph> raised to the power <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Creates a complex number from a point's polar coordinates.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method instantiates a complex number based on its polar coordinates.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because there are multiple representations of a point on a complex plane, the return value of the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method is normalized.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<ph id="ph1">&lt;xref:System.Math.PI&gt;</ph> to <ph id="ph2">&lt;xref:System.Math.PI&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a result, the values of the <ph id="ph1">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> properties of the resulting complex number may not equal the original values of the <ph id="ph3">`magnitude`</ph> and <ph id="ph4">`phase`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>To convert a value from degrees to radians for the <ph id="ph1">`phase`</ph> parameter, multiply it by <ph id="ph2">&lt;xref:System.Math.PI?displayProperty=fullName&gt;</ph>/180.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The phase, which is the angle from the line to the horizontal axis, measured in radians.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Returns the hash code for the current <ph id="ph1">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer hash code.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Gets the imaginary component of the current <ph id="ph1">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>Given a complex number a + bi, the <ph id="ph1">&lt;xref:System.Numerics.Complex.Imaginary%2A&gt;</ph> property returns the value of b.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The imaginary component of a complex number.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Returns a new <ph id="ph1">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> instance with a real number equal to zero and an imaginary number equal to one.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Returns the natural (base <ph id="ph1">`e`</ph>) logarithm of a specified complex number.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Log%28System.Double%29?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The natural (base <ph id="ph1">`e`</ph>) logarithm of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Returns the logarithm of a specified complex number in a specified base.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>The base of the logarithm.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The logarithm of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> in base <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">baseValue</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Returns the base-10 logarithm of a specified complex number.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Log10%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Log10%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The base-10 logarithm of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Gets the magnitude (or absolute value) of a complex number.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property is equivalent to the absolute value of a complex number.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>The absolute value is calculated as follows:</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source>&amp;#124; a + bi &amp;#124; = <ph id="ph1">&lt;xref:System.Math.Sqrt%2A?displayProperty=fullName&gt;</ph>(a * a + b * b)</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the calculation of the absolute value results in an overflow, this property returns either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> and the <ph id="ph2">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph> properties define the position of a point that represents a complex number in the polar coordinate system.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The magnitude of the current instance.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Returns the product of two complex numbers.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>(ac - bd) + (ad + bc)i</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its behavior is identical to multiplication using the multiplication operator.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The first complex number to multiply.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The second complex number to multiply.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The product of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Returns the additive inverse of a specified complex number.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>The additive inverse of a complex number is a complex number that produces a value of <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> when it is added to the original complex number.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its behavior is identical to negation using the unary negation operator, <ph id="ph1">&lt;xref:System.Numerics.Complex.op_UnaryNegation%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The result of the <ph id="ph1">&lt;xref href="System.Numerics.Complex.Real"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.Numerics.Complex.Imaginary"&gt;&lt;/xref&gt;</ph> components of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter multiplied by -1.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Returns a new <ph id="ph1">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> instance with a real number equal to one and an imaginary number equal to zero.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Adds two complex numbers.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Addition%2A&gt;</ph> method defines the addition operation for complex numbers.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Add#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Add#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>(a + c) + (b + d)i</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The first value to add.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The second value to add.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Divides a specified complex number by another specified complex number.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Division%2A&gt;</ph> method defines the division operation for complex numbers.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Divide#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Divide#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>((ac + bd) / (c<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> + d<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>)) + ((bc - ad) / (c<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + d<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>)i</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the division results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators and operator overloading can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The value to be divided.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The value to divide by.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The result of dividing <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether two complex numbers are equal.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> method defines the operation of the equality operator for <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Equals#9<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Equals#9<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> method is equivalent to the following expression:</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Equals#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Equals#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information and a possible workaround, see the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%2A?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>The first complex number to compare.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The second complex number to compare.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters have the same value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether two complex numbers are not equal.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Equality%2A&gt;</ph> method defines the operation of the inequality operator for complex numbers.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Inequality#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Inequality#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can test for inequality by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method and reversing its value.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>One possible workaround is to implement a comparison method that returns <ph id="ph1">`true`</ph> only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are not equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Multiplies two specified complex numbers.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Multiply%2A&gt;</ph> method defines the operation of the multiplication operator for complex numbers.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Multiply#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Multiply#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>(ac - bd) + (ad + bc)i</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The first value to multiply.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The second value to multiply.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The product of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Subtracts a complex number from another complex number.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_Subtraction%2A&gt;</ph> method defines the operation of the subtraction operator for complex numbers.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Subtract#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Subtract#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>(a - c) + (b - d)i</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>The value to subtract from (the minuend).</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The value to subtract (the subtrahend).</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>The result of subtracting <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">right</ph><ept id="p1">&lt;/code&gt;</ept> from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Returns the additive inverse of a specified complex number.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.op_UnaryNegation%2A&gt;</ph> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.Complex.Negate#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.Complex.Negate#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>The resulting complex number produces a value of <ph id="ph1">&lt;xref:System.Numerics.Complex&gt;</ph> 0 (zero) when it is added to the original complex number.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>The value to negate.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>The result of the <ph id="ph1">&lt;xref href="System.Numerics.Complex.Real"&gt;&lt;/xref&gt;</ph> and <ph id="ph2">&lt;xref href="System.Numerics.Complex.Imaginary"&gt;&lt;/xref&gt;</ph> components of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter multiplied by -1.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Gets the phase of a complex number.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a complex number a + bi, the phase is computed as <ph id="ph1">&lt;xref:System.Math.Atan2%2A?displayProperty=fullName&gt;</ph>(b, a).</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>The magnitude (represented by the <ph id="ph1">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph> property) is the distance from the point of origin to the point that is represented by the complex number.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>To convert the phase from radians to degrees, multiply it by 180/<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>The phase of a complex number, in radians.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Returns a specified complex number raised to a power specified by a double-precision floating-point number.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">&lt;xref:System.Numerics.Complex?displayProperty=fullName&gt;</ph>, the method returns <ph id="ph3">&lt;xref:System.Numerics.Complex?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>For other values, if <ph id="ph1">`power`</ph> is 0, the method returns <ph id="ph2">&lt;xref:System.Numerics.Complex?displayProperty=fullName&gt;</ph>, and if <ph id="ph3">`power`</ph> is 1, it returns <ph id="ph4">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Pow%2A?displayProperty=fullName&gt;</ph> method for primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>A complex number to be raised to a power.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number that specifies a power.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The complex number <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> raised to the power <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">power</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Returns a specified complex number raised to a power specified by a complex number.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>A complex number to be raised to a power.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>A complex number that specifies a power.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The complex number <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> raised to the power <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">power</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Gets the real component of the current <ph id="ph1">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Given a complex number a + bi, the <ph id="ph1">&lt;xref:System.Numerics.Complex.Real%2A&gt;</ph> property returns the value of a.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>The real component of a complex number.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>Returns the multiplicative inverse of a complex number.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reciprocal, or multiplicative inverse, of a number <bpt id="p1">*</bpt>x<ept id="p1">*</ept> is a number <bpt id="p2">*</bpt>y<ept id="p2">*</ept> where <bpt id="p3">*</bpt>x<ept id="p3">*</ept> multiplied by <bpt id="p4">*</bpt>y<ept id="p4">*</ept> yields 1.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reciprocal of a complex number is the complex number that produces <ph id="ph1">&lt;xref:System.Numerics.Complex?displayProperty=fullName&gt;</ph> when the two numbers are multiplied.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>+b<bpt id="p2">&lt;sup&gt;</bpt>2<ept id="p2">&lt;/sup&gt;</ept>) + -b/(a<bpt id="p3">&lt;sup&gt;</bpt>2<ept id="p3">&lt;/sup&gt;</ept> + b<bpt id="p4">&lt;sup&gt;</bpt>2<ept id="p4">&lt;/sup&gt;</ept>).</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>If value is <ph id="ph1">&lt;xref:System.Numerics.Complex?displayProperty=fullName&gt;</ph>, the method returns <ph id="ph2">&lt;xref:System.Numerics.Complex?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it returns the result of the expression <ph id="ph1">&lt;xref:System.Numerics.Complex?displayProperty=fullName&gt;</ph><ph id="ph2">/</ph><ph id="ph3">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>The reciprocal of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Returns the sine of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Sin%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph> method uses the following formula to calculate the sine of the complex number a + bi:</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Math.Sin%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cosh%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Cos%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sinh%2A&gt;</ph>(b))</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>The sine of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic sine of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Sinh%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>(<ph id="ph1">&lt;xref:System.Math.Sinh%2A&gt;</ph>(a) * <ph id="ph2">&lt;xref:System.Math.Cos%2A&gt;</ph>(b), <ph id="ph3">&lt;xref:System.Math.Cosh%2A&gt;</ph>(a) * <ph id="ph4">&lt;xref:System.Math.Sin%2A&gt;</ph>(b))</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Returns the square root of a specified complex number.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>The square root of the complex number <ph id="ph1">`value`</ph> is calculated by using the following formula:</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=fullName&gt;</ph>(<ph id="ph2">&lt;xref:System.Math.Sqrt%2A?displayProperty=fullName&gt;</ph>(<ph id="ph3">`value`</ph>.<ph id="ph4">&lt;xref:System.Numerics.Complex.Magnitude%2A&gt;</ph>), <ph id="ph5">`value`</ph>.<ph id="ph6">&lt;xref:System.Numerics.Complex.Phase%2A&gt;</ph>/2.0)</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Sqrt%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Sqrt%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>The square root of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Subtracts one complex number from another and returns the result.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>(a - c) + (b - d)i</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method call results in an overflow in either the real or imaginary component, the value of that component is either <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.Complex.Subtract%2A&gt;</ph> method to perform subtraction using complex numbers.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>The value to subtract from (the minuend).</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>The value to subtract (the subtrahend).</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>The result of subtracting <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">right</ph><ept id="p1">&lt;/code&gt;</ept> from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Returns the tangent of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Tan%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tan%2A&gt;</ph> method uses the following formula to calculate the tangent of the complex number <ph id="ph2">`value`</ph>:</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.Sin%2A&gt;</ph>(<ph id="ph2">`value`</ph>) / <ph id="ph3">&lt;xref:System.Numerics.Complex.Cos%2A&gt;</ph>(<ph id="ph4">`value`</ph>)</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>The tangent of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic tangent of the specified complex number.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tanh%2A&gt;</ph> method for complex numbers corresponds to the <ph id="ph2">&lt;xref:System.Math.Tanh%2A?displayProperty=fullName&gt;</ph> method for real numbers.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Tanh%2A&gt;</ph> method uses the following formula to calculate the hyperbolic tangent of the complex number <ph id="ph2">`value`</ph>:</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.Complex.Sinh%2A&gt;</ph>(<ph id="ph2">`value`</ph>) / <ph id="ph3">&lt;xref:System.Numerics.Complex.Cosh%2A&gt;</ph>(<ph id="ph4">`value`</ph>)</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>A complex number.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>The hyperbolic tangent of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default string representation of a complex number displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the general format specifier ("G") and the conventions of the current system culture.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The string representation of the current instance in Cartesian form.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the general format specifier ("G") and the conventions of the culture defined by <ph id="ph1">`provider`</ph>.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the returned string is formatted using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter can be one of the following:</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>A custom object that implements the <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The string representation of the current instance in Cartesian form, as specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">provider</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the format string specified by <ph id="ph1">`format`</ph>.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String?displayProperty=fullName&gt;</ph> or is <ph id="ph3">`null`</ph>, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format strings, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>The format of the returned string is determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the <ph id="ph1">`format`</ph> parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide formatting information for cultures other than the current culture, call the <ph id="ph1">&lt;xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>A standard or custom numeric format string.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The string representation of the current instance in Cartesian form.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is not a valid format string.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form <ph id="ph1">`(`</ph><bpt id="p1">*</bpt>a<ept id="p1">*</ept><ph id="ph2">`,`</ph> <bpt id="p2">*</bpt>b<ept id="p2">*</ept><ph id="ph3">`)`</ph>, where <bpt id="p3">*</bpt>a<ept id="p3">*</ept> is the real part of the complex number, and <bpt id="p4">*</bpt>b<ept id="p4">*</ept> is its imaginary part.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>Both <bpt id="p1">*</bpt>a<ept id="p1">*</ept> and <bpt id="p2">*</bpt>b<ept id="p2">*</ept> are formatted using the format string specified by <ph id="ph1">`format`</ph>.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String?displayProperty=fullName&gt;</ph> or is <ph id="ph3">`null`</ph>, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format strings, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the <ph id="ph1">`format`</ph> parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the returned string is formatted using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter can be one of the following:</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>A custom object that implements the <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>A standard or custom numeric format string.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The string representation of the current instance in Cartesian form, as specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">format</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">provider</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is not a valid format string.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Returns a new <ph id="ph1">&lt;xref href="System.Numerics.Complex"&gt;&lt;/xref&gt;</ph> instance with a real number equal to zero and an imaginary number equal to zero.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.Complex.Zero&gt;</ph> property is most frequently used to compare a <ph id="ph2">&lt;xref:System.Numerics.Complex&gt;</ph> value to zero.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>