<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">22169acf856e57cc5eb09c6247f5eb11782361fb</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Numerics.BigInteger.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ddd1d88bb322c3ab180d2067d8102ecea4081eb</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ed35d9b3e605dba51d65f338c71b6da0cf61f9e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents an arbitrarily large signed integer.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type is an immutable type that represents an arbitrarily large integer whose value in theory has no upper or lower bounds.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The members of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type closely parallel those of other integral types (the <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.Int64&gt;</ph>, <ph id="ph6">&lt;xref:System.SByte&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph8">&lt;xref:System.UInt32&gt;</ph>, and <ph id="ph9">&lt;xref:System.UInt64&gt;</ph> types).</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>This type differs from the other integral types in the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, which have a range indicated by their <ph id="ph2">`MinValue`</ph> and <ph id="ph3">`MaxValue`</ph> properties.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type is immutable (see <bpt id="p1">[</bpt>Mutability and the BigInteger Structure<ept id="p1">](#mutability)</ept>) and because it has no upper or lower bounds, an <ph id="ph2">&lt;xref:System.OutOfMemoryException&gt;</ph> can be thrown for any operation that causes a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to grow too large.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instantiating a BigInteger Object</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object in several ways:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">`new`</ph> keyword and provide any integral or floating-point value as a parameter to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Floating-point values are truncated before they are assigned to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph>.) The following example illustrates how to use the <ph id="ph2">`new`</ph> keyword to instantiate <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can declare a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable and assign it a value just as you would any numeric type, as long as that value is an integral type.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses assignment to create a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from an <ph id="ph2">&lt;xref:System.Int64&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can assign a decimal or floating-point value to a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object if you cast the value or convert it first.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example explicitly casts (in C#) or converts (in Visual Basic) a <ph id="ph1">&lt;xref:System.Double&gt;</ph> and a <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>These methods enable you to instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is in the range of one of the existing numeric types only.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value can exceed the range of the existing numeric types in one of three ways:</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the <ph id="ph1">`new`</ph> keyword and provide a byte array of any size to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=fullName&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> methods to convert the string representation of a number to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> method that performs some operation on a numeric expression and returns a calculated <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> result.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example does this by cubing <ph id="ph1">&lt;xref:System.UInt64.MaxValue?displayProperty=fullName&gt;</ph> and assigning the result to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The uninitialized value of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> is <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Zero%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performing Operations on BigInteger Values</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> instance as you would use any other integral type.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> overloads the standard numeric operators to enable you to perform basic mathematical operations such as addition, subtraction, division, multiplication, subtraction, negation, and unary negation.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use the standard numeric operators to compare two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values with each other.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Like the other integral types, <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> also supports the bitwise <ph id="ph2">`And`</ph>, <ph id="ph3">`Or`</ph>, <ph id="ph4">`XOr`</ph>, left shift, and right shift operators.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>For languages that do not support custom operators, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure also provides equivalent methods for performing mathematical operations.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>These include <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph>, and several others.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>Many members of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure correspond directly to members of the other integral types.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> adds members such as the following:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.Sign%2A&gt;</ph>, which returns a value that indicates the sign of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph>, which returns the absolute value of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph>, which returns both the quotient and remainder of a division operation.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph>, which returns the greatest common divisor of two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Many of these additional members correspond to the members of the <ph id="ph1">&lt;xref:System.Math&gt;</ph> class, which provides the functionality to work with the primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Mutability and the BigInteger Structure</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object and then increments its value by one.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.Mutability#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.Mutability#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although this example appears to modify the value of the existing object, this is not the case.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects are immutable, which means that internally, the common language runtime actually creates a new <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object and assigns it a value one greater than its previous value.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>This new object is then returned to the caller.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>The other numeric types in the .NET Framework are also immutable.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type has no upper or lower bounds, its values can grow extremely large and have a measurable impact on performance.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although this process is transparent to the caller, it does incur a performance penalty.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, especially when repeated operations are performed in a loop on very large <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values, that performance penalty can be significant.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, in the following example, an operation is performed repetitively up to a million times, and a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is incremented by one every time the operation succeeds.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.Mutability#12<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.Mutability#12<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>In such a case, you can improve performance by performing all intermediate assignments to an <ph id="ph1">&lt;xref:System.Int32&gt;</ph> variable.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The final value of the variable can then be assigned to the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object when the loop exits.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.Mutability#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.Mutability#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Working with Byte Arrays and Hexadecimal Strings</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you convert <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values to byte arrays, or if you convert byte arrays to <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values, you must consider the order of bytes.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure expects the individual bytes in a byte array to appear in little-endian order (that is, the lower-order bytes of the value precede the higher-order bytes).</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can round-trip a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value by calling the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> method and then passing the resulting byte array to the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>To instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from a byte array that represents a value of some other integral type, you can pass the integral value to the <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=fullName&gt;</ph> method, and then pass the resulting byte array to the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example instantiates a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from a byte array that represents an <ph id="ph2">&lt;xref:System.Int16&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure assumes that negative values are stored by using two's complement representation.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure represents a numeric value with no fixed length, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor always interprets the most significant bit of the last byte in the array as a sign bit.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>To prevent the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor from confusing the two's complement representation of a negative value with the sign and magnitude representation of a positive value, positive values in which the most significant bit of the last byte in the byte array would ordinarily be set should include an additional byte whose value is 0.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, 0xC0 0xBD 0xF0 0xFF is the little-endian hexadecimal representation of either -1,000,000 or 4,293,967,296.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the most significant bit of the last byte in this array is on, the value of the byte array would be interpreted by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor as -1,000,000.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>To instantiate a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> whose value is positive, a byte array whose elements are 0xC0 0xBD 0xF0 0xFF 0x00 must be passed to the constructor.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>Byte arrays created by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> method from positive values include this extra zero-value byte.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure can successfully round-trip values by assigning them to, and then restoring them from, byte arrays, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, you may need to add this additional zero-value byte to byte arrays that are created dynamically by the developer or that are returned by methods that convert unsigned integers to byte arrays (such as <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=fullName&gt;</ph>, <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=fullName&gt;</ph>, and <ph id="ph3">&lt;xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=fullName&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>When parsing a hexadecimal string, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> methods assume that if the most significant bit of the first byte in the string is set, or if the first hexadecimal digit of the string represents the lower four bits of a byte value, the value is represented by using two's complement representation.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, both "FF01" and "F01" represent the decimal value -255.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>To differentiate positive from negative values, positive values should include a leading zero.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>The relevant overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, when they are passed the "X" format string, add a leading zero to the returned hexadecimal string for positive values.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>This makes it possible to round-trip <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values by using the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> methods, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the hexadecimal strings created by calling the <ph id="ph1">`ToString`</ph> methods of the other integral types or the overloads of the <ph id="ph2">&lt;xref:System.Convert.ToString%2A&gt;</ph> method that include a <ph id="ph3">`toBase`</ph> parameter do not indicate the sign of the value or the source data type from which the hexadecimal string was derived.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Successfully instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value from such a string requires some additional logic.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example provides one possible implementation.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Class.ByteAndHex#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure using the values in a byte array.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>The individual bytes in the <ph id="ph1">`value`</ph> array should be in little-endian order, from lowest-order byte to highest-order byte.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the numeric value 1,000,000,000,000 is represented as shown in the following table:</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>Hexadecimal string</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>E8D4A51000</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>Byte array (lowest index first)</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>00 10 A5 D4 E8 00</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most methods that convert numeric values to byte arrays, such as <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=fullName&gt;</ph>, return byte arrays in little-endian order.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>The constructor expects positive values in the byte array to use sign-and-magnitude representation, and negative values to use two's complement representation.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, if the highest-order bit of the highest-order byte in <ph id="ph1">`value`</ph> is set, the resulting <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is negative.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the source of the byte array, this may cause a positive value to be misinterpreted as a negative value.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>Byte arrays are typically generated in the following ways:</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>By calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because this method returns a byte array with the highest-order bit of the highest-order byte in the array set to zero for positive values, there is no chance of misinterpreting a positive value as negative.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unmodified byte arrays created by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToByteArray%2A&gt;</ph> method always successfully round-trip when they are passed to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>By calling the <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=fullName&gt;</ph> method and passing it a signed integer as a parameter.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because signed integers handle both sign-and-magnitude representation and two's complement representation, there is no chance of misinterpreting a positive value as negative.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>By calling the <ph id="ph1">&lt;xref:System.BitConverter.GetBytes%2A?displayProperty=fullName&gt;</ph> method and passing it an unsigned integer as a parameter.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because unsigned integers are represented by their magnitude only, positive values can be misinterpreted as negative values.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>To prevent this misinterpretation, you can add a zero-byte value to the end of the array.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>The example in the next section provides an illustration.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>By creating a byte array either dynamically or statically without necessarily calling any of the previous methods, or by modifying an existing byte array.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>To prevent positive values from being misinterpreted as negative values, you can add a zero-byte value to the end of the array.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is an empty <ph id="ph2">&lt;xref:System.Byte&gt;</ph> array, the new <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is initialized to a value of <ph id="ph4">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, the constructor throws an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>An array of byte values in little-endian order.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure using a <ph id="ph2">&lt;xref href="System.Decimal"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result of calling this constructor is identical to explicitly assigning a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling this constructor can cause data loss; any fractional part of <ph id="ph1">`value`</ph> is truncated when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>A decimal number.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure using a double-precision floating-point value.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of the lack of precision of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> data type, calling this constructor can cause data loss.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from explicitly assigning a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point value.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.Double.NaN"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.Double.NegativeInfinity"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.Double.PositiveInfinity"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure using a 32-bit signed integer value.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object by using this constructor.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> structure does not include constructors with a parameter of type <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.SByte&gt;</ph>, or <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type supports the implicit conversion of 8-bit and 16-bit signed and unsigned integers to signed 32-bit integers.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a result, this constructor is called if <ph id="ph1">`value`</ph> is any one of these four integral types.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure using a 64-bit signed integer value.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object by using this constructor.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>A 64-bit signed integer.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure using a single-precision floating-point value.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any fractional part of the <ph id="ph1">`value`</ph> parameter is truncated when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of the lack of precision of the <ph id="ph1">&lt;xref:System.Single&gt;</ph> data type, calling this constructor can result in data loss.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from explicitly assigning a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>A single-precision floating-point value.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.Single.NaN"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.Single.NegativeInfinity"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">&lt;xref href="System.Single.PositiveInfinity"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure using an unsigned 32-bit integer value.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> using this constructor.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning a <ph id="ph2">&lt;xref:System.UInt32&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>An unsigned 32-bit integer value.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> structure with an unsigned 64-bit integer value.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is no loss of precision when instantiating a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> using this constructor.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that results from calling this constructor is identical to the value that results from assigning a <ph id="ph2">&lt;xref:System.UInt64&gt;</ph> value to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>An unsigned 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Gets the absolute value of a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>The absolute value of a number is that number without its sign, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> parameter</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> &gt;= 0</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> &lt; 0</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> * -1</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Abs%2A&gt;</ph> method is equivalent to the <ph id="ph2">&lt;xref:System.Math.Abs%2A?displayProperty=fullName&gt;</ph> method for the primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>A number.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The absolute value of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Adds two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values and returns the result.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support operator overloading or custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> method to perform addition using <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> method is a useful substitute for the addition operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by assigning it a sum that results from addition, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.OperationMethods#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.OperationMethods#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The first value to add.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The second value to add.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Compares two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values and returns an integer that indicates whether the first value is less than, equal to, or greater than the second value.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> type has no fixed range, comparisons of <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values are not characterized by the lack of precision that characterizes the comparison of floating-point numbers.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example compares two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values that differ by one and that each have 1,896 digits.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> method correctly reports that the two values are not equal.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Compare#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Compare#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>A signed integer that indicates the relative values of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Value</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Condition</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;left&lt;/code&gt;</ph> is less than <ph id="ph2">&lt;code&gt;right&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;left&lt;/code&gt;</ph> equals <ph id="ph2">&lt;code&gt;right&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;left&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;code&gt;right&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Compares this instance to an unsigned 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the unsigned 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The unsigned 64-bit integer to compare.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>A signed integer that indicates the relative value of this instance and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept>, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The current instance is less than <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>The current instance is greater than <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Compares this instance to a specified object and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%2A&gt;</ph> method implements the <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is used by non-generic collection objects to order the items in the collection.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`obj`</ph> parameter must be one of the following:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source>An object whose run-time type is <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>An <ph id="ph1">&lt;xref:System.Object&gt;</ph> variable whose value is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value of the <ph id="ph1">`obj`</ph> parameter is <ph id="ph2">`null`</ph>, the method returns 1, which indicates that that the current instance is greater than <ph id="ph3">`obj`</ph>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>The object to compare.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>A signed integer that indicates the relationship of the current instance to the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept> parameter, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The current instance is less than <ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>The current instance is greater than <ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph>, or the <ph id="ph2">&lt;code&gt;obj&lt;/code&gt;</ph> parameter is <ph id="ph3">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;obj&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Compares this instance to a second <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the specified object.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%2A&gt;</ph> method implements the <ph id="ph2">&lt;xref:System.IComparable%601.CompareTo%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is used by generic collection objects to order the items in the collection.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>The object to compare.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>A signed integer value that indicates the relationship of this instance to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept>, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>The current instance is less than <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The current instance is greater than <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Compares this instance to a signed 64-bit integer and returns an integer that indicates whether the value of this instance is less than, equal to, or greater than the value of the signed 64-bit integer.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the <ph id="ph9">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>The signed 64-bit integer to compare.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>A signed integer value that indicates the relationship of this instance to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">other</ph><ept id="p1">&lt;/code&gt;</ept>, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Less than zero</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The current instance is less than <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>The current instance equals <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Greater than zero</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The current instance is greater than <ph id="ph1">&lt;code&gt;other&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Divides one <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value by another and returns the result.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method performs integer division; any remainder that results from the division is discarded.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform integer division while preserving the remainder, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>To retrieve only the remainder, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method can be used by languages that do not support operator overloading.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its behavior is identical to division using the division operator.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The value to be divided.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>The value to divide by.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The quotient of the division.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;divisor&lt;/code&gt;</ph> is 0 (zero).</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Divides one <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value by another, returns the result, and returns the remainder in an output parameter.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method preserves both the quotient and the remainder that results from integer division.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are not interested in the remainder, use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method or the division operator; if you are only interested in the remainder, use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign of the returned <ph id="ph1">`remainder`</ph> value is the same as the sign of the <ph id="ph2">`dividend`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.DivRem%2A&gt;</ph> method is identical to that of the <ph id="ph2">&lt;xref:System.Math.DivRem%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The value to be divided.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>The value to divide by.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>When this method returns, contains a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value that represents the remainder from the division.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The quotient of the division.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;divisor&lt;/code&gt;</ph> is 0 (zero).</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the current instance and a signed 64-bit integer have the same value.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the method is called.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the relationship between the two objects instead of just testing for equality, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>The signed 64-bit integer value to compare.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the signed 64-bit integer and the current instance have the same value; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the current instance and a specified <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object have the same value.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface and performs slightly better than <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Equals%28System.Object%29&gt;</ph> because it does not have to convert the <ph id="ph3">`other`</ph> parameter to a <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the relationship between the two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects instead of just testing for equality, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>The object to compare.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">other</ph><ept id="p1">&lt;/code&gt;</ept> have the same value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the current instance and a specified object have the same value.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`obj`</ph> argument is not a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the method returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method returns <ph id="ph1">`true`</ph> only if <ph id="ph2">`obj`</ph> is a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> instance whose value is equal to the current instance.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the relationship between the two objects instead of just testing for equality, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Object%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The object to compare.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> argument is a <ph id="ph3">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object, and its value is equal to the value of the current <ph id="ph4">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> instance; otherwise, <ph id="ph5">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the current instance and an unsigned 64-bit integer have the same value.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine the relationship between the two objects instead of just testing for equality, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>The unsigned 64-bit integer to compare.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current instance and the unsigned 64-bit integer have the same value; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Returns the hash code for the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer hash code.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Finds the greatest common divisor of two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>The greatest common divisor is the largest number into which the two <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values can be divided without returning a remainder.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`left`</ph> and <ph id="ph2">`right`</ph> parameters are non-zero numbers, the method always returns at least a value of 1 because all numbers can be divided by 1.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>If either parameter is zero, the method returns the absolute value of the non-zero parameter.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>If both values are zero, the method returns zero.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>Computing the greatest common divisor of very large values of <ph id="ph1">`left`</ph> and <ph id="ph2">`right`</ph> can be a very time-consuming operation.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>The value returned by the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A&gt;</ph> method is always positive regardless of the sign of the <ph id="ph2">`left`</ph> and <ph id="ph3">`right`</ph> parameters.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The first value.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>The second value.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is an even number.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is a convenience feature that indicates whether a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is evenly divisible by two.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is equivalent to the following expression:</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value of the current <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=fullName&gt;</ph>, the property returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is an even number; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is <ph id="ph2">&lt;xref href="System.Numerics.BigInteger.One"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property offers significantly better performance than other comparisons with one, such as <ph id="ph1">`thisBigInteger.Equals(BigInteger.One)`</ph>.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is <ph id="ph3">&lt;xref href="System.Numerics.BigInteger.One"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is a power of two.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property determines whether a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value has a single non-zero bit set.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that it returns <ph id="ph1">`true`</ph> if the value of the current <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is 1 (that is, 2<bpt id="p1">&lt;sup&gt;</bpt>0<ept id="p1">&lt;/sup&gt;</ept>) or any greater power of two.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>It returns <ph id="ph1">`false`</ph> if the value of the current <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is 0.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is a power of two; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Indicates whether the value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is <ph id="ph2">&lt;xref href="System.Numerics.BigInteger.Zero"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property offers significantly better performance than <ph id="ph1">`BigInteger.Equals(BigInteger.Zero)`</ph>.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the value of the <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object is <ph id="ph3">&lt;xref href="System.Numerics.BigInteger.Zero"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>Returns the natural (base <ph id="ph1">`e`</ph>) logarithm of a specified number.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter is specified as a base 10 number.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precise return value of this method depends on the sign of <ph id="ph1">`value`</ph>, as the following table shows.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sign of <ph id="ph1">`value`</ph> parameter</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>Positive</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The natural logarithm of <ph id="ph1">`value`</ph>; that is, ln <ph id="ph2">`value`</ph>, or log e<ph id="ph3">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double.NegativeInfinity&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>Negative</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double.NaN&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the base 10 logarithm of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log10%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the logarithm of a number in another base, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can find the square root of a number by calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%2A&gt;</ph> method along with the <ph id="ph2">&lt;xref:System.Math.Exp%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that the result is <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=fullName&gt;</ph> if the result is greater than <ph id="ph2">&lt;xref:System.Double.MaxValue?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example calculates the square root of each element in an array of <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Log#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Log#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Log%28System.Double%29?displayProperty=fullName&gt;</ph> method for the primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>The number whose logarithm is to be found.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The natural (base <ph id="ph1">`e`</ph>) logarithm of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>, as shown in the table in the Remarks section.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>The natural log of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is out of range of the <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> data type.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Returns the logarithm of a specified number in a specified base.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> and <ph id="ph2">`baseValue`</ph> parameters are specified as base 10 numbers.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precise return value of the method depends on the sign of <ph id="ph1">`value`</ph> and on the sign and value of <ph id="ph2">`baseValue`</ph>, as the following table shows.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> parameter</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`baseValue`</ph> parameter</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> &gt; 0</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>(0 &lt; <ph id="ph1">`baseValue`</ph> &lt; 1) -or-(<ph id="ph2">`baseValue`</ph> &gt; 1)</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>logbaseValue(<ph id="ph1">`value`</ph>)</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> &lt; 0</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>(any value)</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>(any value)</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`baseValue`</ph> &lt; 0</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> != 1</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`baseValue`</ph> = 0</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> != 1</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>(any value)</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>(any value)</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`baseValue`</ph> = 1</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> = 0</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>0 &lt; <ph id="ph1">`baseValue`</ph> &lt; 1</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> = 0</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`baseValue`</ph> &gt; 1</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> = 1</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`baseValue`</ph> = 0</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`value`</ph> = 1</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the base 10 logarithm of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log10%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the natural logarithm of a number, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Log%2A?displayProperty=fullName&gt;</ph> method for the primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>A number whose logarithm is to be found.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>The base of the logarithm.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>The base <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">baseValue</ph><ept id="p1">&lt;/code&gt;</ept> logarithm of <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p2">&lt;/code&gt;</ept>, as shown in the table in the Remarks section.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>The log of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is out of range of the <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> data type.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Returns the base 10 logarithm of a specified number.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter is specified as a base 10 number.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>The precise return value of the method depends on the sign of <ph id="ph1">`value`</ph>, as the following table shows.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>Sign of value parameter</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>Positive</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>The base 10 log of <ph id="ph1">`value`</ph>; that is, log10<ph id="ph2">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Zero</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>Negative</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Double?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the natural logarithm of a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>To calculate the logarithm of a number in another base, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Log10%2A?displayProperty=fullName&gt;</ph> method for the primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>A number whose logarithm is to be found.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>The base 10 logarithm of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>, as shown in the table in the Remarks section.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The base 10 log of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is out of range of the <ph id="ph2">&lt;xref href="System.Double"&gt;&lt;/xref&gt;</ph> data type.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Returns the larger of two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Max%2A?displayProperty=fullName&gt;</ph> method for primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept> parameter, whichever is larger.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Returns the smaller of two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Min%2A?displayProperty=fullName&gt;</ph> method for primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> or <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept> parameter, whichever is smaller.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Gets a value that represents the number negative one (-1).</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.MinusOne%2A&gt;</ph> property is used to compare a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to -1 or to assign -1 to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>An integer whose value is negative one (-1).</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>Performs modulus division on a number raised to the power of another number.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ModPow%2A&gt;</ph> method evaluates the following expression:</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>(baseValue ^ exponent) Mod modulus</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>To perform exponentiation on <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values without modulus division, use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>The number to raise to the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">exponent</ph><ept id="p1">&lt;/code&gt;</ept> power.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>The exponent to raise <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> by.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>The number by which to divide <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> raised to the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">exponent</ph><ept id="p2">&lt;/code&gt;</ept> power.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>The remainder after dividing <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept><bpt id="p2">&lt;sup&gt;</bpt>exponent<ept id="p2">&lt;/sup&gt;</ept> by <bpt id="p3">&lt;code&gt;</bpt><ph id="ph2">modulus</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;modulus&lt;/code&gt;</ph> is zero.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;exponent&lt;/code&gt;</ph> is negative.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>Returns the product of two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> method is implemented for languages that do not support operator overloading.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its behavior is identical to multiplication using the multiplication operator.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> method is a useful substitute for the multiplication operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by assigning it a product that results from multiplication, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.OperationMethods#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.OperationMethods#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>If necessary, this method automatically performs implicit conversion of other integral types to <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is illustrated in the example in the next section, where the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Multiply%2A&gt;</ph> method is passed two <ph id="ph2">&lt;xref:System.Int64&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>The first number to multiply.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The second number to multiply.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>The product of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>Negates a specified <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT">
          <source>Negation obtains the additive inverse of a number.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>The additive inverse of a number is a number that produces a value of zero when it is added to the original number.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its behavior is identical to negation using the unary negation operator.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> method is a useful substitute for the negation operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.OperationMethods#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.OperationMethods#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>The value to negate.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>The result of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter multiplied by negative one (-1).</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Gets a value that represents the number one (1).</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.One%2A&gt;</ph> property is usually used to compare a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value to 1 or to assign 1 to a <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>An object whose value is one (1).</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Adds the values of two specified <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Addition%2A&gt;</ph> method defines the addition operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#12<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#12<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>The first value to add.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>The second value to add.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>The sum of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>Performs a bitwise <ph id="ph1">`And`</ph> operation on two <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> method defines the bitwise <ph id="ph2">`And`</ph> operation for <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT">
          <source>The bitwise <ph id="ph1">`And`</ph> operation sets a result bit only if the corresponding bits in <ph id="ph2">`left`</ph> and <ph id="ph3">`right`</ph> are also set, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit in <ph id="ph1">`left`</ph></source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit in <ph id="ph1">`right`</ph></source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit in result</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> method enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseAnd%2A&gt;</ph> method performs the bitwise <ph id="ph2">`And`</ph> operation on two <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values as if they were both in two's complement representation with virtual sign extension.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The first value.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>The second value.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>The result of the bitwise <ph id="ph1">`And`</ph> operation.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Performs a bitwise <ph id="ph1">`Or`</ph> operation on two <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> method defines the bitwise <ph id="ph2">`Or`</ph> operation for <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT">
          <source>The bitwise <ph id="ph1">`Or`</ph> operation sets a result bit only if either or both of the corresponding bits in <ph id="ph2">`left`</ph> and <ph id="ph3">`right`</ph> are set, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit in <ph id="ph1">`left`</ph></source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit in <ph id="ph1">`right`</ph></source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit in result</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> method enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_BitwiseOr%2A&gt;</ph> method performs the bitwise <ph id="ph2">`Or`</ph> operation on two <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values as if they were both in two's complement representation with virtual sign extension.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>The first value.</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The second value.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source>The result of the bitwise <ph id="ph1">`Or`</ph> operation.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>Decrements a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value by 1.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> method defines the decrement operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#17<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects are immutable, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> operator creates a new <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is one less than the <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object represented by <ph id="ph5">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that repeated calls to <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Decrement%2A&gt;</ph> may be expensive.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>The value to decrement.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>The value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter decremented by 1.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>Divides a specified <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value by another specified <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value by using integer division.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Division%2A&gt;</ph> method defines the division operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#13<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#13<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators and operator overloading can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The value to be divided.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>The value to divide by.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>The integral result of the division.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;divisor&lt;/code&gt;</ph> is 0 (zero).</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a signed long integer value and a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value are equal.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=fullName&gt;</ph> instance method instead.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters have the same value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value and a signed long integer value are equal.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=fullName&gt;</ph> instance method instead.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters have the same value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether the values of two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> objects are equal.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method defines the operation of the equality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#19<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#19<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph> instance method instead.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters have the same value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value and an unsigned long integer value are equal.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=fullName&gt;</ph> instance method instead.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters have the same value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether an unsigned long integer value and a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value are equal.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method defines the equality comparison operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#7<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#7<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=fullName&gt;</ph> instance method instead.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> parameters have the same value; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>Performs a bitwise exclusive <ph id="ph1">`Or`</ph> (<ph id="ph2">`XOr`</ph>) operation on two <ph id="ph3">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>The result of a bitwise exclusive <ph id="ph1">`Or`</ph> operation is <ph id="ph2">`true`</ph> if the values of the two bits are different; otherwise, it is <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table illustrates the exclusive <ph id="ph1">`Or`</ph> operation.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit x in <ph id="ph1">`left`</ph></source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>Bit x in <ph id="ph1">`right`</ph></source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT">
          <source>Return value</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_ExclusiveOr%2A&gt;</ph> method enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#8<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#8<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_ExclusiveOr%2A&gt;</ph> method performs the bitwise exclusive <ph id="ph2">`Or`</ph> operation on two <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> values as if they were both in two's complement representation with virtual sign extension.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>The first value.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>The second value.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>The result of the bitwise <ph id="ph1">`Or`</ph> operation.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit signed integer is greater than a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#9<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#9<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> instance method instead.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#10<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> is greater than a 64-bit signed integer value.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#11<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#11<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#12<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is greater than another <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#20<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#20<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#21<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%2A&gt;</ph> Compare(System.Numeric s .BigInteger,System.Numeric s .BigInteger)?qualifyHint=True&amp;autoUpgrade=False</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is greater than a 64-bit unsigned integer.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#13<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#13<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#14<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is greater than a 64-bit unsigned integer.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%2A&gt;</ph> method defines the operation of the greater than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#15<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#15<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#16<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is greater than or equal to a 64-bit unsigned integer value.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#21<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#21<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#22<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is greater than or equal to another <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#22<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#22<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#23<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.%2A&gt;</ph> Compare(System.Numeric s .BigInteger,System.Numeric s .BigInteger)?qualifyHint=True&amp;autoUpgrade=False</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit unsigned integer is greater than or equal to a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#23<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#23<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#24<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit signed integer is greater than or equal to a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#17<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#17<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#18<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is greater than or equal to a 64-bit signed integer value.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A&gt;</ph> method defines the operation of the greater than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#19<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#19<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#20<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is greater than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>Increments a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value by 1.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> method defines the increment operation for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#24<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages (such as Visual Basic) that lack an increment operator or do not support operator overloading can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#25<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects are immutable, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> operator creates a new <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> object whose value is one more than the <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object represented by <ph id="ph5">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, repeated calls to <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Increment%2A&gt;</ph> may be expensive.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>The value to increment.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>The value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter incremented by 1.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit signed integer and a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value are not equal.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#25<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#25<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> instance method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and a signed long integer value.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=fullName&gt;</ph> instance method and reversing its value.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are not equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value and a 64-bit signed integer are not equal.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#26<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#26<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and a signed long integer value.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=fullName&gt;</ph> method and reversing its value.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are not equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> objects have different values.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#26<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#26<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=fullName&gt;</ph> method, which indicates the relationship between two <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph> method and reversing its value.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are not equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value and a 64-bit unsigned integer are not equal.</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#27<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#27<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and an unsigned long integer value.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=fullName&gt;</ph> method and reversing its value.</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are not equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit unsigned integer and a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value are not equal.</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#28<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#28<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can test for inequality by using one of the following techniques:</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method, which indicates the relationship between a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> and an unsigned long integer value.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=fullName&gt;</ph> method and reversing its value.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept> are not equal; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>Shifts a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value a specified number of bits to the left.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LeftShift%2A&gt;</ph> method defines the operation of the bitwise left-shift operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#29<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#29<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike the bitwise left-shift operation with integer primitives, the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LeftShift%2A&gt;</ph> method preserves the sign of the original <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can perform a bitwise left-shift operation by multiplying <ph id="ph1">`value`</ph> by <ph id="ph2">`BigInteger.Pow(2, shift)`</ph>.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows that the results are identical to the results of using this operator.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#30<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#30<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>The value whose bits are to be shifted.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>The number of bits to shift <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to the left.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>A value that has been shifted to the left by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit unsigned integer is less than a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#37<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#37<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#38<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is less than a 64-bit unsigned integer.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#35<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#35<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#36<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit signed integer is less than a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#31<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#31<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#32<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is less than a 64-bit signed integer.</source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#33<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#33<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#34<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is less than another <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%2A&gt;</ph> method defines the operation of the less than operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#27<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#27<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT">
          <source>Some languages can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#28<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit signed integer is less than or equal to a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#39<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#39<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#40<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`left`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than or equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is less than or equal to a 64-bit signed integer.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#41<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#41<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#42<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`right`</ph> is a <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.Int16&gt;</ph>, <ph id="ph4">&lt;xref:System.Int32&gt;</ph>, <ph id="ph5">&lt;xref:System.SByte&gt;</ph>, <ph id="ph6">&lt;xref:System.UInt16&gt;</ph>, or <ph id="ph7">&lt;xref:System.UInt32&gt;</ph> value, it is implicitly converted to an <ph id="ph8">&lt;xref:System.Int64&gt;</ph> value when the operation is performed.</source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than or equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is less than or equal to another <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#29<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#29<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#30<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than or equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value is less than or equal to a 64-bit unsigned integer.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#43<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#43<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#44<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than or equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether a 64-bit unsigned integer is less than or equal to a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A&gt;</ph> method defines the operation of the less than or equal to operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#45<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#45<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT">
          <source>They can also call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29&gt;</ph> method directly, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#46<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>The first value to compare.</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>The second value to compare.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is less than or equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Returns the remainder that results from division with two specified <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Modulus%2A&gt;</ph> method defines the operation of the modulus operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#31<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#31<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign of the value returned by the modulus operation depends on the sign of <ph id="ph1">`dividend`</ph>: If <ph id="ph2">`dividend`</ph> is positive, the modulus operation returns a positive result; if it is negative, the modulus operation returns a negative result.</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT">
          <source>The behavior of the modulus operation with <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> values is identical to the modulus operation with other integral types.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>The value to be divided.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>The value to divide by.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>The remainder that results from the division.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;divisor&lt;/code&gt;</ph> is 0 (zero).</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>Multiplies two specified <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Multiply%2A&gt;</ph> method defines the operation of the multiplication operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#11<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#11<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numeric%2A&gt;</ph> s .BigInteger.Multiply(System.Numeric s .BigInteger,System.Numeric s .BigInteger)?qualifyHint=True&amp;autoUpgrade=False</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source>The first value to multiply.</source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source>The second value to multiply.</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>The product of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">left</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">right</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>Returns the bitwise one's complement of a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> method defines the operation of the bitwise one's complement operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT">
          <source>The bitwise one's complement operator reverses each bit in a numeric value.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, bits in <ph id="ph1">`value`</ph> that are 0 are set to 1 in the result, and bits that are 1 are set to 0 in the result.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> method enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.OnesComplement#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.OnesComplement#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators may be able to call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_OnesComplement%2A&gt;</ph> method directly to perform a bitwise one's complement operation.</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example:</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-vb</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.OnesComplement#2<ept id="p2">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)</ept><ept id="p1">]</ept></source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source>An integer value.</source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>The bitwise one's complement of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>Shifts a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value a specified number of bits to the right.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_RightShift%2A&gt;</ph> method defines the operation of the bitwise right-shift operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#47<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#47<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can perform a bitwise right-shift operation by dividing <ph id="ph1">`value`</ph> by <ph id="ph2">`BigInteger.Pow(2, shift)`</ph> and subtracting 1 times <ph id="ph3">`shift`</ph> for negative values.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows that the results are identical to the results of using this operator.</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Operators#48<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Operators#48<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`shift`</ph> is greater than or equal to the number of bits in a positive <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the result of the right-shift operation is <ph id="ph3">&lt;xref:System.Numerics.BigInteger.Zero%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`shift`</ph> is greater than the number of bits in a negative <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the result of the right-shift operation is <ph id="ph3">&lt;xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source>The value whose bits are to be shifted.</source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>The number of bits to shift <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to the right.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source>A value that has been shifted to the right by the specified number of bits.</source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>Subtracts a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value from another <ph id="ph2">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_Subtraction%2A&gt;</ph> method defines the operation of the subtraction operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT">
          <source>It enables code such as the following:</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numeric.BigInteger.Class#14<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numeric.BigInteger.Class#14<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=fullName&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source>The value to subtract from (the minuend).</source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>The value to subtract (the subtrahend).</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source>The result of subtracting <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">right</ph><ept id="p1">&lt;/code&gt;</ept> from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source>Negates a specified BigInteger value.</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_UnaryNegation%2A&gt;</ph> method defines the operation of the unary negation operator (or the additive inverse operator) for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT">
          <source>The operation produces a value that results in 0 (zero) when it is added to the original number.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=fullName&gt;</ph></source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>The value to negate.</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>The result of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter multiplied by negative one (-1).</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>Returns the value of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> operand.</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>(The sign of the operand is unchanged.)</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.op_UnaryPlus%2A&gt;</ph> method defines the operation of the unary positive operator for <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>An integer value.</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>The value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> operand.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number in a specified style and culture-specific format to its <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the <ph id="ph2">`value`</ph> parameter for the parse operation to succeed.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`styles`</ph> must be a combination of bit flags from the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter makes this method overload useful when <ph id="ph2">`value`</ph> contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by <ph id="ph3">`value`</ph> is known only at run time, or when you want to disallow white space or a sign symbol in <ph id="ph4">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`value`</ph> parameter may include the following elements:</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[<bpt id="p6">*</bpt>.fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`style`</ph> includes <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph>, the <ph id="ph3">`value`</ph> parameter may include the following elements:</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional white space.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT">
          <source>White space can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific currency symbol.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName&gt;</ph> properties of the culture indicated by the <ph id="ph3">`provider`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT">
          <source>An optional sign.</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT">
          <source>Parentheses can be used in <ph id="ph1">`value`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of digits from 0 through 9.</source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT">
          <source>For <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept>, only the digit 0 is valid.</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific group separator symbol.</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT">
          <source>The group separator symbol of the culture specified by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT">
          <source>The decimal point symbol of the culture designated by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> includes any other digit, a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT">
          <source>E</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of hexadecimal digits from 0 through f, or 0 through F.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style) always parses successfully.</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most of the remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members affect the elements that may be present in <ph id="ph2">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT">
          <source>NumberStyles value</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements permitted in value in addition to digits</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>digits<ept id="p1">*</ept> element only.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT">
          <source>The decimal point (.) and <bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept> elements.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates exponential notation.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT">
          <source>along with <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT">
          <source>The group separator (,) element.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT">
          <source>The currency ($) element.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start or end of <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the start of <ph id="ph2">`value`</ph>, and the decimal point (.) symbol.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter can also use exponential notation.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, group separator (,), and decimal point (.) elements.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=fullName&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike the other <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> values, which allow for but do not require the presence of particular style elements in <ph id="ph2">`value`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style value means that the individual numeric characters in <ph id="ph4">`value`</ph> are always interpreted as hexadecimal characters.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid hexadecimal characters are 0-9, A-F, and a-f.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only other flags that can be combined with the <ph id="ph1">`style`</ph> parameter are <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT">
          <source>(The <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration includes a composite number style, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, that includes both white-space flags.)</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as <ph id="ph2">`0x`</ph> or <ph id="ph3">`&amp;h`</ph>) that differentiates it as a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes the conversion to fail.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is a hexadecimal string, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> method interprets <ph id="ph3">`value`</ph> as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to <ph id="ph4">`0x80`</ph>.</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, the method interprets the highest-order bit of the first byte in <ph id="ph1">`value`</ph> as the sign bit.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT">
          <source>To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in <ph id="ph1">`value`</ph> must have a value of zero.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the method interprets <ph id="ph1">`0x80`</ph> as a negative value, but it interprets either <ph id="ph2">`0x080`</ph> or <ph id="ph3">`0x0080`</ph> as a positive value.</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Parse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Parse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of <ph id="ph3">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Typically, <ph id="ph1">`provider`</ph> can be any one of the following:</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that provides numeric formatting information.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT">
          <source>A custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> and uses the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> method to instantiate and return the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture is used.</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>A string that contains a number to convert.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the enumeration values that specify the permitted format of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information about <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>A value that is equivalent to the number specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> includes the <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowHexSpecifier"&gt;&lt;/xref&gt;</ph> or <ph id="ph3">&lt;xref href="System.Globalization.NumberStyles.HexNumber"&gt;&lt;/xref&gt;</ph> flag along with another value.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> does not comply with the input pattern specified by <ph id="ph2">&lt;code&gt;style&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number in a specified culture-specific format to its <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter should be the string representation of a number in the following form:</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional white space.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT">
          <source>An optional sign.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid sign characters are determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=fullName&gt;</ph> properties of the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is returned by the <ph id="ph4">`provider`</ph> object's <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of digits ranging from 0 to 9.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any leading zeros are ignored.</source>
        </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string specified by the <ph id="ph1">`value`</ph> parameter is interpreted using the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style.</source>
        </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT">
          <source>It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</source>
        </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=fullName&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation whose <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method is invoked, it calls the <ph id="ph2">`provider`</ph> parameter's <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method and passes it a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method then returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides information about the format of the <ph id="ph3">`value`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are three ways to use the <ph id="ph1">`provider`</ph> parameter to supply custom formatting information to the parse operation:</source>
        </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
        </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass the actual <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
        </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
        </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass a custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
        </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the formatting of <ph id="ph3">`value`</ph> is interpreted based on the <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
        </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve">
          <source>A string that contains a number to convert.</source>
        </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve">
          <source>An object that provides culture-specific formatting information about <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve">
          <source>A value that is equivalent to the number specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is not in the correct format.</source>
        </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number in a specified style to its <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent.</source>
        </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space, the positive or negative sign symbol, the group separator symbol, or the decimal point symbol) that are allowed in the <ph id="ph2">`value`</ph> parameter for the parse operation to succeed.</source>
        </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`styles`</ph> must be a combination of bit flags from the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter makes this method overload useful when <ph id="ph2">`value`</ph> contains the string representation of a hexadecimal value, when the number system (decimal or hexadecimal) represented by <ph id="ph3">`value`</ph> is known only at run time, or when you want to disallow white space or a sign symbol in <ph id="ph4">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`value`</ph> parameter may include the following elements:</source>
        </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[.<bpt id="p6">*</bpt>fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`style`</ph> includes <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph>, the <ph id="ph3">`value`</ph> parameter may contain the following elements:</source>
        </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional white space.</source>
        </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT">
          <source>White space can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific currency symbol.</source>
        </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName&gt;</ph> properties of the current culture.</source>
        </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's currency symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT">
          <source>An optional sign.</source>
        </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT">
          <source>Parentheses can be used in <ph id="ph1">`value`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of digits from 0 through 9.</source>
        </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT">
          <source>For <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept>, only the digit 0 is valid.</source>
        </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific group separator symbol.</source>
        </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's group separator can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current culture's decimal point symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> includes any other digit, a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT">
          <source>E</source>
        </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of hexadecimal digits from 0 through f, or 0 through F.</source>
        </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string with digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style) always parses successfully.</source>
        </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most of the remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members control elements that may be present, but are not required to be present, in the input string.</source>
        </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members affect the elements that may be present in <ph id="ph2">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`NumberStyles`</ph> value</source>
        </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements permitted in <ph id="ph1">`value`</ph> in addition to digits</source>
        </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>digits<ept id="p1">*</ept> element only.</source>
        </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT">
          <source>The decimal point (.) and <bpt id="p1">*</bpt>fractional-digits<ept id="p1">*</ept> elements.</source>
        </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates exponential notation, along with <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
        </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT">
          <source>The group separator (,) element.</source>
        </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT">
          <source>The currency ($) element.</source>
        </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
        </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start or end of <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the start of <ph id="ph2">`value`</ph>, and the decimal point (<bpt id="p3">*</bpt>.<ept id="p3">*</ept>) symbol.</source>
        </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter can also use exponential notation.</source>
        </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`ws`</ph>, <ph id="ph2">`sign`</ph>, group separator (<bpt id="p1">*</bpt>,<ept id="p1">*</ept>), and decimal point (<bpt id="p2">*</bpt>.<ept id="p2">*</ept>) elements.</source>
        </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=fullName&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike the other <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> values, which allow for, but do not require, the presence of particular style elements in <ph id="ph2">`value`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style value means that the individual numeric characters in <ph id="ph4">`value`</ph> are always interpreted as hexadecimal characters.</source>
        </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid hexadecimal characters are 0-9, A-F, and a-f.</source>
        </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only other flags that can be combined with the <ph id="ph1">`style`</ph> parameter are <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT">
          <source>(The <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration includes a composite number style, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, that includes both white-space flags.)</source>
        </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as <ph id="ph2">`0x`</ph> or <ph id="ph3">`&amp;h`</ph>) that differentiates it as a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes the conversion to fail.</source>
        </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is a hexadecimal string, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29&gt;</ph> method interprets <ph id="ph3">`value`</ph> as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to <ph id="ph4">`0x80`</ph>.</source>
        </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, the method interprets the highest-order bit of the first byte in <ph id="ph1">`value`</ph> as the sign bit.</source>
        </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT">
          <source>To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in <ph id="ph1">`value`</ph> must have a value of zero.</source>
        </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the method interprets <ph id="ph1">`0x80`</ph> as a negative value, but it interprets either <ph id="ph2">`0x080`</ph> or <ph id="ph3">`0x0080`</ph> as a positive value.</source>
        </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</source>
        </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.Parse#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.Parse#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter is parsed by using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that is initialized for the current system culture.</source>
        </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT">
          <source>To specify the culture whose formatting information is used for the parse operation, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve">
          <source>A string that contains a number to convert.</source>
        </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve">
          <source>A bitwise combination of the enumeration values that specify the permitted format of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve">
          <source>A value that is equivalent to the number specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> includes the <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowHexSpecifier"&gt;&lt;/xref&gt;</ph> or <ph id="ph3">&lt;xref href="System.Globalization.NumberStyles.HexNumber"&gt;&lt;/xref&gt;</ph> flag along with another value.</source>
        </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> does not comply with the input pattern specified by <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve">
          <source>Converts the string representation of a number to its <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent.</source>
        </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter should be the string representation of a number in the following form.</source>
        </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional white space.</source>
        </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT">
          <source>An optional sign.</source>
        </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid sign characters are determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=fullName&gt;</ph> properties of the current culture.</source>
        </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of digits ranging from 0 to 9.</source>
        </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT">
          <source>Any leading zeros are ignored.</source>
        </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string specified by the <ph id="ph1">`value`</ph> parameter is interpreted by using the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style.</source>
        </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT">
          <source>It cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</source>
        </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter is parsed by using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo?displayProperty=fullName&gt;</ph> object that is initialized for the current system culture.</source>
        </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT">
          <source>To parse a string by using the formatting information of a specific culture, use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=fullName&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve">
          <source>A string that contains the number to convert.</source>
        </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve">
          <source>A value that is equivalent to the number specified in the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is not in the correct format.</source>
        </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve">
          <source>Raises a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value to the power of a specified value.</source>
        </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> method returns 1 if the value of the exponent parameter is 0, or if the values of both the <ph id="ph2">`value`</ph> and <ph id="ph3">`exponent`</ph> parameters are 0.</source>
        </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`exponent`</ph> is 1, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Pow%2A&gt;</ph> method returns <ph id="ph3">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is negative, the method returns a negative result.</source>
        </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method corresponds to the <ph id="ph1">&lt;xref:System.Math.Pow%2A?displayProperty=fullName&gt;</ph> method for primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve">
          <source>The number to raise to the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">exponent</ph><ept id="p1">&lt;/code&gt;</ept> power.</source>
        </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve">
          <source>The exponent to raise <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> by.</source>
        </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve">
          <source>The result of raising <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> to the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">exponent</ph><ept id="p2">&lt;/code&gt;</ept> power.</source>
        </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve">
          <source>The value of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">exponent</ph><ept id="p1">&lt;/code&gt;</ept> parameter is negative.</source>
        </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve">
          <source>Performs integer division on two <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> values and returns the remainder.</source>
        </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign of the remainder is the sign of the <ph id="ph1">`dividend`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Remainder%2A&gt;</ph> method is implemented for languages that do not support custom operators.</source>
        </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its behavior is identical to division using the modulus operator.</source>
        </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT">
          <source>If necessary, the method automatically performs implicit conversion of other integral types to <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> objects before it performs the modulus operation.</source>
        </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve">
          <source>The value to be divided.</source>
        </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve">
          <source>The value to divide by.</source>
        </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve">
          <source>The remainder after dividing <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">dividend</ph><ept id="p1">&lt;/code&gt;</ept> by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">divisor</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;divisor&lt;/code&gt;</ph> is 0 (zero).</source>
        </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve">
          <source>Gets a number that indicates the sign (negative, positive, or zero) of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Sign%2A&gt;</ph> property is equivalent to the <ph id="ph2">&lt;xref:System.Math.Sign%2A?displayProperty=fullName&gt;</ph> method for the primitive numeric types.</source>
        </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve">
          <source>A number that indicates the sign of the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object, as shown in the following table.</source>
        </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve">
          <source>Number</source>
        </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve">
          <source>-1</source>
        </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve">
          <source>The value of this object is negative.</source>
        </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve">
          <source>0</source>
        </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve">
          <source>The value of this object is 0 (zero).</source>
        </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve">
          <source>1</source>
        </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve">
          <source>The value of this object is positive.</source>
        </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve">
          <source>Subtracts one <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value from another and returns the result.</source>
        </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages that do not support custom operators can use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> method to perform subtraction using <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.Subtract%2A&gt;</ph> method is a useful substitute for the subtraction operator when instantiating a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> variable by assigning it the difference that results from subtraction, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.OperationMethods#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.OperationMethods#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve">
          <source>The value to subtract from (the minuend).</source>
        </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve">
          <source>The value to subtract (the subtrahend).</source>
        </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve">
          <source>The result of subtracting <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">right</ph><ept id="p1">&lt;/code&gt;</ept> from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve">
          <source>Converts a <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value to a byte array.</source>
        </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT">
          <source>The individual bytes in the array returned by this method appear in little-endian order.</source>
        </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, the lower-order bytes of the value precede the higher-order bytes.</source>
        </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first byte of the array reflects the first eight bits of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value, the second byte reflects the next eight bits, and so on.</source>
        </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the value 1024, or 0x0400, is stored as the following array of two bytes:</source>
        </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT">
          <source>Byte value</source>
        </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT">
          <source>0</source>
        </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT">
          <source>0x00</source>
        </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT">
          <source>1</source>
        </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT">
          <source>0x04</source>
        </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Negative values are written to the array using two's complement representation in the most compact form possible.</source>
        </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, -1 is represented as a single byte whose value is <ph id="ph1">`0xFF`</ph> instead of as an array with multiple elements, such as <ph id="ph2">`0xFF`</ph>, <ph id="ph3">`0xFF`</ph> or <ph id="ph4">`0xFF`</ph>, <ph id="ph5">`0xFF`</ph>, <ph id="ph6">`0xFF`</ph>, <ph id="ph7">`0xFF`</ph>.</source>
        </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because two's complement representation always interprets the highest-order bit of the last byte in the array (the byte at position <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=fullName&gt;</ph><ph id="ph2">`- 1`</ph>) as the sign bit, the method returns a byte array with an extra element whose value is zero to disambiguate positive values that could otherwise be interpreted as having their sign bits set.</source>
        </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the value 120 or <ph id="ph1">`0x78`</ph> is represented as a single-byte array: <ph id="ph2">`0x78`</ph>.</source>
        </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, 128, or <ph id="ph1">`0x80`</ph>, is represented as a two-byte array: <ph id="ph2">`0x80`</ph>, <ph id="ph3">`0x00`</ph>.</source>
        </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can round-trip a <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value by storing it to a byte array and then restoring it using the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your code modifies the value of individual bytes in the array returned by this method before it restores the value, you must make sure that you do not unintentionally change the sign bit.</source>
        </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if your modifications increase a positive value so that the highest-order bit in the last element of the byte array becomes set, you can add a new byte whose value is zero to the end of the array.</source>
        </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve">
          <source>The value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object converted to an array of bytes.</source>
        </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object to its equivalent string representation.</source>
        </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in the "R", or round-trip, format of the current culture.</source>
        </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a different format or culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT">
          <source>Round-trip ("R") format</source>
        </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format</source>
        </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format</source>
        </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> value includes a negative sign if its value is negative, and a sequence of digits ranging from 0 to 9 without leading zeros.</source>
        </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT">
          <source>The negative sign is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
        </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve">
          <source>The string representation of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object to its equivalent string representation by using the specified culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in the "R", or round-trip, format by using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of a specified culture.</source>
        </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to specify a different format or the current culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT">
          <source>Round-trip ("R") format</source>
        </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format</source>
        </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format</source>
        </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the string returned by this method.</source>
        </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value is formatted using the <ph id="ph4">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
        </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only property of the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that controls the string representation of the <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value using the general format specifier is <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=fullName&gt;</ph>, which defines the character that represents the negative sign.</source>
        </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter can be one of the following:</source>
        </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT">
          <source>A custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve">
          <source>The string representation of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value in the format specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">provider</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object to its equivalent string representation by using the specified format.</source>
        </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in a specified format by using a <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that represents the conventions of the current culture.</source>
        </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to use the "R", or round-trip, format or specify a different culture, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT">
          <source>Round-trip ("R") format</source>
        </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT">
          <source>Round-trip ("R") format</source>
        </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format</source>
        </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid <bpt id="p1">[</bpt>standard numeric string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, or any combination of <bpt id="p2">[</bpt>custom numeric format strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph> or is <ph id="ph3">`null`</ph>, the return value of the current <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is formatted with the round-trip format specifier ("R").</source>
        </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
        </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about support for formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT">
          <source>The format of the returned string is determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
        </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the <ph id="ph1">`format`</ph> parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</source>
        </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT">
          <source>To provide formatting information for cultures other than the current culture, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> overload.</source>
        </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve">
          <source>A standard or custom numeric format string.</source>
        </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve">
          <source>The string representation of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value in the format specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">format</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is not a valid format string.</source>
        </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve">
          <source>Converts the numeric value of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> object to its equivalent string representation by using the specified format and culture-specific format information.</source>
        </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method formats a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value in a specified format by using the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of a specified culture.</source>
        </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to use the round-trip format or default culture settings, use the other overloads of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, as follows:</source>
        </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use format</source>
        </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT">
          <source>For culture</source>
        </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the overload</source>
        </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT">
          <source>Round-trip ("R") format</source>
        </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT">
          <source>Round-trip ("R") format</source>
        </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific culture</source>
        </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT">
          <source>A specific format</source>
        </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default (current) culture</source>
        </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`format`</ph> parameter can be any valid  <bpt id="p1">[</bpt>standard numeric string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>, or any combination of <bpt id="p2">[</bpt>custom numeric format strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is equal to <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=fullName&gt;</ph> or is <ph id="ph3">`null`</ph>, the return value of the current <ph id="ph4">&lt;xref:System.Numerics.BigInteger&gt;</ph> object is formatted with the round-trip format specifier ("R").</source>
        </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`format`</ph> is any other value, the method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides extensive formatting support, which is described in greater detail in the following formatting topics:</source>
        </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about numeric format specifiers, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about support for formatting in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of the string returned by this method.</source>
        </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method is invoked, it calls the <ph id="ph2">`provider`</ph> parameter's <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method and passes it a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph5">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> type.</source>
        </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method then returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides information for formatting the <ph id="ph3">`value`</ph> parameter, such as the negative sign symbol, the group separator symbol, or the decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are three ways to use the <ph id="ph1">`provider`</ph> parameter to supply formatting information to the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29&gt;</ph> method:</source>
        </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
        </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass the actual <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
        </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
        </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can pass a custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
        </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the formatting of the returned string is based on the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object of the current culture.</source>
        </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve">
          <source>A standard or custom numeric format string.</source>
        </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information.</source>
        </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve">
          <source>The string representation of the current <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> value as specified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">format</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">provider</ph><ept id="p2">&lt;/code&gt;</ept> parameters.</source>
        </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;format&lt;/code&gt;</ph> is not a valid format string.</source>
        </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve">
          <source>Tries to convert the string representation of a number in a specified style and culture-specific format to its <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent, and returns a value that indicates whether the conversion succeeded.</source>
        </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method is like the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29&gt;</ph> method, except that it does not throw an exception if the conversion fails.</source>
        </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> if <ph id="ph2">`value`</ph> is invalid and cannot be parsed successfully.</source>
        </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`style`</ph> parameter defines the style elements (such as white space or a positive or negative sign) that are allowed in the <ph id="ph2">`value`</ph> parameter for the parse operation to succeed.</source>
        </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT">
          <source>It must be a combination of bit flags from the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration.</source>
        </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT">
          <source>Depending on the value of <ph id="ph1">`style`</ph>, the <ph id="ph2">`value`</ph> parameter may include the following elements:</source>
        </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt><ph id="ph1">$</ph><ept id="p2">*</ept>][<bpt id="p3">*</bpt>sign<ept id="p3">*</ept>][<bpt id="p4">*</bpt>digits<ept id="p4">*</ept>,]<bpt id="p5">*</bpt>digits<ept id="p5">*</ept>[.<bpt id="p6">*</bpt>fractional_digits<ept id="p6">*</ept>][E[<bpt id="p7">*</bpt>sign<ept id="p7">*</ept>]<bpt id="p8">*</bpt>exponential_digits<ept id="p8">*</ept>][<bpt id="p9">*</bpt>ws<ept id="p9">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`style`</ph> parameter includes <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.AllowHexSpecifier&gt;</ph>, the <ph id="ph3">`value`</ph> parameter may include the following elements:</source>
        </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>]<bpt id="p2">*</bpt>hexdigits<ept id="p2">*</ept>[<bpt id="p3">*</bpt>ws<ept id="p3">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional white space.</source>
        </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT">
          <source>White space can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, or at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific currency symbol.</source>
        </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its position in the string is defined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object returned by the <ph id="ph3">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method of the <ph id="ph4">`provider`</ph> parameter.</source>
        </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT">
          <source>The currency symbol can appear in <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT">
          <source>An optional sign.</source>
        </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The sign can appear at the start of <ph id="ph1">`value`</ph> if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag, and it can appear at the end of <ph id="ph4">`value`</ph> if <ph id="ph5">`style`</ph> includes the <ph id="ph6">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT">
          <source>Parentheses can be used in <ph id="ph1">`value`</ph> to indicate a negative value if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of digits from 0 through 9.</source>
        </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>,<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific group separator.</source>
        </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT">
          <source>The group separator of the culture specified by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT">
          <source>A culture-specific decimal point symbol.</source>
        </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT">
          <source>The decimal point symbol of the culture specified by <ph id="ph1">`provider`</ph> can appear in <ph id="ph2">`value`</ph> if <ph id="ph3">`style`</ph> includes the <ph id="ph4">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT">
          <source>One or more occurrences of the digit 0.</source>
        </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT">
          <source>Fractional digits can appear in <ph id="ph1">`value`</ph> only if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT">
          <source>E</source>
        </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates that the value is represented in exponential (scientific) notation.</source>
        </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of digits from 0 through 9.</source>
        </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter can represent a number in exponential notation if <ph id="ph2">`style`</ph> includes the <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag.</source>
        </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>hexdigits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of hexadecimal digits from 0 through f, or 0 through F.</source>
        </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT">
          <source>A string with decimal digits only (which corresponds to the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag) always parses successfully.</source>
        </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most of the remaining <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members control elements that may be present, but are not required to be present, in this input string.</source>
        </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table indicates how individual <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> members affect the elements that may be present in <ph id="ph2">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Non-composite <ph id="ph1">`NumberStyles`</ph> values</source>
        </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements permitted in value in addition to digits</source>
        </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT">
          <source>Decimal digits only.</source>
        </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT">
          <source>The decimal point (<bpt id="p1">*</bpt>.<ept id="p1">*</ept>) and <bpt id="p2">*</bpt>fractional_digits<ept id="p2">*</ept> elements.</source>
        </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <bpt id="p1">*</bpt>fractional_digits<ept id="p1">*</ept> must consist of only one or more 0 digits, or the method returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT">
          <source>The "e" or "E" character, which indicates exponential notation, along with <bpt id="p1">*</bpt>exponential_digits<ept id="p1">*</ept>.</source>
        </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> represents a number in exponential notation, it cannot have a non-zero, fractional component.</source>
        </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the end of <ph id="ph1">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element before <bpt id="p2">*</bpt>digits<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element after <bpt id="p2">*</bpt>digits<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>sign<ept id="p1">*</ept> element in the form of parentheses enclosing the numeric value.</source>
        </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT">
          <source>The group separator (<bpt id="p1">*</bpt>,<ept id="p1">*</ept>) element.</source>
        </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT">
          <source>The currency (<bpt id="p1">*</bpt><ph id="ph1">$</ph><ept id="p1">*</ept>) element.</source>
        </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number or a number in exponential notation.</source>
        </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept> element at the start or end of <ph id="ph1">`value`</ph>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept> at the start of <ph id="ph2">`value`</ph>, and the decimal point (<bpt id="p3">*</bpt>.<ept id="p3">*</ept>) symbol.</source>
        </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter can also use exponential notation.</source>
        </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <bpt id="p1">*</bpt>ws<ept id="p1">*</ept>, <bpt id="p2">*</bpt>sign<ept id="p2">*</ept>, group separator (<bpt id="p3">*</bpt>,<ept id="p3">*</ept>), and decimal point (<bpt id="p4">*</bpt>.<ept id="p4">*</ept>) elements.</source>
        </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT">
          <source>All elements.</source>
        </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`value`</ph> cannot represent a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you use the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> method to round-trip the string representation of a <ph id="ph2">&lt;xref:System.Numerics.BigInteger&gt;</ph> value that was output by the <ph id="ph3">&lt;xref:System.Numerics.BigInteger.ToString%2A&gt;</ph> method, you should use the <ph id="ph4">&lt;xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=fullName&gt;</ph> method with the "R" format specifier to generate the string representation of the <ph id="ph5">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the string representation of the <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> preserves only the 50 most significant digits of the original value, and data may be lost when you use the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%2A&gt;</ph> method to restore the <ph id="ph3">&lt;xref:System.Numerics.BigInteger&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> flag is used, <ph id="ph2">`value`</ph> must be a hexadecimal value.</source>
        </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT">
          <source>The only other flags that can be present in <ph id="ph1">`style`</ph> are <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT">
          <source>(The <ph id="ph1">&lt;xref:System.Globalization.NumberStyles&gt;</ph> enumeration has a composite style, <ph id="ph2">&lt;xref:System.Globalization.NumberStyles.HexNumber&gt;</ph>, that includes both white-space flags.)</source>
        </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is the string representation of a hexadecimal number, it cannot be preceded by any decoration (such as <ph id="ph2">`0x`</ph> or <ph id="ph3">`&amp;h`</ph>) that differentiates it as a hexadecimal number.</source>
        </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT">
          <source>This causes the conversion to fail.</source>
        </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`value`</ph> is a hexadecimal string, the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method interprets <ph id="ph3">`value`</ph> as a negative number stored by using two's complement representation if its first two hexadecimal digits are greater than or equal to <ph id="ph4">`0x80`</ph>.</source>
        </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, the method interprets the highest-order bit of the first byte in <ph id="ph1">`value`</ph> as the sign bit.</source>
        </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT">
          <source>To make sure that a hexadecimal string is correctly interpreted as a positive number, the first digit in <ph id="ph1">`value`</ph> must have a value of zero.</source>
        </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the method interprets <ph id="ph1">`0x80`</ph> as a negative value, but it interprets either <ph id="ph2">`0x080`</ph> or <ph id="ph3">`0x0080`</ph> as a positive value.</source>
        </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the difference between hexadecimal strings that represent negative and positive values.</source>
        </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Numerics.BigInteger.TryParse#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Numerics.BigInteger.TryParse#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides culture-specific information about the format of <ph id="ph3">`value`</ph>.</source>
        </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`provider`</ph> parameter can be any one of the following:</source>
        </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents the culture that supplies formatting information.</source>
        </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information for that culture.</source>
        </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides numeric formatting information.</source>
        </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Its implementation of <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> just returns itself.)</source>
        </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT">
          <source>A custom object that implements <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph> method instantiates and returns the <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object that provides formatting information.</source>
        </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`provider`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture is used.</source>
        </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve">
          <source>The string representation of a number.</source>
        </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve">
          <source>The string is interpreted using the style specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">style</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve">
          <source>A bitwise combination of enumeration values that indicates the style elements that can be present in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve">
          <source>A typical value to specify is <ph id="ph1">&lt;xref href="System.Globalization.NumberStyles.Integer"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve">
          <source>An object that supplies culture-specific formatting information about <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve">
          <source>When this method returns, contains the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent to the number that is contained in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>, or <ph id="ph3">&lt;xref href="System.Numerics.BigInteger.Zero"&gt;&lt;/xref&gt;</ph> if the conversion failed.</source>
        </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve">
          <source>The conversion fails if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> or is not in a format that is compliant with <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">style</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized.</source>
        </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter was converted successfully; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> is not a <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles"&gt;&lt;/xref&gt;</ph> value.</source>
        </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;style&lt;/code&gt;</ph> includes the <ph id="ph2">&lt;xref href="System.Globalization.NumberStyles.AllowHexSpecifier"&gt;&lt;/xref&gt;</ph> or <ph id="ph3">&lt;xref href="System.Globalization.NumberStyles.HexNumber"&gt;&lt;/xref&gt;</ph> flag along with another value.</source>
        </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve">
          <source>Tries to convert the string representation of a number to its <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent, and returns a value that indicates whether the conversion succeeded.</source>
        </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method is like the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.Parse%28System.String%29&gt;</ph> method, except that it does not throw an exception if the conversion fails.</source>
        </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method eliminates the need to use exception handling to test for a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> if <ph id="ph2">`value`</ph> is invalid and cannot be successfully parsed.</source>
        </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter should be the string representation of a decimal number in the following form:</source>
        </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT">
          <source>[<bpt id="p1">*</bpt>ws<ept id="p1">*</ept>][<bpt id="p2">*</bpt>sign<ept id="p2">*</ept>]<bpt id="p3">*</bpt>digits<ept id="p3">*</ept>[<bpt id="p4">*</bpt>ws<ept id="p4">*</ept>]</source>
        </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in square brackets ([ and ]) are optional.</source>
        </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table describes each element.</source>
        </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT">
          <source>Element</source>
        </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>ws<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT">
          <source>Optional white space.</source>
        </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>sign<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT">
          <source>An optional sign.</source>
        </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT">
          <source>Valid sign characters are determined by the <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=fullName&gt;</ph> properties of the current culture.</source>
        </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">*</bpt>digits<ept id="p1">*</ept></source>
        </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT">
          <source>A sequence of decimal digits ranging from 0 to 9.</source>
        </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT">
          <source>The string specified by the <ph id="ph1">`value`</ph> parameter cannot contain any group separators or decimal separator, and it cannot have a decimal portion.</source>
        </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter is interpreted by using the <ph id="ph2">&lt;xref:System.Globalization.NumberStyles?displayProperty=fullName&gt;</ph> style.</source>
        </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to the decimal digits, only leading and trailing spaces with a leading sign are allowed.</source>
        </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT">
          <source>To explicitly define the style elements with the culture-specific formatting information that can be present in <ph id="ph1">`value`</ph>, call the <ph id="ph2">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`value`</ph> parameter is parsed by using the formatting information in a <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for the current culture.</source>
        </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT">
          <source>This overload interprets all digits in the <ph id="ph1">`value`</ph> parameter as decimal digits.</source>
        </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT">
          <source>To parse the string representation of a hexadecimal number, call the <ph id="ph1">&lt;xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29&gt;</ph> overload instead.</source>
        </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve">
          <source>The string representation of a number.</source>
        </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve">
          <source>When this method returns, contains the <ph id="ph1">&lt;xref href="System.Numerics.BigInteger"&gt;&lt;/xref&gt;</ph> equivalent to the number that is contained in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept>, or zero (0) if the conversion fails.</source>
        </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve">
          <source>The conversion fails if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> or is not of the correct format.</source>
        </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve">
          <source>This parameter is passed uninitialized.</source>
        </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">value</ph><ept id="p1">&lt;/code&gt;</ept> was converted successfully; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve">
          <source>Gets a value that represents the number 0 (zero).</source>
        </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Numerics.BigInteger&gt;</ph> object returned by this property provides a convenient source of a zero value for use in assignments and comparisons.</source>
        </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve">
          <source>An integer whose value is 0 (zero).</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>